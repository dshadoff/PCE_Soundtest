#[1]   beep.s
    5                     
    6           0000      .ifdef _SGX
    8                     .endif
    9           0000      .ifdef _AC
   11                     .endif
   12                     
   13                     ; first, set MOUSE to default on:
   14                     ;
   15           0001      SUPPORT_MOUSE	.equ	1
   16                     
   18                     
   19           0001      .ifdef HUC
#[3]   huc.inc
   20                     .include "huc.inc"
    1                     ;
    2                     ; Hu-C internal include file
    3                     ;
    4                     
    5                     
    6                     ; variables
    7                     ; ----
    8                     
    9           2000      	.zp
   10  --:2000            __sp
   11  --:2000            __stack	.ds 2
   12  --:2002            __temp	.ds 4
   13  --:2006            __ptr	.ds 2
   14  --:2008            __fbank	.ds 1
   15  --:2009            __fptr	.ds 2
   16           0000      .ifdef HAVE_LIB3
   18                     .endif
   19                     
   20                     ; macros
   21                     ; ----
   22                     
   23                     	.macro	__farptr
   24                     	ldy	#bank(\1)
   25                     	sty	\2
   26                     	ldy	#low(\1)
   27                     	sty	\3
   28                     	ldy	#high(\1) & $1F
   29                     	sty	\3+1
   30                     .endm
   31                     
   32                     	.macro	__farptr_i
   33                     	sax
   34                     	add	#low(\1)
   35                     .if (\# = 3)
   36                     	sta	<\3
   37                     .else
   38                     	sta	<__fptr
   39                     .endif
   40                     	sax
   41                     	adc	#high(\1) & $1F
   42                     .if (\# = 3)
   43                     	sta	<\3+1
   44                     .else
   45                     	tax
   46                     .endif
   47                     	rol	A
   48                     	rol	A
   49                     	rol	A
   50                     	rol	A
   51                     	and	#$F
   52                     	add	#bank(\1)
   53                     .if (\# = 3)
   54                     	sta	<\2
   55                     .endif
   56                     .endm
   57                     
   58                     	.macro	__farptr_get
   59                     	stx	<\1
   60                     	ldy	#2
   61                     	lda	[__ptr],Y
   62                     	sta	<\2
   63                     	iny
   64                     	lda	[__ptr],Y
   65                     	sta	<\2+1
   66                     .endm
   67                     
   68                     	.macro	__fgetb
   69                     	tam	#3
   70                     	txa
   71                     	and	#$1F
   72                     	ora	#$60
   73                     	sta	<__fptr+1
   74                     	lda	[__fptr]
   75                     	tax
   76                     	bpl	.x_\@
   77                     	dec	A
   78                     .x_\@:
   79                     .endm
   80                     
   81                     	.macro	__fgetub
   82                     	tam	#3
   83                     	txa
   84                     	and	#$1F
   85                     	ora	#$60
   86                     	sta	<__fptr+1
   87                     	lda	[__fptr]
   88                     	tax
   89                     	cla
   90                     .endm
   91                     
   92                     __phax	.macro
   93                     	pha
   94                     	phx
   95                     .endm
   96                     __plax	.macro
   97                     	plx
   98                     	pla
   99                     .endm
  100                     __plxa	.macro
  101                     	pla
  102                     	plx
  103                     .endm
  104                     
  105                     __ldb	.macro
  106                     .if (\# = 2)
  107                     	clx
  108                     	lda	\1
  109                     	clc
  110                     	adc	#low(\2)
  111                     	sax
  112                     	adc	#high(\2)
  113                     .else
  114                     	ldx	\1
  115                     	__extw
  116                     .endif
  117                     .endm
  118                     
  119                     __ldby:	.macro
  120                     	ldx	\1, y
  121                     	__extw
  122                     .endm
  123                     
  124                     __ldub	.macro
  125                     .if (\# = 2)
  126                     	clx
  127                     	lda	\1
  128                     	clc
  129                     	adc	#low(\2)
  130                     	sax
  131                     .else
  132                     	ldx	\1
  133                     	cla
  134                     .endif
  135                     .endm
  136                     
  137                     __ldbp	.macro
  138                     	lda	[\1]
  139                     	tax
  140                     	__extw
  141                     .endm
  142                     
  143                     __ldubp	.macro
  144                     	lda	[\1]
  145                     	tax
  146                     	cla
  147                     .endm
  148                     
  149                     __stbps	.macro
  150                     	__phax
  151                     	__ldwp	__stack
  152                     	__stw	<__ptr
  153                     	__plxa
  154                     	sta	[__ptr]
  155                     	sax
  156                     	__addmi	2,__stack
  157                     .endm
  158                     
  159                     __ldw	.macro
  160                     .if (\# = 2)
  161                     	lda	\1
  162                     	clc
  163                     	adc	#low(\2)
  164                     	tax
  165                     	lda	\1+1
  166                     	adc	#high(\2)
  167                     .else
  168                     	ldx	\1
  169                     	lda	\1+1
  170                     .endif
  171                     .endm
  172                     
  173                     __ldwp	.macro
  174                     	lda	[\1]
  175                     	tax
  176                     	ldy	#1
  177                     	lda	[\1],Y
  178                     .endm
  179                     
  180                     __ldwi	.macro
  181                     	ldx	#low(\1)
  182                     	lda	#high(\1)
  183                     .endm
  184                     
  185                     __stw	.macro
  186                     	stx	\1
  187                     	sta	\1+1
  188                     .endm
  189                     
  190                     __stwi	.macro
  191                     	ldx	#low(\2)
  192                     	stx	\1
  193                     	lda	#high(\2)
  194                     	sta	\1 + 1
  195                     .endm
  196                     
  197                     __stbi	.macro
  198                     	ldx	#low(\2)
  199                     	stx	\1
  200                     	cla
  201                     .endm
  202                     
  203                     __stwz	.macro
  204                     	stz	\1
  205                     	stz	\1 + 1
  206                     .endm
  207                     
  208                     __stwp	.macro
  209                     	sax
  210                     	sta	[\1]
  211                     	sax
  212                     	ldy	#1
  213                     	sta	[\1],Y
  214                     .endm
  215                     
  216                     __stbp	.macro
  217                     	sax
  218                     	sta	[\1]
  219                     	sax
  220                     .endm
  221                     
  222                     __stwps	.macro
  223                     	__phax
  224                     	__ldwp	__stack
  225                     	__stw	<__ptr
  226                     	__plax
  227                     	__stwp	__ptr
  228                     	__addmi	2,__stack
  229                     .endm
  230                     
  231                     __stwip	.macro
  232                     	__stw	__ptr
  233                     	lda	#low(\1)
  234                     	tax
  235                     	sta	[__ptr]
  236                     	lda	#high(\1)
  237                     	ldy	#1
  238                     	sta	[__ptr],Y
  239                     .endm
  240                     
  241                     __stbip	.macro
  242                     	__stw	__ptr
  243                     	lda	#low(\1)
  244                     	sta	[__ptr]
  245                     	tax
  246                     	cla
  247                     .endm
  248                     
  249                     __pushw	.macro
  250                     .ifndef SMALL
  251                     	ldy	<__stack
  252                     	bne	.x_\@
  253                     	dec	<__stack + 1
  254                     .endif
  255                     .x_\@:	dec	<__stack
  256                     	sta	[__stack]
  257                     .ifndef SMALL
  258                     	bne	.y_\@
  259                     	dec	<__stack + 1
  260                     .endif
  261                     .y_\@:	dec	<__stack
  262                     	sax
  263                     	sta	[__stack]
  264                     	sax
  265                     .endm
  266                     
  267                     __popw	.macro
  268                     	lda	[__stack]
  269                     	tax
  270                     	ldy	#1
  271                     	lda	[__stack],Y
  272                     	__addmi	2,__stack
  273                     .endm
  274                     
  275                     __calls	.macro
  276                     	pha
  277                     	ldy	#\1
  278                     	lda	[__stack],Y
  279                     	sta	<__ptr
  280                     .ifndef SMALL
  281                     	incw	<__stack
  282                     .else
  283                     	inc	<__stack
  284                     .endif
  285                     	lda	[__stack],Y
  286                     	sta	<__ptr+1
  287                     .ifndef SMALL
  288                     	incw	<__stack
  289                     .else
  290                     	inc	<__stack
  291                     .endif
  292                     	pla
  293                     	jsr	hook
  294                     .endm
  295                     
  296                     __swapw	.macro
  297                     	pha
  298                     	ldy	#1
  299                     	lda	[__stack],Y
  300                     	sta	<__temp
  301                     	lda	[__stack]
  302                     	sax
  303                     	sta	[__stack]
  304                     	pla
  305                     	sta	[__stack],Y
  306                     	lda	<__temp
  307                     .endm
  308                     
  309                     
  310                     ; TODO : check if we need pha/pla or not
  311                     __tstw	.macro
  312                     	; pha
  313                     	stx	<__temp
  314                     	ora	<__temp
  315                     	cla
  316                     	clx
  317                     	beq	.x_\@
  318                     	inx
  319                     .x_\@:
  320                     	; pla
  321                     .endm
  322                     
  323                     __lsrw	.macro
  324                     	lsr	A
  325                     	sax
  326                     	ror	A
  327                     	sax
  328                     .endm
  329                     
  330                     __aslw	.macro
  331                     	sax
  332                     	asl	A
  333                     	sax
  334                     	rol	A
  335                     .endm
  336                     
  337                     __aslwi	.macro
  338                     .if (\1 = 1)
  339                     	__aslw
  340                     .else
  341                     .if (\1 = 2)
  342                     	__aslw
  343                     	__aslw
  344                     .else
  345                     .if (\1 = 8)
  346                     	txa
  347                     	clx
  348                     .else
  349                     	ldy	#\1
  350                     	jsr	aslzp
  351                     .endif
  352                     .endif
  353                     .endif
  354                     .endm
  355                     
  356                     __aslws	.macro
  357                     	lda	[__stack]
  358                     	asl	a
  359                     	sta	[__stack]
  360                     	ldy	#1
  361                     	lda	[__stack],Y
  362                     	rol	a
  363                     	sta	[__stack],Y
  364                     .endm
  365                     
  366                     __asrw	.macro
  367                     	cmp	#$80
  368                     	ror	A
  369                     	sax
  370                     	ror	A
  371                     	sax
  372                     .endm
  373                     
  374                     __asrwi	.macro
  375                     .if (\1 = 1)
  376                     	__asrw
  377                     .else
  378                     .if (\1 = 2)
  379                     	__asrw
  380                     	__asrw
  381                     .else
  382                     .if (\1 = 8)
  383                     	tax
  384                     	cmp	#$80
  385                     	cla
  386                     	bcc	.x_\@
  387                     	dec a
  388                     .x_\@:
  389                     .else
  390                     	ldy	#\1
  391                     	jsr	asrzp
  392                     .endif
  393                     .endif
  394                     .endif
  395                     .endm
  396                     
  397                     __lsrwi	.macro
  398                     .if (\1 = 1)
  399                     	__lsrw
  400                     .else
  401                     .if (\1 = 2)
  402                     	__lsrw
  403                     	__lsrw
  404                     .else
  405                     .if (\1 = 8)
  406                     	tax
  407                     	cla
  408                     .else
  409                     	ldy	#\1
  410                     	jsr	lsrzp
  411                     .endif
  412                     .endif
  413                     .endif
  414                     .endm
  415                     
  416                     __extw	.macro
  417                     	txa	; signed
  418                     	cla
  419                     	bpl	.x_\@
  420                     	dec	A
  421                     .x_\@:
  422                     .endm
  423                     
  424                     __comw	.macro
  425                     	sax
  426                     	eor	#$FF
  427                     	sax
  428                     	eor	#$FF
  429                     .endm
  430                     
  431                     __negw	.macro
  432                     	sax
  433                     	eor	#$FF
  434                     	clc
  435                     	adc	#1
  436                     	sax
  437                     	eor	#$FF
  438                     	adc	#0
  439                     .endm
  440                     
  441                     __boolw	.macro
  442                     	stx	<__temp
  443                     	ora	<__temp
  444                     	clx
  445                     	beq	.x\@
  446                     	inx
  447                     .x\@	cla
  448                     .endm
  449                     
  450                     __notw	.macro
  451                     	stx	<__temp
  452                     	ora	<__temp
  453                     	clx
  454                     	bne	.x\@
  455                     	inx
  456                     .x\@	cla
  457                     .endm
  458                     
  459                     __addw	.macro
  460                     	clc
  461                     	sax
  462                     	adc	\1
  463                     	sax
  464                     	adc	\1+1
  465                     .endm
  466                     
  467                     __addb	.macro
  468                     	clc
  469                     	sax
  470                     	adc	\1
  471                     	sax
  472                     	ldy	\1
  473                     	bpl	.x\@
  474                     	dec a
  475                     .x\@:	adc	#0
  476                     .endm
  477                     
  478                     __addub	.macro
  479                     	clc
  480                     	sax
  481                     	adc	\1
  482                     	sax
  483                     	adc	#0
  484                     .endm
  485                     
  486                     __addwi	.macro
  487                     .if (\1 = 1)
  488                     	cpx	#$ff
  489                     	inx
  490                     	adc	#0
  491                     .else
  492                     .if (\1 = 2)
  493                     	cpx	#$fe
  494                     	inx
  495                     	inx
  496                     	adc	#0
  497                     .else
  498                     	clc
  499                     	sax
  500                     	adc	#low(\1)
  501                     	sax
  502                     	adc	#high(\1)
  503                     .endif
  504                     .endif
  505                     .endm
  506                     
  507                     ; pceas workaround; the regular __addwi doesn't work if the argument is
  508                     ; symbolic because the code size changes as it is resolved.
  509                     __addwi_sym	.macro
  510                     	clc
  511                     	sax
  512                     	adc	#low(\1)
  513                     	sax
  514                     	adc	#high(\1)
  515                     .endm
  516                     
  517                     __mulwi	.macro
  518                     .if (\1 = 2)
  519                     	__aslw
  520                     .else
  521                     .if (\1 = 3)
  522                     	__stw	<__temp
  523                     	__aslw
  524                     	__addw	<__temp
  525                     .else
  526                     .if (\1 = 4)
  527                     	__aslw
  528                     	__aslw
  529                     .else
  530                     .if (\1 = 5)
  531                     	__stw	<__temp
  532                     	__aslw
  533                     	__aslw
  534                     	__addw	<__temp
  535                     .else
  536                     .if (\1 = 6)
  537                     	__aslw
  538                     	__stw	<__temp
  539                     	__aslw
  540                     	__addw	<__temp
  541                     .else
  542                     .if (\1 = 7)
  543                     	__stw	<__temp
  544                     	__aslw
  545                     	__aslw
  546                     	__aslw
  547                     	__subw	<__temp
  548                     .else
  549                     .if (\1 = 8)
  550                     	__aslw
  551                     	__aslw
  552                     	__aslw
  553                     .else
  554                     .if (\1 = 9)
  555                     	__stw	<__temp
  556                     	__aslw
  557                     	__aslw
  558                     	__aslw
  559                     	__addw	<__temp
  560                     .else
  561                     .if (\1 = 10)
  562                     	__aslw
  563                     	__stw	<__temp
  564                     	__aslw
  565                     	__aslw
  566                     	__addw	<__temp
  567                     .else
  568                     	__pushw
  569                     	__ldwi	\1
  570                     	jsr	umul
  571                     .endif
  572                     .endif
  573                     .endif
  574                     .endif
  575                     .endif
  576                     .endif
  577                     .endif
  578                     .endif
  579                     .endif
  580                     .endm
  581                     
  582                     __addbi	.macro
  583                     .if (\1 = 1)
  584                     	inx
  585                     .else
  586                     .if (\1 = 2)
  587                     	inx
  588                     	inx
  589                     .else
  590                     .if (\1 = 3)
  591                     	inx
  592                     	inx
  593                     	inx
  594                     .else
  595                     	clc
  596                     	txa
  597                     	adc	#low(\1)
  598                     	tax
  599                     .endif
  600                     .endif
  601                     .endif
  602                     	cla
  603                     .endm
  604                     
  605           0000      .ifdef SMALL
  642                     .else ; SMALL
  643                     
  644                     __addmi1	.macro		; 10(14)
  645                     	inc	<\1		; 6
  646                     	bne	.x\@		; 4(2)
  647                     	inc	<\1+1		; 0(6)
  648                     .x\@:
  649                     .endm
  650                     
  651                     __submi1	.macro		; 14(18)
  652                     	ldy	<\1		; 4
  653                     	bne	.x\@		; 4(2)
  654                     	dec	<\1+1		; 0(6)
  655                     .x\@:
  656                     	dec	<\1		; 6
  657                     .endm
  658                     
  659                     __addmi	.macro
  660                     .if (\1 = 1)
  661                     	__addmi1	\2
  662                     .else
  663                     .if (\1 = -1)
  664                     	__submi1	\2
  665                     .else
  666                     	tay			; 2
  667                     	clc			; 2
  668                     	lda	<\2		; 4
  669                     	adc	#low(\1)	; 2
  670                     	sta	<\2		; 4
  671                     .if (\1 < 256) & (\1 >= 0)
  672                     	bcc	.x\@		; 4(2)
  673                     	inc	<\2+1		; 0(6)
  674                     .x\@:
  675                     .else
  676                     .if (\1 >= -256) & (\1 < 0)
  677                     	bcs	.y\@		; 4(2)
  678                     	dec	<\2+1		; 0(6)
  679                     .y\@:
  680                     .else
  681                     	lda	<\2+1		; 4
  682                     	adc	#high(\1)	; 2
  683                     	sta	<\2+1		; 4
  684                     .endif
  685                     .endif
  686                     	tya			; 2 => 20(24) / 26
  687                     .endif
  688                     .endif
  689                     .endm
  690                     
  691                     __addmi_sym	.macro
  692                     	tay			; 2
  693                     	clc			; 2
  694                     	lda	<\2		; 4
  695                     	adc	#low(\1)	; 2
  696                     	sta	<\2		; 4
  697                     	lda	<\2+1		; 4
  698                     	adc	#high(\1)	; 2
  699                     	sta	<\2+1		; 4
  700                     	tya			; 2 => 20(24) / 26
  701                     .endm
  702                     
  703                     .endif ; SMALL
  704                     
  705                     __subw	.macro
  706                     	sec
  707                     	sax
  708                     	sbc	\1
  709                     	sax
  710                     	sbc	\1+1
  711                     .endm
  712                     
  713                     __subwi	.macro
  714                     .if (\1 = 1)
  715                     	cpx	#1
  716                     	dex
  717                     	sbc	#0
  718                     .else
  719                     .if (\1 = 2)
  720                     	cpx	#2
  721                     	dex
  722                     	dex
  723                     	sbc	#0
  724                     .else
  725                     	sec
  726                     	sax
  727                     	sbc	#low(\1)
  728                     	sax
  729                     	sbc	#high(\1)
  730                     .endif
  731                     .endif
  732                     .endm
  733                     
  734                     __submi	.macro
  735                     	pha
  736                     	sec
  737                     	lda	<\2
  738                     	sbc	#low(\1)
  739                     	sta	<\2
  740                     	lda	<\2+1
  741                     	sbc	#high(\1)
  742                     	sta	<\2+1
  743                     	pla
  744                     .endm
  745                     
  746                     __addws	.macro
  747                     	sax
  748                     	clc
  749                     	adc	[__stack]
  750                     	sax
  751                     	ldy	#1
  752                     	adc	[__stack],Y
  753                     	__addmi	2, __stack
  754                     .endm
  755                     
  756                     __addbs	.macro
  757                     	txa
  758                     	clc
  759                     	adc	[__stack]
  760                     	tax
  761                     	cla
  762                     	__addmi	2, __stack
  763                     .endm
  764                     
  765                     __subws	.macro
  766                     	stx	<__temp
  767                     	sta	<__temp+1
  768                     	sec
  769                     	lda	[__stack]
  770                     	sbc	<__temp
  771                     	tax
  772                     	ldy	#1
  773                     	lda	[__stack],Y
  774                     	sbc	<__temp+1
  775                     	__addmi	2, __stack
  776                     .endm
  777                     
  778                     __orws	.macro
  779                     	sax
  780                     	ora	[__stack]
  781                     	sax
  782                     	ldy	#1
  783                     	ora	[__stack],Y
  784                     	__addmi	2,__stack
  785                     .endm
  786                     
  787                     __orwi	.macro
  788                     	sax
  789                     	ora	#low(\1)
  790                     	sax
  791                     	ora	#high(\1)
  792                     .endm
  793                     
  794                     __orw	.macro
  795                     	sax
  796                     	ora	\1
  797                     	sax
  798                     	ora	\1+1
  799                     .endm
  800                     
  801                     __andws	.macro
  802                     	sax
  803                     	and	[__stack]
  804                     	sax
  805                     	ldy	#1
  806                     	and	[__stack],Y
  807                     	__addmi	2,__stack
  808                     .endm
  809                     
  810                     __andwi	.macro
  811                     	sax
  812                     	and	#low(\1)
  813                     	sax
  814                     	and	#high(\1)
  815                     .endm
  816                     
  817                     __andw	.macro
  818                     	sax
  819                     	and	\1
  820                     	sax
  821                     	and	\1+1
  822                     .endm
  823                     
  824                     __eorwi	.macro
  825                     	sax
  826                     	eor	#low(\1)
  827                     	sax
  828                     	eor	#high(\1)
  829                     .endm
  830                     
  831                     __eorws	.macro
  832                     	sax
  833                     	eor	[__stack]
  834                     	sax
  835                     	ldy	#1
  836                     	eor	[__stack],Y
  837                     	__addmi	2,__stack
  838                     .endm
  839                     
  840                     __lbra	.macro
  841                     	jmp	\1
  842                     .endm
  843                     
  844                     __lbran	.macro
  845                     	bra	\1
  846                     .endm
  847                     
  848                     __lbeq	.macro
  849                     	cpx	#0
  850                     	bne	.x\@
  851                     	jmp	\1
  852                     .x\@
  853                     .endm
  854                     
  855                     __lbeqn	.macro
  856                     	cpx	#0
  857                     	beq	\1
  858                     .endm
  859                     
  860                     __lbne	.macro
  861                     	cpx	#0
  862                     	beq	.x\@
  863                     	jmp	\1
  864                     .x\@
  865                     .endm
  866                     
  867                     __lbnen	.macro
  868                     	cpx	#0
  869                     	bne	\1
  870                     .endm
  871                     
  872                     __cmpwi_eq	.macro
  873                     	cpx	#low(\1)
  874                     	clx
  875                     	bne	.f\@
  876                     	cmp	#high(\1)
  877                     	bne	.f\@
  878                     	ldx	#1
  879                     .f\@:	cla
  880                     .endm
  881                     
  882                     __cmpwi_ne	.macro
  883                     	cpx	#low(\1)
  884                     	clx
  885                     	bne	.t\@
  886                     	cmp	#high(\1)
  887                     	beq	.f\@
  888                     .t\@:	ldx	#1
  889                     .f\@:	cla
  890                     .endm
  891                     
  892                     __call	.macro
  893                     	call	\1
  894                     .endm
  895                     
  896                     _set_bgpal	.macro
  897                     	set_bgpal	\1,\2,\3
  898                     .endm
  899                     
  900                     _set_sprpal	.macro
  901                     	set_sprpal	\1,\2,\3
  902                     .endm
  903                     
  904                     _load_background	.macro
  905                     	vload		$1000,\1,#$4000
  906                     	vsync
  907                     	set_bgpal	#0, \2,#16
  908                     	batcpy		#$0, \3, \4, \5
  909                     .endm
  910                     
  911                     __map_callbank	.macro
  912                     .if (PAGE(\1) = 5)	; user function
  913                     	tay
  914                     	tma	#4
  915                     	pha
  916                     	lda	#_call_bank
  917                     	tam	#4
  918                     	tya
  919                     .endif
  920                     .endm
  921                     
  922                     __unmap_callbank	.macro
  923                     .if (PAGE(\1) = 5)	; user function
  924                     	tay
  925                     	pla
  926                     	tam	#4
  927                     	tya
  928                     .endif
  929                     .endm
#[2]   startup.asm
#[3]   huc_opt.inc
   21                     .include "huc_opt.inc"
    1                     ;
    2                     ; Hu-C internal include file
    3                     ;
    4                     
    5                     ; optimized macros
    6                     ; ----
    7                     
    8                     ; lea_s
    9                     ;
   10                     .macro __lea_s
   11                     	; (bytes : 10, cycles : 16)
   12                     	lda	<__sp
   13                     	clc
   14                     	adc	#LOW(\1)
   15                     	tax
   16                     .ifndef SMALL
   17                     	lda	<__sp+1
   18                     	adc	#HIGH(\1)
   19                     .else
   20                     	lda	#$3f
   21                     .endif
   22                     .endm
   23                     
   24                     ; pea_s
   25                     ;
   26                     .macro __pea_s
   27                     	; (bytes : 25, cycles : 44)
   28                     .ifndef SMALL
   29                     	lda	<__sp
   30                     	sec
   31                     	sbc	#2
   32                     	bcs	.x_\@
   33                     	dec	<__sp+1
   34                     .x_\@:	 sta	<__sp
   35                     	clc
   36                     	adc	#LOW(\1+2)
   37                     	sta	[__sp]
   38                     	tax
   39                     	lda	<__sp+1
   40                     	adc	#HIGH(\1+2)
   41                     	ldy	#1
   42                     	sta	[__sp],Y
   43                     .else
   44                     	lda	<__sp
   45                     	dec	a
   46                     	dec	a
   47                     	sta	<__sp
   48                     	clc
   49                     	adc	#LOW(\1+2)
   50                     	sta	[__sp]
   51                     	tax
   52                     	lda	#$3f
   53                     	ldy	#1
   54                     	sta	[__sp],Y
   55                     .endif
   56                     .endm
   57                     
   58                     ; ldb_s
   59                     ;
   60                     .macro __ldb_s
   61                     .if (\1 < 256)
   62                     	; short index (bytes :  9, cycles : 13/17)
   63                     	ldy	#\1
   64                     	lda	[__sp],Y
   65                     	tax
   66                     	cla
   67                     	bpl	.x_\@	; signed
   68                     	dec	A
   69                     .x_\@:
   70                     .else
   71                     	; long index  (bytes : 20, cycles : 37/41)
   72                     	addw	#\1,<__sp,<__ptr	; 13,26
   73                     	lda	[__ptr]
   74                     	tax
   75                     	cla
   76                     	bpl	.x_\@	; signed
   77                     	dec	A
   78                     .x_\@:
   79                     .endif
   80                     .endm
   81                     
   82                     ; addb_s
   83                     ;
   84                     .macro __addb_s
   85                     	; short index (bytes :  9, cycles : 13/17)
   86                     	stx	<__temp
   87                     	sta	<__temp+1
   88                     .if (\1 < 256)
   89                     	ldy	#\1
   90                     	lda	[__sp],Y
   91                     .else
   92                     	addw	#\1,<__sp,<__ptr	; 13,26
   93                     	lda	[__ptr]
   94                     .endif
   95                     	tax
   96                     	__extw
   97                     	sax
   98                     	clc
   99                     	adc	<__temp
  100                     	sax
  101                     	adc	<__temp+1
  102                     .endm
  103                     
  104                     ; ldub_s
  105                     ;
  106                     .macro __ldub_s
  107                     .if (\1 < 256)
  108                     	; short index (bytes :  9, cycles : 13/17)
  109                     	ldy	#\1
  110                     	lda	[__sp],Y
  111                     	tax
  112                     	cla
  113                     .else
  114                     	; long index  (bytes : 20, cycles : 37/41)
  115                     	addw	#\1,<__sp,<__ptr	; 13,26
  116                     	lda	[__ptr]
  117                     	tax
  118                     	cla
  119                     .endif
  120                     .endm
  121                     
  122                     ; addub_s
  123                     ;
  124                     .macro __addub_s
  125                     .if (\1 < 256)
  126                     	; short index (bytes :  9, cycles : 13/17)
  127                     	ldy	#\1
  128                     	sax
  129                     	clc
  130                     	adc	[__sp],Y
  131                     	sax
  132                     	adc	#0
  133                     .else
  134                     	; long index  (bytes : 20, cycles : 37/41)
  135                     	sta	<__temp
  136                     	addw	#\1,<__sp,<__ptr	; 13,26
  137                     	txa
  138                     	clc
  139                     	adc	[__ptr]
  140                     	tax
  141                     	lda	<__temp
  142                     	adc	#0
  143                     .endif
  144                     .endm
  145                     
  146                     ; ldb_p
  147                     ;
  148                     .macro __ldb_p
  149                     	; (bytes : 11, cycles : 19/23)
  150                     	stx	<__ptr
  151                     	sta	<__ptr+1
  152                     	lda	[__ptr]
  153                     	tax
  154                     	cla
  155                     	bpl	.x_\@	; signed
  156                     	dec	A
  157                     .x_\@:
  158                     .endm
  159                     
  160                     ; addbi_p
  161                     .macro __addbi_p
  162                     	stx	<__ptr
  163                     	sta	<__ptr+1
  164                     	lda	[__ptr]
  165                     	clc
  166                     	adc	#\1
  167                     	sta	[__ptr]
  168                     	tax
  169                     	cla
  170                     .endm
  171                     
  172                     ; ldub_p
  173                     ;
  174                     .macro __ldub_p
  175                     	; (bytes : 11, cycles : 19/23)
  176                     	stx	<__ptr
  177                     	sta	<__ptr+1
  178                     	lda	[__ptr]
  179                     	tax
  180                     	cla
  181                     .endm
  182                     
  183                     ; ldw_s
  184                     ;
  185                     .macro __ldw_s
  186                     .if (\1 < 255)
  187                     	; short index (bytes :  7/8, cycles : 18/20)
  188                     .if (\1 = 0)
  189                     	lda	[__sp]
  190                     	tax
  191                     	ldy	#1
  192                     	lda	[__sp],Y
  193                     .else
  194                     	ldy	#\1
  195                     	lda	[__sp],Y
  196                     	tax
  197                     	iny
  198                     	lda	[__sp],Y
  199                     .endif
  200                     .else
  201                     	; long index  (bytes : 20, cycles : 44)
  202                     	addw	#\1,<__sp,<__ptr	; 13,26
  203                     	lda	[__ptr]
  204                     	tax
  205                     	ldy	#1
  206                     	lda	[__ptr],Y
  207                     .endif
  208                     .endm
  209                     
  210                     ; stbi_s
  211                     ;
  212                     .macro __stbi_s
  213                     .if (\2 < 256)
  214                     	; short index (bytes :  8/ 9, cycles : 15)
  215                     	lda	#LOW(\1)
  216                     	ldy	#\2
  217                     	sta	[__sp],Y
  218                     	tax
  219                     	cla
  220                     .else
  221                     	; long index  (bytes : 19/20, cycles : 39)
  222                     
  223                     	addw	#\2,<__sp,<__ptr	; 13,26
  224                     	lda	#LOW(\1)
  225                     	sta	[__ptr]
  226                     	tax
  227                     	cla
  228                     .endif
  229                     .endm
  230                     
  231                     ; stwi_s
  232                     ;
  233                     .macro __stwi_s
  234                     .if (\2 < 255)
  235                     	; short index (bytes : 12, cycles : 24)
  236                     	lda	#LOW(\1)
  237                     	ldy	#\2
  238                     	sta	[__sp],Y
  239                     	tax
  240                     	lda	#HIGH(\1)
  241                     	iny
  242                     	sta	[__sp],Y
  243                     .else
  244                     	; long index  (bytes : 24, cycles : 48)
  245                     	addw	#\2,<__sp,<__ptr	; 13,26
  246                     	lda	#LOW(\1)
  247                     	sta	[__ptr]
  248                     	tax
  249                     	lda	#HIGH(\1)
  250                     	ldy	#1
  251                     	sta	[__ptr],Y
  252                     .endif
  253                     .endm
  254                     
  255                     ; stb_s
  256                     ;
  257                     .macro __stb_s
  258                     .if (\1 < 255)
  259                     	; short index (bytes :  6, cycles : 13)
  260                     	sax
  261                     	ldy	#\1
  262                     	sta	[__sp],Y
  263                     	sax
  264                     .else
  265                     	; long index  (bytes : 18, cycles : 42)
  266                     	pha
  267                     	addw	#\1,<__sp,<__ptr	; 13,26
  268                     	txa
  269                     	sta	[__ptr]
  270                     	pla
  271                     .endif
  272                     .endm
  273                     
  274                     ; stw_s
  275                     ;
  276                     .macro __stw_s
  277                     .if (\1 < 255)
  278                     	; short index (bytes :  9, cycles : 22)
  279                     	sax
  280                     	ldy	#\1
  281                     	sta	[__sp],Y
  282                     	sax
  283                     	iny
  284                     	sta	[__sp],Y
  285                     .else
  286                     	; long index  (bytes : 22, cycles : 51)
  287                     	pha
  288                     	addw	#\1,<__sp,<__ptr	; 13,26
  289                     	txa
  290                     	sta	[__ptr]
  291                     	pla
  292                     	ldy	#1
  293                     	sta	[__ptr],Y
  294                     .endif
  295                     .endm
  296                     
  297                     ; addw_s
  298                     ;
  299                     .macro __addw_s
  300                     .if (\1 < 255)
  301                     	; short index (bytes : 10, cycles : 24)
  302                     	ldy	#\1
  303                     	clc
  304                     	sax
  305                     	adc	[__sp],Y
  306                     	sax
  307                     	iny
  308                     	adc	[__sp],Y
  309                     .else
  310                     	; long index  (bytes : 24, cycles : 55)
  311                     	pha				;  1, 3
  312                     	addw	#\1,<__sp,<__ptr	; 13,26
  313                     	pla				;  1, 4
  314                     	clc
  315                     	sax
  316                     	adc	[__ptr]
  317                     	sax
  318                     	ldy	#1
  319                     	adc	[__ptr],Y
  320                     .endif
  321                     .endm
  322                     
  323                     ; XXX: the semantics of this are ridiculous: It assumes the value of
  324                     ; the incremented variable to be in AX, the memory location to
  325                     ; be incremented and the previous value retained in AX, making it
  326                     ; necessary to spill A.
  327                     ; incw_s
  328                     ;
  329                     .macro __incw_s
  330                     	; (bytes : 16, cycles : 24/40)
  331                     	pha
  332                     	ldy	#\1
  333                     	txa
  334                     	inc A
  335                     	sta	[__sp],Y
  336                     	bne	.x_\@
  337                     	iny
  338                     	lda	[__sp],Y
  339                     	inc A
  340                     	sta	[__sp],Y
  341                     .x_\@:
  342                     	pla
  343                     .endm
  344                     
  345                     ; incb_s
  346                     ;
  347                     .macro __incb_s
  348                     	pha
  349                     	ldy	#\1
  350                     	txa
  351                     	inc A
  352                     	sta	[__sp],Y
  353                     	pla
  354                     .endm
  355                     
  356                     ; ldd_i
  357                     ;
  358                     .macro __ldd_i
  359                     	stw	#(\1) & 0xFFFF,<\2
  360                     	stw	#(\1) >> 16,<\3
  361                     	ldx	#low(\2)
  362                     	lda	#high(\2)
  363                     .endm
  364                     
  365                     ; ldd_b
  366                     ;
  367                     .macro __ldd_b
  368                     	lda	 \1
  369                     	sta	<\2
  370                     	stz	<\2+1
  371                     	stwz	<\3
  372                     	ldx	#low(\2)
  373                     	lda	#high(\2)
  374                     .endm
  375                     
  376                     ; ldd_w
  377                     ;
  378                     .macro __ldd_w
  379                     	stw	 \1,<\2
  380                     	stwz	<\3
  381                     	ldx	#low(\2)
  382                     	lda	#high(\2)
  383                     .endm
  384                     
  385                     ; ldd_s_b
  386                     ;
  387                     .macro __ldd_s_b
  388                     	__ldb_s	\1
  389                     	stx	<\2
  390                     	sta	<\2+1
  391                     	stwz	<\3
  392                     	ldx	#low(\2)
  393                     	lda	#high(\2)
  394                     .endm
  395                     
  396                     ; ldd_s_w
  397                     ;
  398                     .macro __ldd_s_w
  399                     	__ldw_s	\1
  400                     	stx	<\2
  401                     	sta	<\2+1
  402                     	stwz	<\3
  403                     	ldx	#low(\2)
  404                     	lda	#high(\2)
  405                     .endm
  406                     
#[2]   startup.asm
   22                     .endif	; HUC
   23                     
#[3]   standard.inc
   24                     .include  "standard.inc" ; HUCARD
    1                     ;
    2                     ; STANDARD.INC  -  MagicKit standard include file
    3                     ;
#[4]   equ.inc
    4                     .include "equ.inc"
    1                     ;
    2                     ; EQU.INC  -  MagicKit Standard Equates
    3                     ;
    4                     
    5                     
    6                     ; --------
    7                     ; This block defines standard system variables
    8                     ; in zero-page.
    9                     ;
   10                     
   11           20F3      vdc_crl	= $20F3	; VDC control register (copy of)
   12           20F4      vdc_crh	= $20F4	;
   13           20F5      irq_m	= $20F5	; interrupt control mask (copy of)
   14           20F6      vdc_sr	= $20F6	; VDC status register (copy of)
   15           20F7      vdc_reg	= $20F7	; VDC register index (copy of)
   16                     
   17                     ; old aliases (for compatibility only, don't use them)
   18           0000      .ifndef HUC
   22                     .endif
   23                     
   24                     
   25                     ; --------
   26                     ; This block defines standard parameter-passing
   27                     ; areas (in zero-page) for subroutines.
   28                     ;
   29                     
   30           20EC      __bp	= $20EC	; base pointer
   31           20EE      __si	= $20EE	; source address
   32           20F0      __di	= $20F0	; destination address
   33           20F8      __ax	= $20F8
   34           20F8      __al	= $20F8
   35           20F9      __ah	= $20F9
   36           20FA      __bx	= $20FA
   37           20FA      __bl	= $20FA
   38           20FB      __bh	= $20FB
   39           20FC      __cx	= $20FC
   40           20FC      __cl	= $20FC
   41           20FD      __ch	= $20FD
   42           20FE      __dx	= $20FE
   43           20FE      __dl	= $20FE
   44           20FF      __dh	= $20FF
   45                     
   46           0001      .ifdef DEPRECATED
   47                     ; aliases for old assembler code
   48           20EC      _bp	= __bp
   49           20EE      _si	= __si
   50           20F0      _di	= __di
   51           20F8      _ax	= __ax
   52           20F8      _al	= __al
   53           20F9      _ah	= __ah
   54           20FA      _bx	= __bx
   55           20FA      _bl	= __bl
   56           20FB      _bh	= __bh
   57           20FC      _cx	= __cx
   58           20FC      _cl	= __cl
   59           20FD      _ch	= __ch
   60           20FE      _dx	= __dx
   61           20FE      _dl	= __dl
   62           20FF      _dh	= __dh
   63                     .endif
   64                     
   65                     
   66                     ; --------
   67                     ; This block defines names for standard
   68                     ; devices and equipment on the PC-Engine.
   69                     ; (they should be self-explanatory...)
   70                     ;
   71                     
   72                     ; ----
   73                     ; VDC (Video Display Controller)
   74                     
   75           0000      videoport	.equ $0000
   76                     
   77           0000      video_reg	.equ videoport
   78           0000      video_reg_l	.equ video_reg
   79           0001      video_reg_h	.equ video_reg+1
   80                     
   81           0002      video_data	.equ videoport+2
   82           0002      video_data_l	.equ video_data
   83           0003      video_data_h	.equ video_data+1
   84                     
   85                     
   86           0000      .ifdef _SGX
  119                     .endif ; _SGX
  120                     
  121                     
  122           0000      .ifdef _AC
  170                     .endif ; _AC
  171                     
  172                     
  173                     ; ----
  174                     ; VCE (Video Color Encoder)
  175                     
  176           0400      colorport	.equ $0400
  177           0400      color_ctrl	.equ colorport
  178                     
  179           0402      color_reg	.equ colorport+2
  180           0402      color_reg_l	.equ color_reg
  181           0403      color_reg_h	.equ color_reg+1
  182                     
  183           0404      color_data	.equ colorport+4
  184           0404      color_data_l	.equ color_data
  185           0405      color_data_h	.equ color_data+1
  186                     
  187           0001      .ifdef HUC
  188           0402      _color_reg	.equ colorport+2
  189           0404      _color_data	.equ colorport+4
  190                     .endif
  191                     
  192                     
  193                     ; ----
  194                     ; PSG (Programmable Sound Generator)
  195                     
  196           0800      psgport		.equ $0800
  197           0800      psg_ch		.equ psgport
  198           0801      psg_mainvol	.equ psgport+1
  199           0802      psg_freqlo	.equ psgport+2
  200           0803      psg_freqhi	.equ psgport+3
  201           0804      psg_ctrl	.equ psgport+4
  202           0805      psg_pan		.equ psgport+5
  203           0806      psg_wavebuf	.equ psgport+6
  204           0807      psg_noise	.equ psgport+7
  205           0808      psg_lfofreq	.equ psgport+8
  206           0809      psg_lfoctrl	.equ psgport+9
  207                     
  208                     
  209                     ; ----
  210                     ; TIMER
  211                     
  212           0C00      timerport	.equ $0C00
  213           0C00      timer_cnt	.equ timerport
  214           0C01      timer_ctrl	.equ timerport+1
  215                     
  216                     
  217                     ; ----
  218                     ; I/O port
  219                     
  220           1000      joyport		.equ $1000
  221                     
  222                     
  223                     ; ----
  224                     ; IRQ ports
  225                     
  226           1400      irqport		.equ $1400
  227           1402      irq_disable	.equ irqport+2
  228           1403      irq_status	.equ irqport+3
  229                     
  230                     
  231                     ; ----
  232                     ; CDROM/Expansion ports
  233                     
  234           1800      cd_port		.equ $1800
  235                     
  236           1803      bram_lock	.equ cd_port+3	; a read access here will do it
  237           1807      bram_unlock	.equ cd_port+7	; actually, bit #$80 of this byte
  238                     
  239                     
  240                     ; ----
  241                     ; Arcade Card ports
  242                     
  243           1A00      ac_port		.equ $1A00
  244           1A00      ac_data1	.equ ac_port
  245           1A01      ac_data1_alt	.equ ac_port+1
  246           1A02      ac_base1_l	.equ ac_port+2
  247           1A03      ac_base1_m	.equ ac_port+3
  248           1A04      ac_base1_h	.equ ac_port+4
  249           1A05      ac_offset1_l	.equ ac_port+5
  250           1A06      ac_offset1_m	.equ ac_port+6
  251           1A09      ac_cntrol1	.equ ac_port+9
  252           1A0A      ac_addoffset1	.equ ac_port+$0A
  253                     
  254           1AE0      ac_shftreg	.equ $1AE0		; actually, probably rotate register
  255           1AE0      ac_shftreg_0	.equ ac_shftreg
  256           1AE1      ac_shftreg_1	.equ ac_shftreg+1
  257           1AE2      ac_shftreg_2	.equ ac_shftreg+2
  258           1AE3      ac_shftreg_3	.equ ac_shftreg+3
  259           1AE4      ac_shft_bits	.equ ac_shftreg+4	; positive = shift left
  260                     
  261           1AFD      ac_identbase	.equ $1AFD
  262           1AFD      ac_identver_l	.equ ac_identbase
  263           1AFE      ac_identver_h	.equ ac_identbase+1
  264           1AFF      ac_identflag	.equ ac_identbase+2
  265                     
  266           0051      AC_IDENT	.equ $51	; if ac_identflag = AC_IDENT, then AC in use
  267                     
  268                     
  269                     ; --------
  270                     ; This block defines names for macro
  271                     ; argument types (\?x).
  272                     ;
  273                     
  274           0000      ARG_NONE	.equ 0
  275           0001      ARG_REG		.equ 1
  276           0002      ARG_IMMED	.equ 2
  277           0003      ARG_ABS		.equ 3
  278           0003      ARG_ABSOLUTE	.equ 3
  279           0004      ARG_INDIRECT	.equ 4
  280           0005      ARG_STRING	.equ 5
  281           0006      ARG_LABEL	.equ 6
#[3]   standard.inc
#[4]   macro.inc
    5                     .include "macro.inc"
    1                     ;
    2                     ; macro.inc  -  MagicKit standard macro definitions
    3                     ;
    4                     
    5                     map	.macro			; map a memory bank into
    6                     	lda	#bank(\1)	; addressable memory
    7                     	tam	#page(\1)
    8                     .endm
    9                     
   10                     ;
   11                     ; MAPLIBFUNC - Re-map a library function into $A000-space if it's
   12                     ;	       not in library bank #1
   13                     ;
   14                     maplibfunc	.macro
   15                     	tay
   16                     	tma	#page(\1)
   17                     	pha
   18                     	lda	#bank(\1)
   19                     	tam	#page(\1)
   20                     	tya
   21                     	jsr	\1
   22                     	tay
   23                     	pla
   24                     	tam	#page(\1)
   25                     	tya
   26                     .endm
   27                     
   28                     
   29           0000      .ifdef HAVE_LIB3
   47                     .endif ; HAVE_LIB3
   48                     
   49                     ;
   50                     ; STWZ - store a word-sized zero value at stated memory location
   51                     ;
   52                     stwz	.macro
   53                     	stz	LOW_BYTE \1
   54                     	stz	HIGH_BYTE \1
   55                     .endm
   56                     
   57                     ;
   58                     ; STW - store a word-sized value at stated memory location
   59                     ;
   60                     stw	.macro
   61                     	lda	LOW_BYTE \1
   62                     	sta	LOW_BYTE \2
   63                     	lda	HIGH_BYTE \1
   64                     	sta	HIGH_BYTE \2
   65                     .endm
   66                     
   67                     stb	.macro
   68                     	lda	\1
   69                     	sta	\2
   70                     .endm
   71                     
   72                     ;
   73                     ; ADDW - add word-sized value to value at stated memory location,
   74                     ;	 storing result back into stated memory location (or into
   75                     ;	 another destination memory location - third arg)
   76                     ;
   77                     addw	.macro
   78                     .if	(\# = 3)
   79                     	; 3-arg mode
   80                     	;
   81                     	clc
   82                     	lda	LOW_BYTE \2
   83                     	adc	LOW_BYTE \1
   84                     	sta	LOW_BYTE \3
   85                     	lda	HIGH_BYTE \2
   86                     	adc	HIGH_BYTE \1
   87                     	sta	HIGH_BYTE \3
   88                     .else
   89                     	; 2-arg mode
   90                     	;
   91                     	clc
   92                     	lda	LOW_BYTE \2
   93                     	adc	LOW_BYTE \1
   94                     	sta	LOW_BYTE \2
   95                     	lda	HIGH_BYTE \2
   96                     	adc	HIGH_BYTE \1
   97                     	sta	HIGH_BYTE \2
   98                     .endif
   99                     .endm
  100                     
  101                     ;
  102                     ; ADCW - add word-sized value plus carry to value at stated memory location,
  103                     ;	 storing result back into stated memory location
  104                     ;
  105                     adcw	.macro
  106                     	lda	LOW_BYTE \2
  107                     	adc	LOW_BYTE \1
  108                     	sta	LOW_BYTE \2
  109                     	lda	HIGH_BYTE \2
  110                     	adc	HIGH_BYTE \1
  111                     	sta	HIGH_BYTE \2
  112                     .endm
  113                     
  114                     ;
  115                     ; SUBW - substract word-sized value from value at stated memory location,
  116                     ;	 storing result back into stated memory location
  117                     ;
  118                     subw	.macro
  119                     	sec
  120                     	lda	LOW_BYTE \2
  121                     	sbc	LOW_BYTE \1
  122                     	sta	LOW_BYTE \2
  123                     	lda	HIGH_BYTE \2
  124                     	sbc	HIGH_BYTE \1
  125                     	sta	HIGH_BYTE \2
  126                     .endm
  127                     
  128                     ;
  129                     ; SBCW - substract word-sized value plus carry from value at stated memory
  130                     ;	 location, storing result back into stated memory location
  131                     ;
  132                     sbcw	.macro
  133                     	lda	LOW_BYTE \2
  134                     	sbc	LOW_BYTE \1
  135                     	sta	LOW_BYTE \2
  136                     	lda	HIGH_BYTE \2
  137                     	sbc	HIGH_BYTE \1
  138                     	sta	HIGH_BYTE \2
  139                     .endm
  140                     
  141                     cmpw	.macro
  142                     	lda	HIGH_BYTE \2
  143                     	cmp	HIGH_BYTE \1
  144                     	bne	.x_\@
  145                     	lda	LOW_BYTE \2
  146                     	cmp	LOW_BYTE \1
  147                     .x_\@:
  148                     .endm
  149                     
  150                     tstw	.macro			; test if the word-sized 
  151                     	lda	\1		; value at stated memory
  152                     	ora	\1+1		; location is zero
  153                     .endm
  154                     
  155                     incw	.macro			; increment a word-sized
  156                     	inc	\1		; value at stated memory
  157                     	bne	.x_\@		; location
  158                     	inc	\1+1
  159                     .x_\@:
  160                     .endm
  161                     
  162                     decw	.macro			; decrement a word-sized
  163                     	sec			; value at stated memory
  164                     	lda	\1		; location
  165                     	sbc	#1
  166                     	sta	\1
  167                     	lda	\1+1
  168                     	sbc	#0
  169                     	sta	\1+1
  170                     .endm
  171                     
  172                     rolw	.macro			; rotate word-sized value
  173                     	rol	\1		; (at stated memory location)
  174                     	rol	\1+1
  175                     .endm
  176                     
  177                     aslw	.macro			; arithmetic shift-left
  178                     	asl	\1		; word-sized value (at stated
  179                     	rol	\1+1		; memory location)
  180                     .endm
  181                     
  182                     lsrw	.macro			; logical shift-right word-sized
  183                     	lsr	\1+1		; value (at stated memory
  184                     	ror	\1		; location)
  185                     .endm
  186                     
  187                     rorw	.macro			; rotate right word-sized value
  188                     	ror	\1+1		; (at stated memory location)
  189                     	ror	\1
  190                     .endm
  191                     
  192                     negw	.macro			; negate word-sized value
  193                     	cla			; (at stated memory location)
  194                     	sub	\1		; 2's complement
  195                     	sta	\1
  196                     	cla
  197                     	sbc	\1+1
  198                     	sta	\1+1
  199                     .endm
  200                     
  201                     neg	.macro			; negate byte-sized value
  202                     	eor	#$FF		; in register A
  203                     	inc	A		; 2's complement
  204                     .endm
  205                     
  206                     add	.macro			; add byte-sized value to
  207                     .if (\# = 2)			; register A (handle carry
  208                     	lda	\2		; flag)
  209                     	clc
  210                     	adc	\1
  211                     	sta	\2
  212                     .else
  213                     	clc
  214                     	adc	\1
  215                     .endif
  216                     .endm
  217                     
  218                     sub	.macro			; subtract byte-sized value
  219                     .if (\# = 2)			; from register A (handle
  220                     	lda	\2		; carry flag)
  221                     	sec
  222                     	sbc	\1
  223                     	sta	\2
  224                     .else
  225                     	sec
  226                     	sbc	\1
  227                     .endif
  228                     .endm
  229                     
  230                     blo	.macro			; branch if 'lower'
  231                     	bcc	\1
  232                     .endm
  233                     
  234                     bhs	.macro			; branch if 'higher or same'
  235                     	bcs	\1
  236                     .endm
  237                     
  238                     bhi	.macro			; branch if 'higher'
  239                     	beq	.x_\@
  240                     	bcs	\1
  241                     .x_\@:
  242                     .endm
  243                     
  244                     ;-------------------------------
  245                     
  246                     ;
  247                     ; Long branch macros
  248                     ;
  249                     
  250                     lbne	.macro
  251                     	beq	.x_\@
  252                     	jmp	\1
  253                     .x_\@
  254                     .endm
  255                     
  256                     lbeq	.macro
  257                     	bne	.x_\@
  258                     	jmp	\1
  259                     .x_\@
  260                     .endm
  261                     
  262                     lbpl	.macro
  263                     	bmi	.x_\@
  264                     	jmp	\1
  265                     .x_\@
  266                     .endm
  267                     
  268                     lbmi	.macro
  269                     	bpl	.x_\@
  270                     	jmp	\1
  271                     .x_\@
  272                     .endm
  273                     
  274                     lbcc	.macro
  275                     	bcs	.x_\@
  276                     	jmp	\1
  277                     .x_\@
  278                     .endm
  279                     
  280                     lbcs	.macro
  281                     	bcc	.x_\@
  282                     	jmp	\1
  283                     .x_\@
  284                     .endm
  285                     
  286                     lblo	.macro
  287                     	bcs	.x_\@
  288                     	jmp	\1
  289                     .x_\@
  290                     .endm
  291                     
  292                     lbhs	.macro
  293                     	bcc	.x_\@
  294                     	jmp	\1
  295                     .x_\@
  296                     .endm
  297                     
  298                     
  299                     ;-------------------------------
  300                     
  301                     ;
  302                     ; These macros are the same as the macros
  303                     ; without an underscore; the difference
  304                     ; is these macros preserve the state of
  305                     ; the registers they use (at the expense
  306                     ; of speed)
  307                     ;
  308                     
  309                     _stw	.macro
  310                     	pha
  311                     	stw	\1,\2
  312                     	pla
  313                     .endm
  314                     
  315                     _addw	.macro
  316                     	pha
  317                     	addw	\1,\2
  318                     	pla
  319                     .endm
  320                     
  321                     _adcw	.macro
  322                     	pha
  323                     	adcw	\1,\2
  324                     	pla
  325                     .endm
  326                     
  327                     _subw	.macro
  328                     	pha
  329                     	subw	\1,\2
  330                     	pla
  331                     .endm
  332                     
  333                     _sbcw	.macro
  334                     	pha
  335                     	sbcw	\1,\2
  336                     	pla
  337                     .endm
  338                     
  339                     _cmpw	.macro
  340                     	pha
  341                     	cmpw	\1,\2
  342                     	pla
  343                     .endm
  344                     
  345                     _tstw	.macro
  346                     	pha
  347                     	tstw	\1
  348                     	pla
  349                     .endm
  350                     
  351                     _incw	.macro
  352                     	incw	\1
  353                     .endm
  354                     
  355                     _decw	.macro
  356                     	pha
  357                     	decw	\1
  358                     	pla
  359                     .endm
#[3]   standard.inc
#[4]   func.inc
    6                     .include "func.inc"
    1                     ;
    2                     ; FUNC.INC  -  MagicKit Standard Functions
    3                     ;
    4                     ;
    5                     
    6                     ; ----
    7                     ; BATVAL - create a value for the BAT map
    8                     ;
    9                     ; parameters:
   10                     ; \1 = palette (0-15)
   11                     ; \2 = VRAM address of tile
   12                     BATVAL	.func	(\1<<12)|(\2>>4)
   13                     
   14                     ; ----
   15                     ; CHAR - create a BAT value for a character defined
   16                     ;	 using '.defchar' (uses default palette)
   17                     ;
   18                     ; parameters:
   19                     ; \1 = name of character
   20                     ;
   21                     CHAR	.func	(PAL(\1)<<12|VRAM(\1)>>4)
   22                     
   23                     ; ----
   24                     ; SPR_VRAM - return shifted value of sprite-pattern VRAM address
   25                     ;
   26                     ; parameters:
   27                     ; \1 = VRAM address of sprite
   28                     ;
   29                     SPR_VRAM	.func	(VRAM(\1)>>5)
#[3]   standard.inc
#[4]   library.inc
    7                     .include "library.inc"
    1                     ;
    2                     ; LIBRARY.INC  -  MagicKit include-interface to LIBRARY.ASM
    3                     ;
    4                     
    5                     ;
    6                     ; These MACROs are just simple one-line setups to the
    7                     ; back-end library subroutines.  They simply setup
    8                     ; calling parameters, and call the subroutine
    9                     ;
   10                     
   11                     
   12                     ; set video memory read and write address:
   13                     ;
   14                     ; setvraddr(addr)
   15                     ; ----
   16                     ; addr, new address in VRAM to read at
   17                     ;
   18                     .macro setvraddr
   19                     	stw	#\1,<__di
   20                     	jsr	set_read
   21                     .endm
   22                     
   23                     ; setvwaddr(addr)
   24                     ; ----
   25                     ; addr, new address in VRAM to write at
   26                     ;
   27                     .macro setvwaddr
   28                     	stw	#\1,<__di
   29                     	jsr	set_write
   30                     .endm
   31                     
   32                     ; set_bgpal(index, data [, nb])
   33                     ; ----
   34                     ; index,	sub-palette index (0-15)
   35                     ; data,		color data memory address
   36                     ; nb,		number of sub-palette to load (optional, one by default)
   37                     
   38                     .macro set_bgpal
   39                     	lda	\1
   40                     	sta	<__al
   41                     .if (\?2 = ARG_LABEL)
   42                     	stb	#BANK(\2),<__bl
   43                     .else
   44                     	stb	#$FE,<__bl
   45                     .endif
   46                     	stw	#\2,<__si
   47                     .if \?3
   48                     	lda	\3
   49                     .else
   50                     	lda	#1
   51                     .endif
   52                     	sta	<__cl
   53                     	jsr	load_palette
   54                     .endm
   55                     
   56                     ; set_sprpal(index, data [, nb])
   57                     ; ----
   58                     ; index,	sub-palette index (0-15)
   59                     ; data,		palette data memory address
   60                     ; nb,		number of sub-palette to update (optional, one by default)
   61                     
   62                     .macro set_sprpal
   63                     	lda	\1
   64                     	add	#16
   65                     	sta	<__al
   66                     .if (\?2 = ARG_LABEL)
   67                     	stb	#BANK(\2),<__bl
   68                     .else
   69                     	stb	#$FE,<__bl
   70                     .endif
   71                     	stw	#\2,<__si
   72                     .if \?3
   73                     	lda	\3
   74                     .else
   75                     	lda	#1
   76                     .endif
   77                     	sta	<__cl
   78                     	jsr	load_palette
   79                     .endm
   80                     
   81                     ; setcolor(index, r, g, b)
   82                     ; ----
   83                     ; index, color index
   84                     ; r,	red	(0-7)
   85                     ; g,	green	(0-7)
   86                     ; b,	blue	(0-7)
   87                     
   88                     .macro setcolor
   89                     	stw	\1,color_reg
   90                     	stw	#(((\3) << 6) + ((\2) << 3) + (\4)),color_data
   91                     .endm
   92                     
   93                     ; vload([vram,] data, size)
   94                     ; ----
   95                     ; vram, VRAM base address
   96                     ; data, video data memory address
   97                     ; size, number of words to copy
   98                     
   99                     .macro vload
  100                     .if (\# = 3)
  101                     	stw	#\1,<__di
  102                     .if (\?2 = ARG_LABEL)
  103                     	stb	#BANK(\2),<__bl
  104                     .else
  105                     	stb	#$FE,<__bl
  106                     .endif
  107                     	stw	#\2,<__si
  108                     	stw	\3,<__cx
  109                     .else
  110                     	stw	#VRAM(\1),<__di
  111                     	stb	#BANK(\1),<__bl
  112                     	stw	#\1,<__si
  113                     	stw	#\2,<__cx
  114                     .endif
  115                     	jsr	load_vram
  116                     .endm
  117                     
  118                     ; batcpy(vram, bat, w, h)
  119                     ; ----
  120                     ; vram,	VRAM base address
  121                     ; bat,	BAT address in memory
  122                     ; w,	nb of column to copy
  123                     ; h,	nb of row
  124                     
  125                     .macro batcpy
  126                     .if (\# = 5)
  127                     .fail "batcpy syntax has changed, update your code!"
  128                     .endif
  129                     	stw	\1,<__di
  130                     .if (\?2 = ARG_LABEL)
  131                     	stb	#BANK(\2),<__bl
  132                     .else
  133                     	stb	#$FE,<__bl
  134                     .endif
  135                     	stw	#\2,<__si
  136                     	lda	\3
  137                     	sta	<__cl
  138                     	lda	\4
  139                     	sta	<__ch
  140                     	jsr	load_bat
  141                     .endm
  142                     
  143                     ; setmap(map, tile, ctable, w ,h)
  144                     ; ----
  145                     ; map,		map base address
  146                     ; tile,		tile vram address
  147                     ; ctable,	tile palette table address
  148                     ; w,		map width
  149                     ; h,		map height
  150                     
  151                     .macro setmap
  152                     	stw	#BANK(\1),mapbank
  153                     	stw	#\1,mapaddr
  154                     	stw	#(\2)>>4,maptilebase
  155                     	stw	#\3,mapctable
  156                     	stb	#BANK(\3),mapctablebank
  157                     	stw	\4,mapwidth
  158                     	stw	\5,mapheight
  159                     .endm
  160                     
  161                     ; mapcpy(vram, x, y, w, h)
  162                     ; ----
  163                     ; vram, VRAM base address
  164                     ; x,	x start coordinate in the map
  165                     ; y,	y start coordinate
  166                     ; w,	nb of column to copy
  167                     ; h,	nb of row
  168                     
  169                     .macro mapcpy
  170                     	stw	#\1,<__di
  171                     	lda	\2
  172                     	sta	<__cl
  173                     	lda	\3
  174                     	sta	<__ch
  175                     	lda	\4
  176                     	sta	<__dl
  177                     	lda	\5
  178                     	sta	<__dh
  179                     	jsr	load_map
  180                     .endm
  181                     
  182                     ; fntcpy(vram, font, color, bg, nb)
  183                     ; ----
  184                     ; vram,		VRAM base address
  185                     ; font,		font address in memory
  186                     ; color, 	character color
  187                     ; bg,		bg color
  188                     ; nb,		nb of char. to copy
  189                     
  190                     .macro fntcpy
  191                     	stw	#\1,<__di
  192                     	stb	#BANK(\2),<__bl
  193                     	stw	#\2,<__si
  194                     	lda	\3
  195                     	sta	<__al
  196                     	lda	\4
  197                     	sta	<__ah
  198                     	lda	\4
  199                     	sta	<__cl
  200                     	jsr	load_font
  201                     .endm
  202                     
  203                     ; scroll(num, x, y, top, bottom, cr)
  204                     ; ----
  205                     ; num,		scroll number (0-3)
  206                     ; x,		BAT x position
  207                     ; y,		BAT y position
  208                     ; top,		screen window top
  209                     ; bottom,	screen window bottom
  210                     ; cr,		screen window display control (bg/sp)
  211                     
  212                     .macro scroll
  213                     	lda	\1
  214                     	tax
  215                     	lda	LOW_BYTE  \2
  216                     	sta	scroll_xl,X
  217                     	lda	HIGH_BYTE \2
  218                     	sta	scroll_xh,X
  219                     	lda	LOW_BYTE  \3
  220                     	sta	scroll_yl,X
  221                     	lda	HIGH_BYTE \3
  222                     	sta	scroll_yh,X
  223                     	lda	\4
  224                     	sta	scroll_top,X
  225                     	lda	\5
  226                     	sta	scroll_bottom,X
  227                     	lda	\6
  228                     	ora	#$01
  229                     	sta	scroll_cr,X
  230                     .endm
  231                     
  232                     ; scroll_disable(num)
  233                     ; ----
  234                     ; num,	scroll number (0-3)
  235                     
  236                     .macro scroll_disable
  237                     	lda	\1
  238                     	tax
  239                     	lda	scroll_cr,X
  240                     	and	#$fe
  241                     	sta	scroll_cr,X
  242                     .endm
  243                     
  244                     ; setxres (xres)
  245                     ; ----
  246                     ; xres,	horizontal display resolution
  247                     
  248                     .macro setxres
  249                     	stw	#\1,<__ax
  250                     	jsr	set_xres
  251                     .endm
  252                     
#[3]   standard.inc
#[4]   sprites.inc
    8                     .include "sprites.inc"
    1                     ;
    2                     ; SPRITES.INC  -  MagicKit sprite MACRO definitions
    3                     ;
    4                     
    5                     
    6                     ; load_sprites(vram_addr, spr_bank, #nb_group)
    7                     ; ----
    8                     ; vram_addr,	destination address in VRAM
    9                     ; spr_bank,	sprite bank address
   10                     ; nb_group,	number of 32x64 patterns to copy
   11                     
   12                     .macro load_sprites
   13                     	; put the VRAM address in di
   14                     	stw	#\1,<__di
   15                     
   16                     	; put the sprite bank address in si/bl
   17                     	stw	#\2,<__si
   18                     	stb	#BANK(\2),<__bl
   19                     
   20                     	; get the number of patterns to copy, multiply it by $200 -
   21                     	; the size in words of a 32x64 pattern (remember that
   22                     	; 'load_vram' need a size in words), and put it in cx
   23                     	lda	\3
   24                     	asl a
   25                     	stz	<__cx
   26                     	sta	<__cx+1
   27                     
   28                     	; call the 'load_vram' function
   29                     	jsr load_vram
   30                     .endm
   31                     
   32                     
   33                     ; spr_set(#sprite, satb)
   34                     ; ----
   35                     ; sprite,	the sprite number (0-63)
   36                     ; satb,		the address of the SATB in RAM
   37                     
   38                     .macro spr_set
   39                     	; multiply the sprite number by 8 (the size of a SATB entry)
   40                     	; and put the result in si
   41                     	stz	<__si+1
   42                     	lda	\1
   43                     	asl a
   44                     	asl a
   45                     	asl a
   46                     	rol	<__si+1
   47                     	sta	<__si
   48                     
   49                     	; add the satb address to si
   50                     	addw	#\2,<__si
   51                     .endm
   52                     
   53                     
   54                     ; spr_x(#x [,offset])
   55                     ; ----
   56                     ; x, the new x coordinate
   57                     
   58                     .macro spr_x
   59                     	ldy	#2
   60                     .if (\# = 2)
   61                     	lda	LOW_BYTE \1
   62                     	clc
   63                     	adc	LOW_BYTE \2
   64                     	sta	[__si],Y
   65                     	lda	HIGH_BYTE \1
   66                     	adc	HIGH_BYTE \2
   67                     .else
   68                     	lda	LOW_BYTE \1
   69                     	sta	[__si],Y
   70                     	lda	HIGH_BYTE \1
   71                     .endif
   72                     	iny
   73                     	sta	[__si],Y
   74                     .endm
   75                     
   76                     
   77                     ; spr_y(#y [,offset])
   78                     ; ----
   79                     ; y, the new y coordinate
   80                     
   81                     .macro spr_y
   82                     .if (\# = 2)
   83                     	lda	LOW_BYTE \1
   84                     	clc
   85                     	adc	LOW_BYTE \2
   86                     	sta	[__si]
   87                     	lda	HIGH_BYTE \1
   88                     	adc	HIGH_BYTE \2
   89                     .else
   90                     	lda	LOW_BYTE \1
   91                     	sta	[__si]
   92                     	lda	HIGH_BYTE \1
   93                     .endif
   94                     	ldy	#1
   95                     	sta	[__si],Y
   96                     .endm
   97                     
   98                     
   99                     ; spr_pattern(#addr)
  100                     ; ----
  101                     ; addr, address of the sprite pattern in VRAM
  102                     
  103                     .macro spr_pattern
  104                     	ldy	#4
  105                     .if (\?1 = ARG_IMMED)
  106                     	lda	#LOW((\1) >> 5)
  107                     	sta	[__si],Y
  108                     	lda	#HIGH((\1) >> 5)
  109                     .else
  110                     	lda	\1
  111                     	sta	[__si],Y
  112                     	lda	\1+1
  113                     .endif
  114                     	iny
  115                     	sta	[__si],Y
  116                     .endm
  117                     
  118                     
  119                     ; spr_ctrl(#mask, #flag)
  120                     ; ----
  121                     ; mask, mask of the bits to change
  122                     ; flag, new bit value
  123                     
  124                     .macro spr_ctrl
  125                     	ldy	#7
  126                     	lda	\1
  127                     	eor	#$FF
  128                     	and	[__si],Y
  129                     	ora	\2
  130                     	sta	[__si],Y
  131                     .endm
  132                     
  133                     
  134                     ; spr_pri(#flag)
  135                     ; ----
  136                     ; flag, new priority (1 = in foreground, 0 = in background)
  137                     
  138                     .macro spr_pri
  139                     	ldy	#6
  140                     	lda	[__si],Y
  141                     	and	#$7F
  142                     	ldx	\1
  143                     	beq	.x\@
  144                     	ora	#$80
  145                     .x\@:
  146                     	sta [__si],Y
  147                     .endm
  148                     
  149                     
  150                     ; spr_pal(#index)
  151                     ; ----
  152                     ; index, palette index (0-15)
  153                     
  154                     .macro spr_pal
  155                     	ldy	#6
  156                     	lda	[__si],Y
  157                     	and	#$F0
  158                     	ora	\1
  159                     	sta	[__si],Y
  160                     .endm
  161                     
  162                     
  163                     ; init_satb(addr)
  164                     ; ----
  165                     ; addr, the address of the local RAM SATB
  166                     
  167                     .macro init_satb
  168                     	stz	\1
  169                     	tii	\1,\1+1,511
  170                     .endm
  171                     
  172                     
  173                     ; update_satb(satb[, addr] [,nb_sprite])
  174                     ; ----
  175                     ; satb,		the address of the local RAM SATB
  176                     ; addr,		the address where to copy the SATB in VRAM ($7F00 by default)
  177                     ; nb_sprite,	number of sprite entry to copy (64 by default)
  178                     
  179                     .macro update_satb
  180                     	stw	#\1,<__si
  181                     	stb	#BANK(\1),<__bl
  182                     
  183                     .if (\?2)
  184                     	stw	#\2,<__di
  185                     .else
  186                     	stw	#$7F00,<__di
  187                     .endif
  188                     
  189                     .if (\?3)
  190                     	stw	#(\3)*4,<__cx
  191                     .else
  192                     	stw	#$100,<__cx
  193                     .endif
  194                     
  195                     	jsr	load_vram
  196                     .endm
  197                     
  198                     
  199                     ; ----
  200           0008      FLIP_X_MASK	.equ $08
  201           0080      FLIP_Y_MASK	.equ $80
  202           0088      FLIP_MASK	.equ $88
  203           0031      SIZE_MASK	.equ $31
  204                     
  205           0000      NO_FLIP		.equ 0
  206           0000      NO_FLIP_X	.equ 0
  207           0000      NO_FLIP_Y	.equ 0
  208           0008      FLIP_X		.equ $08
  209           0080      FLIP_Y		.equ $80
  210           0000      SIZE_16x16	.equ 0
  211           0010      SIZE_16x32	.equ $10
  212           0030      SIZE_16x64	.equ $30
  213           0001      SIZE_32x16	.equ $01
  214           0011      SIZE_32x32	.equ $11
  215           0031      SIZE_32x64	.equ $31
  216                     
#[3]   standard.inc
#[4]   vdc.inc
    9                     .include "vdc.inc"
    1                     ;
    2                     ; VDC.INC  -  MagicKit PC-Engine video MACRO definitions
    3                     ;
    4                     
    5                     
    6                     ;
    7                     ; VREG - set up video register to be read/written
    8                     ;
    9                     
   10                     .macro vreg
   11                     	lda	\1
   12                     	sta	<vdc_reg
   13                     .if (\?1 = ARG_IMMED)
   14                     	st0	\1
   15                     .else
   16                     	sta	video_reg
   17                     .endif
   18                     .endm
   19                     
   20                     ;
   21                     ; SETVINC - set VRAM auto-increment step
   22                     ;
   23                     
   24                     .macro setvinc
   25                     	vreg	#5
   26                     .if (\?1 = ARG_IMMED)
   27                     	st2	\1
   28                     .else
   29                     	lda	\1
   30                     	sta	video_data_h
   31                     .endif
   32                     .endm
   33                     
   34                     ; standard increment step
   35                     
   36           0000      VADDR_INC_1	= %00_000
   37           0008      VADDR_INC_32	= %01_000
   38           0010      VADDR_INC_64	= %10_000
   39           0018      VADDR_INC_128	= %11_000
   40                     
   41                     ;
   42                     ; SETBGMAP - set the bgmap virtual size
   43                     ;
   44                     
   45                     .macro setbgmap
   46                     	lda	\1
   47                     	jsr	set_bat_size
   48                     .endm
   49                     
   50                     ; standard bgmap size
   51                     
   52           0000      BGMAP_SIZE_32x32	= %000
   53           0001      BGMAP_SIZE_64x32	= %001
   54           0003      BGMAP_SIZE_128x32	= %011
   55           0004      BGMAP_SIZE_32x64	= %100
   56           0005      BGMAP_SIZE_64x64	= %101
   57           0007      BGMAP_SIZE_128x64	= %111
   58                     
   59                     ;
   60                     ; These values represent a bit in the VCE which
   61                     ; does color-correction to fix leading/trailing
   62                     ; edges of images
   63                     ;
   64                     ; Default to XRES_SOFT
   65                     ;
   66           0004      XRES_SOFT	= 4
   67           0000      XRES_SHARP	= 0
#[3]   standard.inc
#[4]   startup.inc
   10                     .include "startup.inc"
    1                     ;
    2                     ; STARTUP.INC  -  MagicKit startup code equates and macros
    3                     ;
    4                     
    5                     ; ----
    6                     ; this block defines names for joypad
    7                     ; direction and button bits
    8                     
    9           0001      JOY_I		= $01
   10           0002      JOY_II		= $02
   11           0004      JOY_SEL		= $04
   12           0008      JOY_RUN		= $08
   13           0010      JOY_UP		= $10
   14           0020      JOY_RIGHT	= $20
   15           0040      JOY_DOWN	= $40
   16           0080      JOY_LEFT	= $80
   17                     
   18           0050      JOY_TYPE6	= $50
   19           0001      JOY_III		= $01
   20           0002      JOY_IV		= $02
   21           0004      JOY_V		= $04
   22           0008      JOY_VI		= $08
   23                     
   24           0000      JOY_BITI	= $0
   25           0001      JOY_BITII	= $1
   26           0002      JOY_BITSEL	= $2
   27           0003      JOY_BITRUN	= $3
   28           0004      JOY_BITUP	= $4
   29           0005      JOY_BITRT	= $5
   30           0006      JOY_BITDN	= $6
   31           0007      JOY_BITLT	= $7
   32                     
   33           0000      JOY_BITIII	= $0
   34           0001      JOY_BITIV	= $1
   35           0002      JOY_BITV	= $2
   36           0003      JOY_BITVI	= $3
   37                     
   38                     ; ----
   39                     ; this block defines names for interrupt
   40                     ; vectors
   41                     ;
   42           0000      IRQ2		= 0
   43           0001      IRQ1		= 1
   44           0002      TIMER		= 2
   45           0003      NMI		= 3
   46           0004      VSYNC		= 4
   47           0005      HSYNC		= 5
   48           0006      SOFT_RESET	= 6
   49                     
   50                     
   51                     ; ----
   52                     ; setvec(num, addr)
   53                     ; ----
   54                     ; num,	vector number (see defines above)
   55                     ; addr,	address of the new routine
   56                     ; ----
   57                     
   58                     setvec	.macro
   59                     	 lda	\1
   60                     	 ldx	#LOW(\2)
   61                     	 ldy	#HIGH(\2)
   62                     	 jsr	set_intvec
   63                     .endm
   64                     
   65                     ; ----
   66                     ; vec_on(num)
   67                     ; ----
   68                     ; num, vector to enable
   69                     ; ----
   70                     
   71                     vec_on	.macro
   72                     .if (\1 = 5)
   73                     	 smb	#6,<irq_m
   74                     .else
   75                     	 smb	\1,<irq_m
   76                     .endif
   77                     .endm
   78                     
   79                     ; ----
   80                     ; vec_off(num)
   81                     ; ----
   82                     ; num, vector to disable
   83                     ; ----
   84                     
   85                     vec_off	.macro
   86                     .if (\1 = 5)
   87                     	 rmb	#6,<irq_m
   88                     .else
   89                     	 rmb	\1,<irq_m
   90                     .endif
   91                     .endm
   92                     
   93                     ; ----
   94                     ; vsync([nb])
   95                     ; ----
   96                     ; nb, number of frames to be sync'ed on
   97                     ; ----
   98                     
   99                     vsync	.macro
  100                     .if (\# = 0)
  101                     	 lda #1
  102                     .else
  103                     	 lda \1
  104                     .endif
  105                     	 jsr	wait_vsync
  106                     .endm
#[3]   standard.inc
#[2]   startup.asm
   25                     
   26                     ; ----
   27                     ; if FONT_VADDR is not specified, then specify it
   28                     ; (VRAM address to load font into)
   29                     ;
   30           0000      .ifndef	FONT_VADDR
   32                     .endif
   33                     
   34                     ; ----
   35                     ; system variables
   36                     ;
   37           200B      		.zp
   38  --:200B            zp_ptr1:	.ds 2
   39                     
   40                     
   41           2200      		.bss
   42                     
   43           0000      .if  (CDROM)	; CDROM def's in system.inc
   47                     .else  		; ie HuCard
   48                     
   49           2200      		.org	$2200
   50  --:2200            user_jmptbl:		; user interrupt vectors
   51  --:2200            irq2_jmp:	.ds 2	; IRQ2 (BRK instruction and external IRQ)
   52  --:2202            irq1_jmp:	.ds 2	; IRQ1 (VDC interrupt)
   53  --:2204            timer_jmp:	.ds 2	; TIMER
   54  --:2206            nmi_jmp:	.ds 2	; NMI (unused)
   55  --:2208            vsync_hook:	.ds 2	; VDC vertical sync routine
   56  --:220A            hsync_hook:	.ds 2	; VDC horizontal sync rountine
   57                     
   58  --:220C            bg_x1:		.ds 2
   59  --:220E            bg_x2:		.ds 2
   60  --:2210            bg_y1:		.ds 2
   61  --:2212            bg_y2:		.ds 2
   62                     
   63           2227      		.org	$2227
   64  --:2227            joyena:		.ds 1	; soft reset enable (bit 0/pad 1, bit 1/pad2, etc.)
   65  --:2228            joy:		.ds 5	; 'current' pad values (pad #1-5)
   66  --:222D            joytrg:		.ds 5	; 'delta' pad values (new keys hit)
   67  --:2232            joyold:		.ds 5	; 'previous' pad values
   68                     
   69           2241      		.org	$2241
   70  --:2241            irq_cnt:	.ds 1	; VDC interrupt counter; increased 60 times per second
   71                     			; reset to zero when vsync() function called
   72  --:2242            vdc_mwr:	.ds 1
   73  --:2243            vdc_dcr:	.ds 1
   74                     
   75                     .endif	; CDROM
   76                     
   77           2244      		.org	$2244
   78  --:2244            scr_mode:	.ds 1	; screen mode and dimensions - set by <ex_scrmod>
   79  --:2245            scr_w:		.ds 1
   80  --:2246            scr_h:		.ds 1
   81                     
   82           2284      		.org	$2284
   83  --:2284            soft_reset:	.ds 2	; soft reset jump loc (run+select)
   84                     
   85                     		; include sound driver variables
   86                     
#[3]   sound.inc
   87                     		.include  "sound.inc"
    1                     ;
    2                     ; SOUND.INC - Included by STARTUP.ASM to customize the sound driver.
    3                     ;
    4                     ; A customized sound driver for HuCard or CDROM usage can create a
    5                     ; version of this file, and then have startup.asm use the new
    6                     ; definitions just by including the new sound driver's path
    7                     ; in the PCE_INCLUDE environment variable BEFORE the standard
    8                     ; "huc/include/pce" path.
    9                     ;
   10                     ; This default version is comptabile with the CDROM System Card usage.
   11                     ;
   12                     
   13                     ;---------------------------------------------------------------------------
   14                     ; tell startup.asm that we need the SOUND_BANK and to include sound.asm
   15                     
   16           0000      NEED_SOUND_BANK	= 0
   17           0000      NEED_SOUND_CODE	= 0
   18                     
   19                     ;---------------------------------------------------------------------------------------
   20                     ; This macro is invoked in HuC startup.asm after the RAM is cleared, and just before
   21                     ; interrupts are enabled.
   22                     
   23                     __sound_init	.macro
   24                     		.endm
   25                     
   26                     ;---------------------------------------------------------------------------------------
   27                     ; This macro is invoked in HuC startup.asm inside the vsync handler code.
   28                     
   29                     __sound_vsync	.macro
   30                     		.endm
   31                     
   32                     ;---------------------------------------------------------------------------------------
   33                     ; This macro is invoked in HuC startup.asm inside the timer handler code.
   34                     ;
   35                     ; N.B. HuC startup.asm only invokes this if NOT building for CDROM!!!
   36                     ;
   37                     
   38                     __sound_timer	.macro
   39                     		.endm
   40                     
   41                     ;---------------------------------------------------------------------------------------
   42                     ; this is the location to start allocating HuC's internal variables.
   43                     
   44           2680      		.org			$2680
#[2]   startup.asm
   88                     
   89                     		; sound.inc sets the starting location for these HuC variables
   90                     		;
   91                     		; this is normally $2680, but can be lower if a custom
   92                     		; sound driver is used that doesn't need all of the
   93                     		; standard System Card allocation of sound RAM.
   94                     
   95  --:2680            vsync_cnt:	.ds 1	; counter for 'wait_vsync' routine
   96                     
   97  --:2681            joybuf:		.ds 5	; 'delta' pad values collector
   98  --:2686            joyhook:	.ds 2	; 'read_joypad' routine hook
   99  --:2688            joycallback:	.ds 6	; joypad enhanced callback support
  100  --:268E            disp_cr:	.ds 1   ; display control
  101                     			; HuCard: 1 = on, 0 = off
  102                     			; CD-ROM: 2 = on, 1 = off, 0 = no change
  103  --:268F            clock_hh	.ds 1	; system clock, hours since startup (0-255)
  104  --:2690            clock_mm	.ds 1	; system clock, minutes since startup (0-59)
  105  --:2691            clock_ss	.ds 1	; system clock, seconds since startup (0-59)
  106  --:2692            clock_tt	.ds 1	; system clock, ticks (1/60th sec) since startup (0-59)
  107                     
  108  --:2693            joy6:		.ds 5	; second byte for 6-button joysticks
  109  --:2698            joytrg6:	.ds 5
  110  --:269D            joyold6:	.ds 5
  111  --:26A2            joybuf6:	.ds 5
  112                     
  113  --:26A7            joytmp:		.ds 5
  114  --:26AC            joytmp6:	.ds 5
  115                     
  116  --:26B1            color_queue_r:	.ds 1	; ring buffer index for read
  117  --:26B2            color_queue_w:	.ds 1	; ring buffer index for write
  118  --:26B3            color_index:	.ds 8	; ring buffer - palette index
  119  --:26BB            color_count:	.ds 8	; ring buffer - palette count
  120  --:26C3            color_bank:	.ds 8	; ring buffer - data bank
  121  --:26CB            color_addr_l:	.ds 8	; ring buffer - data addr lo
  122  --:26D3            color_addr_h:	.ds 8	; ring buffer - data addr hi
  123  --:26DB            color_tia:	.ds 8	; self-modifying RAM tia function
  124                     
  125           0000      .if (CDROM)
  134                     .endif	; (CDROM)
  135                     
  136                     ; ----
  137                     ; setup flexible boundaries for startup code
  138                     ; and user program's "main".
  139                     ;
  140           0000      		.rsset	0
  141           0000      START_BANK	.rs	0
  142           0000      LIB1_BANK	.rs	1
  143           0001      LIB2_BANK	.rs	1
  144           0000      .ifdef HAVE_LIB3
  146                     .endif
  147                     
  148           0000      .if (NEED_SOUND_BANK)
  150                     .endif ; defined in sound.inc if needed
  151                     
  152           0001      .ifdef HUC
  153           0001      FONT_BANK	.equ	LIB2_BANK
  154           0002      CONST_BANK	.rs	1
  155           0003      DATA_BANK	.rs	1
  156                     .else ; HUC
  159                     .endif	; HUC
  160                     
  161                     ; [ STARTUP CODE ]
  162                     
  163                     ; Let's prepare the secondary library banks first, for use later.
  164                     ; The reason, as you will see, is because code for a given function
  165                     ; which sits together in a file, may have things in zero-page,
  166                     ; bss, LIB1_BANK (ie. START_BANK), and LIB2_BANK.
  167                     ;
  168                     ; The assembler must know beforehand what address etc. to use as a basis.
  169                     ;
  170                     
  171           0000      .ifdef _PAD
  175                     .endif
  176                     
  177           E000      	.data
  178           0001      	.bank LIB2_BANK,"Base Library 2/Font"
  179           6000      	.org  $6000
#[3]   font.inc
  180                     	.include "font.inc"
    1                     ; 8x8 monochrome font(s)
    2                     
    3  01:6000            font_1:
    4  01:6000  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;SPACE
       01:6003  00 00 00  
       01:6006  00 00     
    5  01:6008  CC CC CC  	.db $cc,$cc,$cc,$88,$88,$00,$cc,$00	;!
       01:600B  88 88 00  
       01:600E  CC 00     
    6  01:6010  6C 6C D8  	.db $6c,$6c,$d8,$00,$00,$00,$00,$00	;"
       01:6013  00 00 00  
       01:6016  00 00     
    7  01:6018  6C FE 6C  	.db $6c,$fe,$6c,$6c,$6c,$fe,$6c,$00	;#
       01:601B  6C 6C FE  
       01:601E  6C 00     
    8  01:6020  10 38 40  	.db $10,$38,$40,$38,$04,$38,$10,$00	;$
       01:6023  38 04 38  
       01:6026  10 00     
    9  01:6028  42 A4 48  	.db $42,$a4,$48,$10,$24,$4a,$84,$00	;%
       01:602B  10 24 4A  
       01:602E  84 00     
   10  01:6030  20 50 20  	.db $20,$50,$20,$54,$88,$94,$62,$00	;&
       01:6033  54 88 94  
       01:6036  62 00     
   11  01:6038  18 30 60  	.db $18,$30,$60,$00,$00,$00,$00,$00	;'
       01:603B  00 00 00  
       01:603E  00 00     
   12  01:6040  18 30 60  	.db $18,$30,$60,$60,$60,$30,$18,$00	;(
       01:6043  60 60 30  
       01:6046  18 00     
   13  01:6048  30 18 0C  	.db $30,$18,$0c,$0c,$0c,$18,$30,$00	;)
       01:604B  0C 0C 18  
       01:604E  30 00     
   14  01:6050  54 38 7C  	.db $54,$38,$7c,$38,$54,$00,$00,$00	;*
       01:6053  38 54 00  
       01:6056  00 00     
   15  01:6058  00 10 10  	.db $00,$10,$10,$7c,$10,$10,$00,$00	;+
       01:605B  7C 10 10  
       01:605E  00 00     
   16  01:6060  00 00 00  	.db $00,$00,$00,$18,$18,$08,$10,$00	;,
       01:6063  18 18 08  
       01:6066  10 00     
   17  01:6068  00 00 00  	.db $00,$00,$00,$78,$00,$00,$00,$00	;-
       01:606B  78 00 00  
       01:606E  00 00     
   18  01:6070  00 00 00  	.db $00,$00,$00,$00,$60,$60,$00,$00	;.
       01:6073  00 60 60  
       01:6076  00 00     
   19  01:6078  06 0C 18  	.db $06,$0c,$18,$30,$60,$c0,$00,$00	;/
       01:607B  30 60 C0  
       01:607E  00 00     
   20                     
   21  01:6080  38 4C C6  	.db $38,$4c,$c6,$c6,$c6,$64,$38,$00	;0
       01:6083  C6 C6 64  
       01:6086  38 00     
   22  01:6088  18 78 18  	.db $18,$78,$18,$18,$18,$18,$7e,$00	;1
       01:608B  18 18 18  
       01:608E  7E 00     
   23  01:6090  7C C6 0E  	.db $7c,$c6,$0e,$3c,$78,$e0,$fe,$00	;2
       01:6093  3C 78 E0  
       01:6096  FE 00     
   24  01:6098  FE 0C 18  	.db $fe,$0c,$18,$7c,$06,$c6,$7c,$00	;3
       01:609B  7C 06 C6  
       01:609E  7C 00     
   25  01:60A0  3C 6C CC  	.db $3c,$6c,$cc,$cc,$cc,$fe,$0c,$00	;4
       01:60A3  CC CC FE  
       01:60A6  0C 00     
   26  01:60A8  FE C0 FC  	.db $fe,$c0,$fc,$06,$06,$c6,$7c,$00	;5
       01:60AB  06 06 C6  
       01:60AE  7C 00     
   27  01:60B0  3C 60 C0  	.db $3c,$60,$c0,$fc,$c6,$c6,$7c,$00	;6
       01:60B3  FC C6 C6  
       01:60B6  7C 00     
   28  01:60B8  FE C6 0C  	.db $fe,$c6,$0c,$18,$30,$30,$30,$00	;7
       01:60BB  18 30 30  
       01:60BE  30 00     
   29  01:60C0  7C C6 C6  	.db $7c,$c6,$c6,$7c,$c6,$c6,$7c,$00	;8
       01:60C3  7C C6 C6  
       01:60C6  7C 00     
   30  01:60C8  7C C6 C6  	.db $7c,$c6,$c6,$7e,$06,$0c,$78,$00	;9
       01:60CB  7E 06 0C  
       01:60CE  78 00     
   31  01:60D0  00 18 18  	.db $00,$18,$18,$00,$18,$18,$00,$00	;:
       01:60D3  00 18 18  
       01:60D6  00 00     
   32  01:60D8  00 18 18  	.db $00,$18,$18,$00,$18,$18,$30,$00	;;
       01:60DB  00 18 18  
       01:60DE  30 00     
   33  01:60E0  0C 18 30  	.db $0c,$18,$30,$60,$30,$18,$0c,$00	;<
       01:60E3  60 30 18  
       01:60E6  0C 00     
   34  01:60E8  00 00 7C  	.db $00,$00,$7c,$00,$7c,$00,$00,$00	;=
       01:60EB  00 7C 00  
       01:60EE  00 00     
   35  01:60F0  60 30 18  	.db $60,$30,$18,$0c,$18,$30,$60,$00	;>
       01:60F3  0C 18 30  
       01:60F6  60 00     
   36  01:60F8  7C C6 9E  	.db $7c,$c6,$9e,$38,$20,$00,$30,$00	;?
       01:60FB  38 20 00  
       01:60FE  30 00     
   37                     
   38  01:6100  3C 42 9A  	.db $3c,$42,$9a,$aa,$aa,$5c,$00,$00	;@
       01:6103  AA AA 5C  
       01:6106  00 00     
   39  01:6108  38 6C C6  	.db $38,$6c,$c6,$c6,$fe,$c6,$c6,$00	;A
       01:610B  C6 FE C6  
       01:610E  C6 00     
   40  01:6110  FC C6 C6  	.db $fc,$c6,$c6,$fc,$c6,$c6,$fc,$00	;B
       01:6113  FC C6 C6  
       01:6116  FC 00     
   41  01:6118  3C 66 C0  	.db $3c,$66,$c0,$c0,$c0,$66,$3c,$00	;C
       01:611B  C0 C0 66  
       01:611E  3C 00     
   42  01:6120  F8 CC C6  	.db $f8,$cc,$c6,$c6,$c6,$cc,$f8,$00	;D
       01:6123  C6 C6 CC  
       01:6126  F8 00     
   43  01:6128  FE C0 C0  	.db $fe,$c0,$c0,$fc,$c0,$c0,$fe,$00	;E
       01:612B  FC C0 C0  
       01:612E  FE 00     
   44  01:6130  FE C0 C0  	.db $fe,$c0,$c0,$fc,$c0,$c0,$c0,$00	;F
       01:6133  FC C0 C0  
       01:6136  C0 00     
   45  01:6138  3C 66 C0  	.db $3c,$66,$c0,$ce,$c6,$66,$3e,$00	;G
       01:613B  CE C6 66  
       01:613E  3E 00     
   46  01:6140  C6 C6 C6  	.db $c6,$c6,$c6,$fe,$c6,$c6,$c6,$00	;H
       01:6143  FE C6 C6  
       01:6146  C6 00     
   47  01:6148  7E 18 18  	.db $7e,$18,$18,$18,$18,$18,$7e,$00	;I
       01:614B  18 18 18  
       01:614E  7E 00     
   48  01:6150  06 06 06  	.db $06,$06,$06,$06,$06,$c6,$7c,$00	;J
       01:6153  06 06 C6  
       01:6156  7C 00     
   49  01:6158  C6 CC D8  	.db $c6,$cc,$d8,$f0,$d8,$cc,$c6,$00	;K
       01:615B  F0 D8 CC  
       01:615E  C6 00     
   50  01:6160  C0 C0 C0  	.db $c0,$c0,$c0,$c0,$c0,$c0,$fe,$00	;L
       01:6163  C0 C0 C0  
       01:6166  FE 00     
   51  01:6168  82 C6 EE  	.db $82,$c6,$ee,$fe,$d6,$c6,$c6,$00	;M
       01:616B  FE D6 C6  
       01:616E  C6 00     
   52  01:6170  86 C6 E6  	.db $86,$c6,$e6,$f6,$de,$ce,$c6,$00	;N
       01:6173  F6 DE CE  
       01:6176  C6 00     
   53  01:6178  7C C6 C6  	.db $7c,$c6,$c6,$c6,$c6,$c6,$7c,$00	;O
       01:617B  C6 C6 C6  
       01:617E  7C 00     
   54                     
   55  01:6180  FC C6 C6  	.db $fc,$c6,$c6,$c6,$fc,$c0,$c0,$00	;P
       01:6183  C6 FC C0  
       01:6186  C0 00     
   56  01:6188  7C C6 C6  	.db $7c,$c6,$c6,$c6,$de,$cc,$76,$00	;Q
       01:618B  C6 DE CC  
       01:618E  76 00     
   57  01:6190  FC C6 C6  	.db $fc,$c6,$c6,$fc,$d8,$cc,$c6,$00	;R
       01:6193  FC D8 CC  
       01:6196  C6 00     
   58  01:6198  7C C6 F0  	.db $7c,$c6,$f0,$7c,$1e,$c6,$7c,$00	;S
       01:619B  7C 1E C6  
       01:619E  7C 00     
   59  01:61A0  7E 18 18  	.db $7e,$18,$18,$18,$18,$18,$18,$00	;T
       01:61A3  18 18 18  
       01:61A6  18 00     
   60  01:61A8  C6 C6 C6  	.db $c6,$c6,$c6,$c6,$c6,$c6,$7c,$00	;U
       01:61AB  C6 C6 C6  
       01:61AE  7C 00     
   61  01:61B0  C6 C6 C6  	.db $c6,$c6,$c6,$c6,$c6,$6c,$38,$00	;V
       01:61B3  C6 C6 6C  
       01:61B6  38 00     
   62  01:61B8  C6 C6 C6  	.db $c6,$c6,$c6,$d6,$fe,$ee,$c6,$00	;W
       01:61BB  D6 FE EE  
       01:61BE  C6 00     
   63  01:61C0  C6 EE 7C  	.db $c6,$ee,$7c,$38,$7c,$ee,$c6,$00	;X
       01:61C3  38 7C EE  
       01:61C6  C6 00     
   64  01:61C8  66 66 66  	.db $66,$66,$66,$3c,$18,$18,$18,$00	;Y
       01:61CB  3C 18 18  
       01:61CE  18 00     
   65  01:61D0  FE 0E 1C  	.db $fe,$0e,$1c,$38,$70,$e0,$fe,$00	;Z
       01:61D3  38 70 E0  
       01:61D6  FE 00     
   66  01:61D8  78 60 60  	.db $78,$60,$60,$60,$60,$60,$78,$00	;[
       01:61DB  60 60 60  
       01:61DE  78 00     
   67  01:61E0  C0 60 30  	.db $c0,$60,$30,$18,$0c,$06,$00,$00	;\
       01:61E3  18 0C 06  
       01:61E6  00 00     
   68  01:61E8  3C 0C 0C  	.db $3c,$0c,$0c,$0c,$0c,$0c,$3c,$00	;]
       01:61EB  0C 0C 0C  
       01:61EE  3C 00     
   69  01:61F0  10 28 44  	.db $10,$28,$44,$00,$00,$00,$00,$00	;^
       01:61F3  00 00 00  
       01:61F6  00 00     
   70  01:61F8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$fe,$00	;_
       01:61FB  00 00 00  
       01:61FE  FE 00     
   71                     
   72  01:6200  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	; 
       01:6203  00 00 00  
       01:6206  00 00     
   73  01:6208  00 00 3C  	.db $00,$00,$3c,$06,$7e,$c6,$7e,$00	;a
       01:620B  06 7E C6  
       01:620E  7E 00     
   74  01:6210  C0 C0 FC  	.db $c0,$c0,$fc,$c6,$c6,$c6,$fc,$00	;b
       01:6213  C6 C6 C6  
       01:6216  FC 00     
   75  01:6218  00 00 7C  	.db $00,$00,$7c,$c6,$c0,$c6,$7c,$00	;c
       01:621B  C6 C0 C6  
       01:621E  7C 00     
   76  01:6220  06 06 7E  	.db $06,$06,$7e,$c6,$c6,$c6,$7e,$00	;d
       01:6223  C6 C6 C6  
       01:6226  7E 00     
   77  01:6228  00 00 7C  	.db $00,$00,$7c,$c6,$fc,$c0,$7e,$00	;e
       01:622B  C6 FC C0  
       01:622E  7E 00     
   78  01:6230  3E 60 60  	.db $3e,$60,$60,$f8,$60,$60,$60,$00	;f
       01:6233  F8 60 60  
       01:6236  60 00     
   79  01:6238  00 00 7C  	.db $00,$00,$7c,$c6,$c6,$7e,$06,$7c	;g
       01:623B  C6 C6 7E  
       01:623E  06 7C     
   80  01:6240  C0 C0 FC  	.db $c0,$c0,$fc,$c6,$c6,$c6,$c6,$00	;h
       01:6243  C6 C6 C6  
       01:6246  C6 00     
   81  01:6248  18 00 18  	.db $18,$00,$18,$18,$18,$18,$18,$00	;i
       01:624B  18 18 18  
       01:624E  18 00     
   82  01:6250  0C 0C 00  	.db $0c,$0c,$00,$0c,$0c,$0c,$0c,$78	;j
       01:6253  0C 0C 0C  
       01:6256  0C 78     
   83  01:6258  C0 C0 D8  	.db $c0,$c0,$d8,$f0,$e0,$f0,$d8,$00	;k
       01:625B  F0 E0 F0  
       01:625E  D8 00     
   84  01:6260  70 30 30  	.db $70,$30,$30,$30,$30,$30,$78,$00	;l
       01:6263  30 30 30  
       01:6266  78 00     
   85  01:6268  00 00 7C  	.db $00,$00,$7c,$d6,$d6,$d6,$d6,$00	;m
       01:626B  D6 D6 D6  
       01:626E  D6 00     
   86  01:6270  00 00 7C  	.db $00,$00,$7c,$66,$66,$66,$66,$00	;n
       01:6273  66 66 66  
       01:6276  66 00     
   87  01:6278  00 00 3C  	.db $00,$00,$3c,$66,$66,$66,$3c,$00	;o
       01:627B  66 66 66  
       01:627E  3C 00     
   88                     
   89  01:6280  00 00 7C  	.db $00,$00,$7c,$66,$66,$7c,$60,$60	;p
       01:6283  66 66 7C  
       01:6286  60 60     
   90  01:6288  00 00 3E  	.db $00,$00,$3e,$66,$66,$3e,$06,$06	;q
       01:628B  66 66 3E  
       01:628E  06 06     
   91  01:6290  00 00 D8  	.db $00,$00,$d8,$fc,$e0,$c0,$c0,$00	;r
       01:6293  FC E0 C0  
       01:6296  C0 00     
   92  01:6298  00 00 3C  	.db $00,$00,$3c,$60,$38,$0c,$78,$00	;s
       01:629B  60 38 0C  
       01:629E  78 00     
   93  01:62A0  30 30 78  	.db $30,$30,$78,$30,$30,$30,$1c,$00	;t
       01:62A3  30 30 30  
       01:62A6  1C 00     
   94  01:62A8  00 00 66  	.db $00,$00,$66,$66,$66,$66,$3e,$00	;u
       01:62AB  66 66 66  
       01:62AE  3E 00     
   95  01:62B0  00 00 C6  	.db $00,$00,$c6,$c6,$6c,$38,$10,$00	;v
       01:62B3  C6 6C 38  
       01:62B6  10 00     
   96  01:62B8  00 00 C6  	.db $00,$00,$c6,$d6,$d6,$d6,$6c,$00	;w
       01:62BB  D6 D6 D6  
       01:62BE  6C 00     
   97  01:62C0  00 00 C6  	.db $00,$00,$c6,$6c,$10,$6c,$c6,$00	;x
       01:62C3  6C 10 6C  
       01:62C6  C6 00     
   98  01:62C8  00 00 66  	.db $00,$00,$66,$66,$66,$3e,$06,$3c	;y
       01:62CB  66 66 3E  
       01:62CE  06 3C     
   99  01:62D0  00 00 FE  	.db $00,$00,$fe,$0c,$38,$60,$fe,$00	;z
       01:62D3  0C 38 60  
       01:62D6  FE 00     
  100  01:62D8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62DB  00 00 00  
       01:62DE  00 00     
  101  01:62E0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62E3  00 00 00  
       01:62E6  00 00     
  102  01:62E8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62EB  00 00 00  
       01:62EE  00 00     
  103  01:62F0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62F3  00 00 00  
       01:62F6  00 00     
  104  01:62F8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62FB  00 00 00  
       01:62FE  00 00     
  105                     
  106  01:6300            font_2:
  107  01:6300  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;SPACE
       01:6303  00 00 00  
       01:6306  00 00     
  108  01:6308  04 0C 0C  	.db $04,$0c,$0c,$08,$08,$00,$10,$00	;!
       01:630B  08 08 00  
       01:630E  10 00     
  109  01:6310  36 12 24  	.db $36,$12,$24,$00,$00,$00,$00,$00	;"
       01:6313  00 00 00  
       01:6316  00 00     
  110  01:6318  12 3F 12  	.db $12,$3f,$12,$22,$24,$7e,$24,$00	;#
       01:631B  22 24 7E  
       01:631E  24 00     
  111  01:6320  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;$
       01:6323  00 00 00  
       01:6326  00 00     
  112  01:6328  00 31 32  	.db $00,$31,$32,$04,$18,$26,$46,$00	;%
       01:632B  04 18 26  
       01:632E  46 00     
  113  01:6330  08 14 14  	.db $08,$14,$14,$38,$4a,$44,$3a,$00	;&
       01:6333  38 4A 44  
       01:6336  3A 00     
  114  01:6338  18 08 10  	.db $18,$08,$10,$00,$00,$00,$00,$00	;'
       01:633B  00 00 00  
       01:633E  00 00     
  115  01:6340  0C 10 20  	.db $0c,$10,$20,$20,$20,$10,$08,$00	;(
       01:6343  20 20 10  
       01:6346  08 00     
  116  01:6348  10 08 04  	.db $10,$08,$04,$04,$04,$08,$30,$00	;)
       01:634B  04 04 08  
       01:634E  30 00     
  117  01:6350  00 08 2A  	.db $00,$08,$2a,$1c,$1c,$2a,$08,$00	;*
       01:6353  1C 1C 2A  
       01:6356  08 00     
  118  01:6358  00 08 08  	.db $00,$08,$08,$3e,$08,$08,$00,$00	;+
       01:635B  3E 08 08  
       01:635E  00 00     
  119  01:6360  00 00 00  	.db $00,$00,$00,$00,$60,$60,$20,$40	;,
       01:6363  00 60 60  
       01:6366  20 40     
  120  01:6368  00 00 00  	.db $00,$00,$00,$1e,$00,$00,$00,$00	;-
       01:636B  1E 00 00  
       01:636E  00 00     
  121  01:6370  00 00 00  	.db $00,$00,$00,$00,$00,$60,$60,$00	;.
       01:6373  00 00 60  
       01:6376  60 00     
  122  01:6378  00 02 04  	.db $00,$02,$04,$08,$10,$20,$40,$00	;/
       01:637B  08 10 20  
       01:637E  40 00     
  123                     
  124  01:6380  1C 22 22  	.db $1c,$22,$22,$42,$42,$44,$38,$00	;0
       01:6383  42 42 44  
       01:6386  38 00     
  125  01:6388  0C 1C 04  	.db $0c,$1c,$04,$08,$08,$08,$3c,$00	;1
       01:638B  08 08 08  
       01:638E  3C 00     
  126  01:6390  1C 22 02  	.db $1c,$22,$02,$0c,$30,$40,$7c,$00	;2
       01:6393  0C 30 40  
       01:6396  7C 00     
  127  01:6398  1C 22 02  	.db $1c,$22,$02,$0c,$02,$44,$38,$00	;3
       01:639B  0C 02 44  
       01:639E  38 00     
  128  01:63A0  0E 12 24  	.db $0e,$12,$24,$44,$7f,$08,$08,$00	;4
       01:63A3  44 7F 08  
       01:63A6  08 00     
  129  01:63A8  1F 10 20  	.db $1f,$10,$20,$3c,$02,$42,$3c,$00	;5
       01:63AB  3C 02 42  
       01:63AE  3C 00     
  130  01:63B0  1E 21 20  	.db $1e,$21,$20,$7c,$42,$42,$3c,$00	;6
       01:63B3  7C 42 42  
       01:63B6  3C 00     
  131  01:63B8  3E 22 44  	.db $3e,$22,$44,$04,$08,$08,$10,$00	;7
       01:63BB  04 08 08  
       01:63BE  10 00     
  132  01:63C0  1C 22 22  	.db $1c,$22,$22,$3c,$42,$42,$3c,$00	;8
       01:63C3  3C 42 42  
       01:63C6  3C 00     
  133  01:63C8  1C 22 22  	.db $1c,$22,$22,$1e,$02,$44,$38,$00	;9
       01:63CB  1E 02 44  
       01:63CE  38 00     
  134  01:63D0  00 00 08  	.db $00,$00,$08,$00,$00,$00,$10,$00	;:
       01:63D3  00 00 00  
       01:63D6  10 00     
  135  01:63D8  00 00 08  	.db $00,$00,$08,$00,$00,$00,$10,$20	;;
       01:63DB  00 00 00  
       01:63DE  10 20     
  136  01:63E0  00 04 08  	.db $00,$04,$08,$10,$10,$08,$04,$00	;<
       01:63E3  10 10 08  
       01:63E6  04 00     
  137  01:63E8  00 00 00  	.db $00,$00,$00,$1e,$00,$1e,$00,$00	;=
       01:63EB  1E 00 1E  
       01:63EE  00 00     
  138  01:63F0  00 10 08  	.db $00,$10,$08,$04,$04,$08,$10,$00	;>
       01:63F3  04 04 08  
       01:63F6  10 00     
  139  01:63F8  1C 22 02  	.db $1c,$22,$02,$04,$08,$00,$10,$00	;?
       01:63FB  04 08 00  
       01:63FE  10 00     
  140                     
  141  01:6400  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;@
       01:6403  00 00 00  
       01:6406  00 00     
  142  01:6408  0E 12 12  	.db $0e,$12,$12,$22,$3e,$42,$42,$00	;A
       01:640B  22 3E 42  
       01:640E  42 00     
  143  01:6410  1C 12 22  	.db $1c,$12,$22,$3c,$22,$42,$7c,$00	;B
       01:6413  3C 22 42  
       01:6416  7C 00     
  144  01:6418  1C 22 22  	.db $1c,$22,$22,$40,$40,$44,$38,$00	;C
       01:641B  40 40 44  
       01:641E  38 00     
  145  01:6420  18 14 22  	.db $18,$14,$22,$22,$42,$44,$f8,$00	;D
       01:6423  22 42 44  
       01:6426  F8 00     
  146  01:6428  1E 10 20  	.db $1e,$10,$20,$3c,$20,$40,$7c,$00	;E
       01:642B  3C 20 40  
       01:642E  7C 00     
  147  01:6430  1E 10 20  	.db $1e,$10,$20,$3c,$20,$40,$40,$00	;F
       01:6433  3C 20 40  
       01:6436  40 00     
  148  01:6438  1C 22 20  	.db $1c,$22,$20,$40,$47,$44,$38,$00	;G
       01:643B  40 47 44  
       01:643E  38 00     
  149  01:6440  11 11 22  	.db $11,$11,$22,$3e,$22,$44,$44,$00	;H
       01:6443  3E 22 44  
       01:6446  44 00     
  150  01:6448  1E 08 08  	.db $1e,$08,$08,$10,$10,$20,$f0,$00	;I
       01:644B  10 10 20  
       01:644E  F0 00     
  151  01:6450  1E 04 04  	.db $1e,$04,$04,$08,$88,$90,$60,$00	;J
       01:6453  08 88 90  
       01:6456  60 00     
  152  01:6458  10 12 24  	.db $10,$12,$24,$38,$28,$44,$44,$00	;K
       01:645B  38 28 44  
       01:645E  44 00     
  153  01:6460  10 10 20  	.db $10,$10,$20,$20,$20,$40,$7c,$00	;L
       01:6463  20 20 40  
       01:6466  7C 00     
  154  01:6468  21 27 5A  	.db $21,$27,$5a,$52,$42,$84,$84,$00	;M
       01:646B  52 42 84  
       01:646E  84 00     
  155  01:6470  21 21 52  	.db $21,$21,$52,$52,$4a,$84,$84,$00	;N
       01:6473  52 4A 84  
       01:6476  84 00     
  156  01:6478  1C 22 22  	.db $1c,$22,$22,$42,$42,$44,$38,$00	;O
       01:647B  42 42 44  
       01:647E  38 00     
  157                     
  158  01:6480  1C 12 22  	.db $1c,$12,$22,$3c,$20,$40,$40,$00	;P
       01:6483  3C 20 40  
       01:6486  40 00     
  159  01:6488  1C 22 22  	.db $1c,$22,$22,$42,$4a,$44,$34,$02	;Q
       01:648B  42 4A 44  
       01:648E  34 02     
  160  01:6490  1C 12 22  	.db $1c,$12,$22,$3c,$28,$48,$46,$00	;R
       01:6493  3C 28 48  
       01:6496  46 00     
  161  01:6498  1C 22 20  	.db $1c,$22,$20,$18,$04,$44,$38,$00	;S
       01:649B  18 04 44  
       01:649E  38 00     
  162  01:64A0  3E 08 10  	.db $3e,$08,$10,$10,$10,$20,$20,$00	;T
       01:64A3  10 10 20  
       01:64A6  20 00     
  163  01:64A8  22 22 42  	.db $22,$22,$42,$44,$44,$44,$38,$00	;U
       01:64AB  44 44 44  
       01:64AE  38 00     
  164  01:64B0  42 44 44  	.db $42,$44,$44,$48,$50,$50,$60,$00	;V
       01:64B3  48 50 50  
       01:64B6  60 00     
  165  01:64B8  41 41 42  	.db $41,$41,$42,$52,$52,$6c,$44,$00	;W
       01:64BB  52 52 6C  
       01:64BE  44 00     
  166  01:64C0  22 24 18  	.db $22,$24,$18,$18,$28,$44,$44,$00	;X
       01:64C3  18 28 44  
       01:64C6  44 00     
  167  01:64C8  42 42 24  	.db $42,$42,$24,$18,$10,$20,$20,$00	;Y
       01:64CB  18 10 20  
       01:64CE  20 00     
  168  01:64D0  3E 02 04  	.db $3e,$02,$04,$18,$20,$40,$7c,$00	;Z
       01:64D3  18 20 40  
       01:64D6  7C 00     
  169  01:64D8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;[
       01:64DB  00 00 00  
       01:64DE  00 00     
  170  01:64E0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;\
       01:64E3  00 00 00  
       01:64E6  00 00     
  171  01:64E8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;]
       01:64EB  00 00 00  
       01:64EE  00 00     
  172  01:64F0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;^
       01:64F3  00 00 00  
       01:64F6  00 00     
  173  01:64F8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$3e,$00	;_
       01:64FB  00 00 00  
       01:64FE  3E 00     
  174                     
  175  01:6500  00 10 18  	.db $00,$10,$18,$18,$00,$00,$00,$00	; 
       01:6503  18 00 00  
       01:6506  00 00     
  176  01:6508  00 1C 02  	.db $00,$1c,$02,$3c,$44,$48,$34,$00	;a
       01:650B  3C 44 48  
       01:650E  34 00     
  177  01:6510  00 08 08  	.db $00,$08,$08,$1c,$12,$22,$3c,$00	;b
       01:6513  1C 12 22  
       01:6516  3C 00     
  178  01:6518  00 00 1C  	.db $00,$00,$1c,$22,$40,$40,$38,$00	;c
       01:651B  22 40 40  
       01:651E  38 00     
  179  01:6520  00 02 02  	.db $00,$02,$02,$3c,$44,$48,$38,$00	;d
       01:6523  3C 44 48  
       01:6526  38 00     
  180  01:6528  00 00 1C  	.db $00,$00,$1c,$22,$7e,$40,$38,$00	;e
       01:652B  22 7E 40  
       01:652E  38 00     
  181  01:6530  00 06 08  	.db $00,$06,$08,$3c,$10,$20,$20,$00	;f
       01:6533  3C 10 20  
       01:6536  20 00     
  182  01:6538  00 00 3A  	.db $00,$00,$3a,$44,$44,$38,$08,$70	;g
       01:653B  44 44 38  
       01:653E  08 70     
  183  01:6540  00 08 08  	.db $00,$08,$08,$1c,$12,$22,$24,$00	;h
       01:6543  1C 12 22  
       01:6546  24 00     
  184  01:6548  00 04 00  	.db $00,$04,$00,$08,$08,$10,$10,$00	;i
       01:654B  08 08 10  
       01:654E  10 00     
  185  01:6550  00 02 00  	.db $00,$02,$00,$04,$44,$48,$38,$00	;j
       01:6553  04 44 48  
       01:6556  38 00     
  186  01:6558  00 10 12  	.db $00,$10,$12,$24,$38,$48,$46,$00	;k
       01:655B  24 38 48  
       01:655E  46 00     
  187  01:6560  00 0C 04  	.db $00,$0c,$04,$08,$08,$10,$10,$00	;l
       01:6563  08 08 10  
       01:6566  10 00     
  188  01:6568  00 00 2A  	.db $00,$00,$2a,$15,$25,$29,$4a,$00	;m
       01:656B  15 25 29  
       01:656E  4A 00     
  189  01:6570  00 00 2C  	.db $00,$00,$2c,$12,$12,$24,$26,$00	;n
       01:6573  12 12 24  
       01:6576  26 00     
  190  01:6578  00 00 0C  	.db $00,$00,$0c,$12,$22,$24,$18,$00	;o
       01:657B  12 22 24  
       01:657E  18 00     
  191                     
  192  01:6580  00 0E 09  	.db $00,$0e,$09,$11,$1e,$20,$20,$00	;p
       01:6583  11 1E 20  
       01:6586  20 00     
  193  01:6588  00 1E 22  	.db $00,$1e,$22,$24,$1c,$08,$08,$00	;q
       01:658B  24 1C 08  
       01:658E  08 00     
  194  01:6590  00 00 2C  	.db $00,$00,$2c,$12,$10,$20,$20,$00	;r
       01:6593  12 10 20  
       01:6596  20 00     
  195  01:6598  00 00 1C  	.db $00,$00,$1c,$22,$18,$44,$38,$00	;s
       01:659B  22 18 44  
       01:659E  38 00     
  196  01:65A0  00 08 3C  	.db $00,$08,$3c,$10,$20,$20,$18,$00	;t
       01:65A3  10 20 20  
       01:65A6  18 00     
  197  01:65A8  00 00 22  	.db $00,$00,$22,$42,$44,$48,$34,$00	;u
       01:65AB  42 44 48  
       01:65AE  34 00     
  198  01:65B0  00 00 22  	.db $00,$00,$22,$24,$28,$28,$10,$00	;v
       01:65B3  24 28 28  
       01:65B6  10 00     
  199  01:65B8  00 00 21  	.db $00,$00,$21,$41,$49,$5a,$2c,$00	;w
       01:65BB  41 49 5A  
       01:65BE  2C 00     
  200  01:65C0  00 00 11  	.db $00,$00,$11,$0a,$0c,$14,$22,$00	;x
       01:65C3  0A 0C 14  
       01:65C6  22 00     
  201  01:65C8  00 00 11  	.db $00,$00,$11,$21,$22,$1e,$04,$38	;y
       01:65CB  21 22 1E  
       01:65CE  04 38     
  202  01:65D0  00 00 3E  	.db $00,$00,$3e,$04,$18,$20,$7c,$00	;z
       01:65D3  04 18 20  
       01:65D6  7C 00     
  203  01:65D8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65DB  00 00 00  
       01:65DE  00 00     
  204  01:65E0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65E3  00 00 00  
       01:65E6  00 00     
  205  01:65E8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65EB  00 00 00  
       01:65EE  00 00     
  206  01:65F0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65F3  00 00 00  
       01:65F6  00 00     
  207  01:65F8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65FB  00 00 00  
       01:65FE  00 00     
#[2]   startup.asm
  181           E000      	.code
  182           0001      	.bank LIB2_BANK
  183           A600      	.org  $A600
  184                     
  185           0000      .ifdef HAVE_LIB3
  189                     .endif
  190                     
  191           6600      	.data
  192           0002      	.bank CONST_BANK,"Constants"
  193           4000      	.org  $4000
  194                     
  195           4000      	.data
  196           0003      	.bank DATA_BANK,"User Program"
  197           6000      	.org  $6000
  198                     
  199                     ;
  200                     ; place overlay array here
  201                     ; 100 entries, stored as 100
  202                     ; lo-bytes of the starting
  203                     ; sector num, followed by 100
  204                     ; hi-bytes for a 128MB range
  205                     ; all files are contiguous, so
  206                     ; the # sectors is calculated
  207                     ;
  208  03:6000            ovlarray:	.ds	200
  209                     
  210                     
  211           A600      	.code
  212           0000      	.bank START_BANK,"Base Library 1"
  213                     
  214                     ; A little introduction to the boot sequence:
  215                     ;
  216                     ; A HuCard has its origin at bank 0, and is mapped at $E000
  217                     ; It needs to grab the interrupt vectors at $FFF6 and implement
  218                     ; implement handlers for them
  219                     ;
  220                     ; A CDROM will load at bank $80 ($68 for SCD), and the initial
  221                     ; loader will be mapped at $4000.  The current MagicKit sequence
  222                     ; also maps $C000 to this same bank.  However, the initial boot
  223                     ; sequence will execute at $4070, proceeding to load additional
  224                     ; code and data, and then jump to a post-boot section called
  225                     ; 'init_go'.  This is the point at which the loader explicitly
  226                     ; relinquishes the $4000 segment.  It should be noted that there
  227                     ; are library subroutines loaded as part of this initial segment,
  228                     ; and those routines are located in the $C000 range as well.
  229                     ;
  230                     ; Sectors are loaded, up to and including the first "DATA_BANK",
  231                     ; where the overlay array is stored - so that the CDROM error
  232                     ; overlay can be located and executed in the event of a CDROM
  233                     ; system version mismatch (ie. playing SCD games on CDROM)
  234                     ;
  235                     ; A second entry point is defined for overlays that are not
  236                     ; being booted (ie. they are loaded and executed from another
  237                     ; overlay).  This entry point is at $4000, after the segments
  238                     ; have all found their natural loading spots (ie. segment $68
  239                     ; for Super CDROMs).  This entry point maps the necessary
  240                     ; segments and resets the stack, without clearing memory or
  241                     ; performing other setup chores, and then maps and executes
  242                     ; _main() to run the module.  The user has no choice regarding
  243                     ; this function, although he can pass values through the global
  244                     ; variables which main() can use to decide what to do next.
  245                     ;
  246                     ; An additional "Hook" area has now been defined at $402F,
  247                     ; which is used at initial load time, in case a SCD overlay
  248                     ; program is run on plain CDROM hardware, and the author
  249                     ; wishes to override the default text error message by
  250                     ; loading and executing a plain CDROM program instead
  251                     ;
  252                         ; ----
  253                         ; interrupt vectors
  254                     
  255           0001      .if !(CDROM)
  256           FFF6      	.org  $FFF6
  257                     
  258  00:FFF6  23 E1     	.dw irq2
  259  00:FFF8  2A E1     	.dw irq1
  260  00:FFFA  B8 E2     	.dw timer
  261  00:FFFC  C5 E2     	.dw nmi
  262  00:FFFE  10 E0     	.dw reset
  263                     .endif	; !(CDROM)
  264                     
  265                         ; ----
  266                         ; develo startup code
  267                     
  268           0000      .if (DEVELO)
  278                     .endif	; (DEVELO)
  279                     
  280                     
  281                     ; ----
  282                     ; reset
  283                     ; ----
  284                     ; things start here
  285                     ; ----
  286                     
  287                         ; ----
  288                         ; CDROM re-map library bank
  289                         ;
  290                     ;
  291                     ; overlay entry point
  292                     ;
  293                     ; assume MMR0, MMR1, MMR6, MMR7 are set.
  294                     ; set others & reset stack pointer
  295                     ;
  296           0000      .if (CDROM)
  409                     .else		; (ie. if HuCard...)
  410                     
  411           E010      	.org  $E010
  412  00:E010            reset:
  413  00:E010  78        	sei			; disable interrupts 
  414  00:E011  D4        	csh			; select the 7.16 MHz clock
  415  00:E012  D8        	cld			; clear the decimal flag 
  416  00:E013  A2 FF     	ldx   #$FF		; initialize the stack pointer
  417  00:E015  9A        	txs 
  418  00:E016  A9 FF     	lda   #$FF		; map the I/O bank in the first page
  419  00:E018  53 01     	tam   #0
  420  00:E01A  A9 F8     	lda   #$F8		; and the RAM bank in the second page
  421  00:E01C  53 02     	tam   #1
  422  00:E01E  9C 00 20  	stz   $2000		; clear all the RAM
  423  00:E021  73 00 20  	tii   $2000,$2001,$1FFF
       00:E024  01 20 FF  
       00:E027  1F        
  424                     
  425                     .endif	; (CDROM)
  426                     
  427                         ; ----
  428                         ; initialize the hardware
  429                     
  430           0000      .if (CDROM)
  435                     .else
  436  00:E028  9C 01 0C  	stz   timer_ctrl	; init timer
  437                     .endif	; (CDROM)
  438                     
  439  00:E02B  20 A8 E4  	jsr   init_psg		; init sound
  440  00:E02E  20 3E E4  	jsr   init_vdc		; init video
  441           0000      .ifdef _SGX
  443                     .endif
  444  00:E031  A9 1F     	lda   #$1F		; init joypad
  445  00:E033  8D 27 22  	sta   joyena
  446                     
  447                         ; ----
  448                         ; initialize the sound driver
  449                     
  450                     	__sound_init
  451                     
  452                         ; ----
  453                         ; initialize interrupt vectors
  454                     
  455           0000      .if  (CDROM)
  460                     .else
  461  00:E036  A2 04     	ldx   #4		; user vector table
  462  00:E038  C2        	cly
  463  00:E039  A9 22     .l2:	lda   #LOW(rti)
  464  00:E03B  99 00 22  	sta   user_jmptbl,Y
  465  00:E03E  C8        	iny
  466  00:E03F  A9 E1     	lda   #HIGH(rti)
  467  00:E041  99 00 22  	sta   user_jmptbl,Y
  468  00:E044  C8        	iny
  469  00:E045  CA        	dex
  470  00:E046  D0 F1     	bne   .l2
  471                     
  472                     	stw   #reset,soft_reset ; soft reset
       00:E048  A9 10     	lda	LOW_BYTE #reset
       00:E04A  8D 84 22  	sta	LOW_BYTE soft_reset
       00:E04D  A9 E0     	lda	HIGH_BYTE #reset
       00:E04F  8D 85 22  	sta	HIGH_BYTE soft_reset
  473                     	stw   #rts,vsync_hook   ; user vsync routine
       00:E052  A9 21     	lda	LOW_BYTE #rts
       00:E054  8D 08 22  	sta	LOW_BYTE vsync_hook
       00:E057  A9 E1     	lda	HIGH_BYTE #rts
       00:E059  8D 09 22  	sta	HIGH_BYTE vsync_hook
  474                     	stw   #rts,hsync_hook   ; user hsync routine
       00:E05C  A9 21     	lda	LOW_BYTE #rts
       00:E05E  8D 0A 22  	sta	LOW_BYTE hsync_hook
       00:E061  A9 E1     	lda	HIGH_BYTE #rts
       00:E063  8D 0B 22  	sta	HIGH_BYTE hsync_hook
  475                     
  476  00:E066  A9 01     	lda   #$01		 ; enable interrupts
  477  00:E068  8D 02 14  	sta   irq_disable
  478  00:E06B  9C 03 14  	stz   irq_status
  479  00:E06E  58        	cli
  480                     
  481                         ; ----
  482                         ; enable display and VSYNC interrupt
  483                     
  484                     	vreg  #5
       00:E06F  A9 05     	lda	#5
       00:E071  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:E073  03 05     	st0	#5
                          .else
                          .endif
  485  00:E075  A9 C8     	lda   #$C8
  486  00:E077  85 F3     	sta   <vdc_crl
  487  00:E079  8D 02 00  	sta   video_data_l
  488  00:E07C  23 00     	st2   #$00
  489  00:E07E  A9 01     	lda   #$01
  490  00:E080  8D 8E 26  	sta   disp_cr
  491                     
  492                     .endif	; (CDROM)
  493                     
  494                         ; ----
  495                         ; init TIA instruction in RAM (fast BLiTter to hardware)
  496                     
  497  00:E083  A9 E3     	lda   #$E3		; TIA instruction opcode
  498  00:E085  8D FE 26  	sta   ram_hdwr_tia
  499  00:E088  A9 60     	lda   #$60		; RTS instruction opcode
  500  00:E08A  8D 05 27  	sta   ram_hdwr_tia_rts
  501                     
  502                         ; ----
  503                         ; init random number generator
  504                     
  505  00:E08D  A9 01     	lda   #1
  506  00:E08F  20 F1 FA  	jsr   wait_vsync	; wait for one frame & randomize rndseed2
  507                     	stw   #$03E7,<__cx	; set random seed
       00:E092  A9 E7     	lda	LOW_BYTE #$03E7
       00:E094  85 FC     	sta	LOW_BYTE <__cx	
       00:E096  A9 03     	lda	HIGH_BYTE #$03E7
       00:E098  85 FD     	sta	HIGH_BYTE <__cx	
  508                     	stw   rndseed2,<__dx
       00:E09A  AD 75 27  	lda	LOW_BYTE rndseed2
       00:E09D  85 FE     	sta	LOW_BYTE <__dx
       00:E09F  AD 76 27  	lda	HIGH_BYTE rndseed2
       00:E0A2  85 FF     	sta	HIGH_BYTE <__dx
  509  00:E0A4  20 BE E6  	jsr   srand
  510                     
  511           0000      .if (CDROM)
  606                     .endif	; (CDROM)
  607                     
  608                         ; ----
  609                         ; jump to main routine
  610                     
  611                         ; ----
  612                         ; load font
  613                     
  614           0001      .ifdef HUC
  615                     
  616           0001      .ifndef SMALL
  617                     	stw   #$4000,<__sp	; init stack ptr first
       00:E0A7  A9 00     	lda	LOW_BYTE #$4000
       00:E0A9  85 00     	sta	LOW_BYTE <__sp	
       00:E0AB  A9 40     	lda	HIGH_BYTE #$4000
       00:E0AD  85 01     	sta	HIGH_BYTE <__sp	
  618                     .else
  620                     .endif
  621                     
  622                     	stw   #FONT_VADDR,<__di	; Load Font @ VRAM addr
       00:E0AF  A9 00     	lda	LOW_BYTE #FONT_VADDR
       00:E0B1  85 F0     	sta	LOW_BYTE <__di	
       00:E0B3  A9 08     	lda	HIGH_BYTE #FONT_VADDR
       00:E0B5  85 F1     	sta	HIGH_BYTE <__di	
  623                     
  624                     	;
  625                     	; this section of font loading was stolen
  626                     	; from _load_default_font because the default
  627                     	; FONT segment number is not yet guaranteed
  628                     	; if the SCD is being run on a plain CDROM system
  629                     	; so we need to trick the segment pointer
  630                     	; with a reliable one
  631                     	;
  632                           __ldw   <__di	; stolen from _load_default_font
                0000      .if (1 = 2)
                          .else
       00:E0B7  A6 F0     	ldx	<__di	
       00:E0B9  A5 F1     	lda	<__di	+1
                          .endif
  633                     			; because segment# default not reliable
  634                     
  635  00:E0BB  20 79 ED  	jsr   _set_font_addr		; set VRAM
  636                     
  637           0000      .if (CDROM)
  640                     .else
  641                     	stb   #FONT_BANK+_bank_base,<__bl
       00:E0BE  A9 01     	lda	#FONT_BANK+_bank_base
       00:E0C0  85 FA     	sta	<__bl
  642                     .endif
  643                     
  644                     	stb   #96,<__cl
       00:E0C2  A9 60     	lda	#96
       00:E0C4  85 FC     	sta	<__cl
  645                     	stb   font_color+1,<__ah
       00:E0C6  AD 7C 27  	lda	font_color+1
       00:E0C9  85 F9     	sta	<__ah
  646  00:E0CB  AD 7B 27  	lda   font_color
  647  00:E0CE  D0 01     	bne   .fntld
  648  00:E0D0  1A        	inc   A
  649  00:E0D1  85 F8     .fntld:	sta   <__al
  650  00:E0D3  82        	clx
  651  00:E0D4  BD CC E2  	lda   font_table,X
  652  00:E0D7  85 EE     	sta   <__si
  653  00:E0D9  E8        	inx
  654  00:E0DA  BD CC E2  	lda   font_table,X
  655  00:E0DD  85 EF     	sta   <__si+1
  656                     
  657                     
  658                     	; Now, load the font
  659                     	;
  660                     	;   Note for CDROM/Super CDROM:
  661                     	;
  662                     	; The 'REAL' mapping for the lib2_load_font function
  663                     	; maybe doesn't exist yet (we are executing from bank $80,
  664                     	; not from $68 if it's a Super CDROM)
  665                     	;
  666                     	; So we must map the version at bank ($80 + LIB2_BANK)
  667                     	; before executing it.  We remap the bank after completion,
  668                     	; 'just in case'
  669                     
  670           0000      .if  (CDROM)
  678                     .else
  679  00:E0DF  20 75 E3  	jsr   load_font
  680                     .endif
  681                     
  682                     	;
  683                     	; END stolen font-load
  684                     	;
  685                     
  686  00:E0E2  20 2D ED  	jsr   _cls
  687                     
  688  00:E0E5  9C 02 04  	stz  color_reg	; set color #0 = 0/0/0 rgb
  689  00:E0E8  9C 03 04  	stz  color_reg+1
  690  00:E0EB  9C 04 04  	stz  color_data
  691  00:E0EE  9C 05 04  	stz  color_data+1
  692                     
  693  00:E0F1  A9 01     	lda  #1		; set color #1 = 7/7/7 rgb
  694  00:E0F3  8D 02 04  	sta  color_reg
  695  00:E0F6  9C 03 04  	stz  color_reg+1
  696  00:E0F9  A2 FF     	ldx  #$ff
  697  00:E0FB  8E 04 04  	stx  color_data
  698  00:E0FE  8D 05 04  	sta  color_data+1
  699                     
  700                         ; ----
  701                         ; Super CDROM error message
  702                         ; ----
  703                     
  704           0000      .if (CDROM)
  747                     .endif		; (CDROM)
  748                     
  749                     .endif		; (HUC)
  750                     
  751                     
  752           0001      .ifdef SUPPORT_MOUSE
  753  00:E101  20 9D FA  	jsr  mousinit		; check existence of mouse
  754                     .endif	; SUPPORT_MOUSE
  755                     
  756           0000      .if  (CDROM)
  778                     .endif	; (CDROM)
  779                     
  780           0001      .ifdef HUC
  781                         ; ----
  782                         ; Map the final stuff before executing main()
  783                         ; ----
  784                     
  785  00:E104  A9 02     	lda   #CONST_BANK+_bank_base	; map string constants bank
  786  00:E106  53 04     	tam   #2		; (ie. $4000-$5FFF)
  787  00:E108  A9 05     	lda   #_call_bank	; map call bank
  788  00:E10A  53 10     	tam   #4		; (ie. $8000-$9FFF)
  789                     	; ---
  790           0000      	.if   (CDROM)
  793                     	.endif
  794                     	; ---
  795  00:E10C  9C 8F 26  	stz   clock_hh		; clear clock
  796  00:E10F  9C 90 26  	stz   clock_mm
  797  00:E112  9C 91 26  	stz   clock_ss
  798  00:E115  9C 92 26  	stz   clock_tt
  799                     
  800           0000      .ifdef HAVE_INIT
  802                     .endif
  803                     
  804           0000      .ifdef LINK_malloc
  806                     .endif
  807                     
  808                     	map   _main
       00:E118  A9 04     	lda	#bank(_main)	; addressable memory
       00:E11A  53 20     	tam	#page(_main)
  809  00:E11C  20 00 A0  	jsr   _main 		; go!
  810  00:E11F  80 FE     	bra   *
  811                     
  812                     .else	; HUC
  815                     .endif	; HUC
  816                     
  817                     ; XXX: if LINK_malloc or HAVE_INIT are defined the interrupt handlers start
  818                     ; a couple of bytes later.  When an overlay is loaded the handlers are not
  819                     ; relocated, causing a crash.  This hack makes sure the handlers are in the
  820                     ; same place in all cases.
  821           0000       .if (CDROM)
  836                      .endif
  837                     
  838                     ; ----
  839                     ; system
  840                     ; ----
  841                     ; give back control to the Develo system
  842                     ; ----
  843                     
  844           0000      .if (DEVELO)
  881                     .endif	; (DEVELO)
  882                     
  883                     ; [INTERRUPT CODE]
  884                     
  885  00:E121            rts:
  886  00:E121  60        	rts
  887  00:E122            rti:
  888  00:E122  40        	rti
  889                     
  890                     ; ----
  891                     ; irq2
  892                     ; ----
  893                     ; IRQ2 interrupt handler
  894                     ; ----
  895                     
  896           0001      .if !(CDROM)
  897  00:E123            irq2:
  898  00:E123  8F F5 01  	bbs0 <irq_m,.user
  899  00:E126  40        	rti
  900  00:E127            .user:
  901  00:E127  6C 00 22  	jmp   [irq2_jmp]
  902                     .endif	; !(CDROM)
  903                     
  904                     ; ----
  905                     ; irq1
  906                     ; ----
  907                     ; VDC interrupt handler
  908                     ; ----
  909                     
  910           0001      .if !(CDROM)
  911                     
  912  00:E12A            irq1:
  913  00:E12A  9F F5 2D  	bbs1 <irq_m,user_irq1	; jump to the user irq1 vector if bit set
  914                     	; --
  915  00:E12D  48        	pha			; save registers
  916  00:E12E  DA        	phx
  917  00:E12F  5A        	phy
  918                     	; --
  919  00:E130  AD 00 00  	lda   video_reg		; get VDC status register
  920  00:E133  85 F6     	sta  <vdc_sr		; save a copy
  921                     
  922                         ; ----
  923                         ; vsync interrupt
  924                         ;
  925  00:E135            .vsync:
  926  00:E135  5F F6 10  	bbr5 <vdc_sr,.hsync
  927                     	; --
  928  00:E138  EE 41 22  	inc   irq_cnt		; increment IRQ counter
  929                     	; --
  930  00:E13B  03 05     	st0   #5		; update display control (bg/sp)
  931  00:E13D  A5 F3     	lda  <vdc_crl
  932  00:E13F  8D 02 00  	sta   video_data_l
  933                     	; --
  934  00:E142  DF F5 03  	bbs5 <irq_m,.hsync
  935                     	; --
  936  00:E145  20 5D E1  	jsr  vsync_hndl
  937                     	; --
  938                         ; ----
  939                         ; hsync interrupt
  940                         ;
  941  00:E148            .hsync:
  942  00:E148  2F F6 06  	bbr2 <vdc_sr,.exit
  943  00:E14B  FF F5 03  	bbs7 <irq_m,.exit
  944                     	; --
  945  00:E14E  20 C2 E1  	jsr  hsync_hndl
  946                     
  947                         ; ----
  948                         ; exit interrupt
  949                         ;
  950  00:E151            .exit:
  951  00:E151  A5 F7     	lda  <vdc_reg		; restore VDC register index
  952  00:E153  8D 00 00  	sta   video_reg
  953                     	; --
  954  00:E156  7A        	ply
  955  00:E157  FA        	plx
  956  00:E158  68        	pla
  957  00:E159  40        	rti
  958                     
  959                     .endif	; !(CDROM)
  960                     
  961                     
  962                         ; ----
  963                         ; user routine hooks
  964                         ;
  965  00:E15A            user_irq1:
  966  00:E15A  6C 02 22  	jmp   [irq1_jmp]
  967                     
  968                     
  969                     ; ----
  970                     ; vsync_hndl
  971                     ; ----
  972                     ; Handle VSYNC interrupts
  973                     ; ----
  974  00:E15D            vsync_hndl:
  975                     
  976           0001      .if  !(CDROM)
  977  00:E15D  AE 8E 26  	ldx   disp_cr		; check display state (on/off)
  978  00:E160  D0 09     	bne  .l1
  979  00:E162  29 3F     	and   #$3F		; disable display
  980  00:E164  03 05     	st0   #5		; update display control (bg/sp)
  981  00:E166  8D 02 00  	sta   video_data_l
  982  00:E169  80 06     	bra  .l2
  983                     	; --	
  984                     .else
  995                     .endif
  996                     
  997  00:E16B  20 26 E3  .l1:	jsr   xfer_palette	; transfer queued palettes
  998                     
  999  00:E16E  20 13 E2  	jsr   rcr_init		; init display list
 1000                     
 1001  00:E171  03 07     .l2:	st0   #7		; scrolling
 1002                     	stw   bg_x1,video_data
       00:E173  AD 0C 22  	lda	LOW_BYTE bg_x1
       00:E176  8D 02 00  	sta	LOW_BYTE video_data
       00:E179  AD 0D 22  	lda	HIGH_BYTE bg_x1
       00:E17C  8D 03 00  	sta	HIGH_BYTE video_data
 1003  00:E17F  03 08     	st0   #8
 1004                     	stw   bg_y1,video_data
       00:E181  AD 10 22  	lda	LOW_BYTE bg_y1
       00:E184  8D 02 00  	sta	LOW_BYTE video_data
       00:E187  AD 11 22  	lda	HIGH_BYTE bg_y1
       00:E18A  8D 03 00  	sta	HIGH_BYTE video_data
 1005                     
 1006                     	; --
 1007  00:E18D  AD 92 26  	lda   clock_tt		; keep track of time
 1008  00:E190  1A        	inc   A
 1009  00:E191  C9 3C     	cmp   #60
 1010  00:E193  D0 1C     	bne   .lcltt
 1011  00:E195  AD 91 26  	lda   clock_ss
 1012  00:E198  1A        	inc   A
 1013  00:E199  C9 3C     	cmp   #60
 1014  00:E19B  D0 10     	bne   .lclss
 1015  00:E19D  AD 90 26  	lda   clock_mm
 1016  00:E1A0  1A        	inc   A
 1017  00:E1A1  C9 3C     	cmp   #60
 1018  00:E1A3  D0 04     	bne   .lclmm
 1019  00:E1A5  EE 8F 26  	inc   clock_hh
 1020  00:E1A8  62        	cla
 1021  00:E1A9  8D 90 26  .lclmm:	sta   clock_mm
 1022  00:E1AC  62        	cla
 1023  00:E1AD  8D 91 26  .lclss:	sta   clock_ss
 1024  00:E1B0  62        	cla
 1025  00:E1B1  8D 92 26  .lcltt:	sta   clock_tt
 1026                     	; --
 1027                     
 1028           0000      .if  (CDROM)
 1034                     .endif
 1035                     
 1036                     	; invoke the sound driver's vsync irq code
 1037                     
 1038                     	__sound_vsync
 1039                     
 1040           0001      .ifdef SUPPORT_MOUSE
 1041  00:E1B4  AD 8E 29  	lda   msflag		; if mouse supported, and exists
 1042  00:E1B7  F0 05     	beq  .l3		; then read mouse instead of pad
 1043  00:E1B9  20 AF FA  	jsr   mousread
 1044  00:E1BC  80 03     	bra  .out
 1045                     .endif	; SUPPORT_MOUSE
 1046                     
 1047  00:E1BE  20 64 FB  .l3:	jsr   read_joypad	; else read joypad
 1048  00:E1C1  60        .out:	rts
 1049                     
 1050                     
 1051                     ; ----
 1052                     ; hsync_hndl
 1053                     ; ----
 1054                     ; Handle HSYNC interrupts
 1055                     ; ----
 1056                         ; ----
 1057                         ; hsync scrolling handler
 1058                         ;
 1059  00:E1C2            hsync_hndl:
 1060                     
 1061  00:E1C2  AC 2E 27  	ldy   s_idx
 1062  00:E1C5  10 13     	bpl  .r1
 1063                     	; --
 1064  00:E1C7  A5 F3     	lda  <vdc_crl
 1065  00:E1C9  29 3F     	and   #$3F
 1066  00:E1CB  85 F3     	sta  <vdc_crl
 1067  00:E1CD  9C 2E 27  	stz   s_idx
 1068  00:E1D0  AE 68 27  	ldx   s_list
 1069  00:E1D3  BD 57 27  	lda   s_top,X
 1070  00:E1D6  20 7B E2  	jsr   rcr5
 1071  00:E1D9  60        	rts
 1072                     	; --
 1073  00:E1DA  BE 68 27  .r1:	ldx   s_list,Y
 1074  00:E1DD  A5 F3     	lda  <vdc_crl
 1075  00:E1DF  29 3F     	and   #$3F
 1076  00:E1E1  1D 4F 27  	ora   s_cr,X
 1077  00:E1E4  85 F3     	sta  <vdc_crl
 1078                     	; --
 1079  00:E1E6  20 55 E2  	jsr   rcr_set
 1080                     	; --
 1081  00:E1E9  BD 57 27  	lda   s_top,X
 1082  00:E1EC  C9 FF     	cmp   #$FF
 1083  00:E1EE  F0 22     	beq  .out
 1084                     	; --
 1085  00:E1F0  03 07     	st0   #7
 1086  00:E1F2  BD 2F 27  	lda   s_xl,X
 1087  00:E1F5  BC 37 27  	ldy   s_xh,X
 1088  00:E1F8  8D 02 00  	sta   video_data_l
 1089  00:E1FB  8C 03 00  	sty   video_data_h
 1090  00:E1FE  03 08     	st0   #8
 1091  00:E200  BD 3F 27  	lda   s_yl,X
 1092  00:E203  BC 47 27  	ldy   s_yh,X
 1093                     	sub   #1
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:E206  38        	sec
       00:E207  E9 01     	sbc	#1
                          .endif
 1094  00:E209  B0 01     	bcs  .r2
 1095  00:E20B  88        	dey
 1096  00:E20C  8D 02 00  .r2:	sta   video_data_l
 1097  00:E20F  8C 03 00  	sty   video_data_h
 1098  00:E212  60        .out:	rts
 1099                     
 1100                         ; ----
 1101                         ; init display list
 1102                         ;
 1103  00:E213            rcr_init:
 1104                     	maplibfunc   build_disp_list
       00:E213  A8        	tay
       00:E214  43 20     	tma	#page(build_disp_list)
       00:E216  48        	pha
       00:E217  A9 01     	lda	#bank(build_disp_list)
       00:E219  53 20     	tam	#page(build_disp_list)
       00:E21B  98        	tya
       00:E21C  20 75 AB  	jsr	build_disp_list
       00:E21F  A8        	tay
       00:E220  68        	pla
       00:E221  53 20     	tam	#page(build_disp_list)
       00:E223  98        	tya
 1105  00:E224  B0 01     	bcs  .r3
 1106  00:E226  60        	rts
 1107                     	; --
 1108  00:E227  F7 F3     .r3:	smb   #7,<vdc_crl
 1109  00:E229  A9 FF     	lda   #$FF
 1110  00:E22B  8D 2E 27  	sta   s_idx
 1111  00:E22E  AE 68 27  	ldx   s_list
 1112  00:E231  BC 57 27  	ldy   s_top,X
 1113  00:E234  C0 FF     	cpy   #$FF
 1114  00:E236  D0 43     	bne   rcr5
 1115                     	; --
 1116  00:E238  BC 2F 27  	ldy   s_xl,X
 1117  00:E23B  8C 0C 22  	sty   bg_x1
 1118  00:E23E  BC 37 27  	ldy   s_xh,X
 1119  00:E241  8C 0D 22  	sty   bg_x1+1
 1120  00:E244  BC 3F 27  	ldy   s_yl,X
 1121  00:E247  8C 10 22  	sty   bg_y1
 1122  00:E24A  BC 47 27  	ldy   s_yh,X
 1123  00:E24D  8C 11 22  	sty   bg_y1+1
 1124  00:E250  9C 2E 27  	stz   s_idx
 1125  00:E253  80 26     	bra   rcr5
 1126                     
 1127                         ; ----
 1128                         ; program scanline interrupt
 1129                         ;
 1130  00:E255            rcr_set:
 1131  00:E255  C8        	iny
 1132  00:E256  8C 2E 27  	sty   s_idx
 1133  00:E259  B9 68 27  	lda   s_list,Y
 1134  00:E25C  A8        	tay
 1135  00:E25D  B9 57 27  	lda   s_top,Y
 1136  00:E260  CD 0C 27  	cmp   scr_height
 1137                     	bhs   rcr6
       00:E263  B0 26     	bcs	rcr6
 1138  00:E265  DD 60 27  	cmp   s_bottom,X
 1139                     	blo   rcr5
       00:E268  90 11     	bcc	rcr5
 1140                     	; --
 1141  00:E26A  BD 60 27  	lda   s_bottom,X
 1142  00:E26D  3A        rcr4:	dec   A
 1143  00:E26E  48        	pha
 1144  00:E26F  A9 F0     	lda   #$F0
 1145  00:E271  9D 60 27  	sta   s_bottom,X
 1146  00:E274  9E 4F 27  	stz   s_cr,X
 1147  00:E277  CE 2E 27  	dec   s_idx
 1148  00:E27A  68        	pla
 1149                     	; --
 1150  00:E27B  03 06     rcr5:	st0   #6		; set scanline counter
 1151                     	add   #64
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:E27D  18        	clc
       00:E27E  69 40     	adc	#64
                          .endif
 1152  00:E280  8D 02 00  	sta   video_data_l
 1153  00:E283  62        	cla
 1154  00:E284  69 00     	adc   #0
 1155  00:E286  8D 03 00  	sta   video_data_h
 1156  00:E289  80 0E     	bra   __rcr_on
 1157                     	;--
 1158  00:E28B  BD 60 27  rcr6:	lda   s_bottom,X
 1159  00:E28E  CD 0C 27  	cmp   scr_height
 1160                     	blo   rcr4
       00:E291  90 DA     	bcc	rcr4
 1161  00:E293  80 14     	bra   __rcr_off
 1162                     
 1163                     ; ----
 1164                     ; rcr_on
 1165                     ; ----
 1166                     ; enable scanline interrupt
 1167                     ; ----
 1168                     
 1169  00:E295            _rcr_on:
 1170  00:E295  A9 05      	lda   #5
 1171  00:E297  85 F7     	sta  <vdc_reg
 1172  00:E299            __rcr_on:
 1173  00:E299  03 05     	st0   #5
 1174  00:E29B  A5 F3     	lda  <vdc_crl
 1175  00:E29D  09 04     	ora   #$04
 1176  00:E29F  85 F3     	sta  <vdc_crl
 1177  00:E2A1  8D 02 00  	sta   video_data_l
 1178  00:E2A4  60        	rts
 1179                     
 1180                     ; ----
 1181                     ; rcr_off
 1182                     ; ----
 1183                     ; disable scanline interrupt
 1184                     ; ----
 1185                     
 1186  00:E2A5            _rcr_off:
 1187  00:E2A5  A9 05     	lda   #5
 1188  00:E2A7  85 F7     	sta  <vdc_reg
 1189  00:E2A9            __rcr_off:
 1190  00:E2A9  03 05     	st0   #5
 1191  00:E2AB  A5 F3     	lda  <vdc_crl
 1192  00:E2AD  29 FB     	and   #$FB
 1193  00:E2AF  85 F3     	sta  <vdc_crl
 1194  00:E2B1  8D 02 00  	sta   video_data_l
 1195  00:E2B4  60        	rts
 1196                     
 1197                     
 1198                     
 1199                     ; ----
 1200                     ; timer
 1201                     ; ----
 1202                     ; timer interrupt handler
 1203                     ; ----
 1204                     
 1205           0001      .if  !(CDROM)
 1206                     
 1207  00:E2B5  6C 04 22  timer_user:	jmp		[timer_jmp]
 1208                     
 1209  00:E2B8  AF F5 FA  timer:		bbs2		<irq_m,timer_user
 1210  00:E2BB  48        		pha
 1211  00:E2BC  DA        		phx
 1212  00:E2BD  5A        		phy
 1213                     
 1214  00:E2BE  8D 03 14  		sta		irq_status	; acknowledge interrupt
 1215                     
 1216                     		; invoke the sound driver's timer irq code
 1217                     
 1218                     		__sound_timer
 1219                     
 1220  00:E2C1  7A        		ply
 1221  00:E2C2  FA        		plx
 1222  00:E2C3  68        		pla
 1223  00:E2C4  40        		rti
 1224                     
 1225                     .endif	; !(CDROM)
 1226                     
 1227                     ; ----
 1228                     ; nmi
 1229                     ; ----
 1230                     ; NMI interrupt handler
 1231                     ; ----
 1232                     
 1233           0001      .if  !(CDROM)
 1234  00:E2C5            nmi:
 1235  00:E2C5  BF F5 01  	bbs3 <irq_m,.user
 1236  00:E2C8  40        	rti
 1237  00:E2C9            .user:
 1238  00:E2C9  6C 06 22  	jmp   [nmi_jmp]
 1239                     .endif	; !(CDROM)
 1240                     
 1241                     
 1242                     ; [DATA]
 1243                     
 1244                     ; ----
 1245                     ; font
 1246                     ; ----
 1247                     
 1248           0001      .ifdef HUC
 1249  00:E2CC            font_table:
 1250  00:E2CC  00 60     	 .dw font_1
 1251  00:E2CE  00 63     	 .dw font_2
 1252  00:E2D0  00 60     	 .dw font_1
 1253  00:E2D2  00 60     	 .dw font_1
 1254                     .endif	; HUC
 1255                     
 1256                     
 1257                     ; [LIBRARY]
 1258                     
 1259                     ; ----
 1260                     ; standard library
 1261                     ; ----
 1262                     
#[3]   library.asm
 1263                     .include "library.asm"
    1                     ;
    2                     ; LIBRARY.ASM  -  MagicKit Standard Library
    3                     ;
    4                     ;
    5                     
    6                     ; IMPORTANT NOTE:
    7                     ; ----
    8                     ; almost all the library functions have been changed to automatically
    9                     ; handle bank mapping (you don't have to map data yourself anymore),
   10                     ; the change will be transparent to you if you were using only library
   11                     ; macros to call functions, but you will have to update your code
   12                     ; in case you were directly calling those functions!
   13                     
   14                     
   15                     ; ----
   16                     ; map_data
   17                     ; ----
   18                     ; map data in page 3-4 ($6000-$9FFF)
   19                     ; ----
   20                     ; IN :	_BL = data bank
   21                     ;	_SI = data address
   22                     ; ----
   23                     ; OUT:	_BX = old banks
   24                     ;	_SI = remapped data address
   25                     ; ----
   26                     
   27  00:E2D4            map_data:
   28  00:E2D4  A6 FA     	ldx	<__bl
   29                     
   30                     	; ----
   31                     	; save current bank mapping
   32                     	;
   33  00:E2D6  43 08     	tma	#3
   34  00:E2D8  85 FA     	sta	<__bl
   35  00:E2DA  43 10     	tma	#4
   36  00:E2DC  85 FB     	sta	<__bh
   37                     	; --
   38  00:E2DE  E0 FE     	cpx	#$FE
   39  00:E2E0  D0 03     	bne	.l1
   40                     	; --
   41  00:E2E2  86 EC     	stx	<__bp
   42  00:E2E4  60        	rts
   43                     
   44                     	; ----
   45                     	; map new bank
   46                     	;
   47  00:E2E5  64 EC     .l1:	stz	<__bp
   48                     	; --
   49  00:E2E7  8A        	txa
   50  00:E2E8  53 08     	tam	#3
   51  00:E2EA  1A        	inc	A
   52  00:E2EB  53 10     	tam	#4
   53                     
   54                     	; ----
   55                     	; remap data address to page 3
   56                     	;
   57  00:E2ED  A5 EF     	lda	<__si+1
   58  00:E2EF  29 1F     	and	#$1F
   59  00:E2F1  09 60     	ora	#$60
   60  00:E2F3  85 EF     	sta	<__si+1
   61  00:E2F5  60        	rts
   62                     
   63                     
   64                     ; ----
   65                     ; unmap_data
   66                     ; ----
   67                     ; IN :	_BX = old banks
   68                     ; ----
   69                     
   70  00:E2F6            unmap_data:
   71                     
   72  00:E2F6  A5 FA     	lda	<__bl
   73  00:E2F8  53 08     	tam	#3
   74  00:E2FA  A5 FB     	lda	<__bh
   75  00:E2FC  53 10     	tam	#4
   76  00:E2FE  60        	rts
   77                     
   78                     ; ----
   79                     ; remap_data
   80                     ; ----
   81                     
   82  00:E2FF            remap_data:
   83  00:E2FF  A5 EC     	lda	<__bp
   84  00:E301  D0 10     	bne	.l1
   85  00:E303  A5 EF     	lda	<__si+1
   86  00:E305  10 0C     	bpl	.l1
   87                     	sub	#$20
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:E307  38        	sec
       00:E308  E9 20     	sbc	#$20
                          .endif
   88  00:E30A  85 EF     	sta	<__si+1
   89  00:E30C  43 10     	tma	#4
   90  00:E30E  53 08     	tam	#3
   91  00:E310  1A        	inc	A
   92  00:E311  53 10     	tam	#4
   93  00:E313            .l1:
   94  00:E313  60        	rts
   95                     
   96                     
   97                     ; ----
   98                     ; load_palette
   99                     ; ----
  100                     ; initialize one or more sub-palette
  101                     ; ----
  102                     ; IN :	_AL = index of the first sub-palette (0-31)
  103                     ;	_BL = data bank
  104                     ;	_SI = address of data
  105                     ;	_CL = number of sub-palette to copy
  106                     ; ----
  107                     
  108           0001      .ifdef HUC
  109  00:E314            _load_palette.3:
  110                     .endif
  111  00:E314            load_palette:
  112                     	maplibfunc	lib2_load_palette
       00:E314  A8        	tay
       00:E315  43 20     	tma	#page(lib2_load_palette)
       00:E317  48        	pha
       00:E318  A9 01     	lda	#bank(lib2_load_palette)
       00:E31A  53 20     	tam	#page(lib2_load_palette)
       00:E31C  98        	tya
       00:E31D  20 00 A6  	jsr	lib2_load_palette
       00:E320  A8        	tay
       00:E321  68        	pla
       00:E322  53 20     	tam	#page(lib2_load_palette)
       00:E324  98        	tya
  113  00:E325  60        	rts
  114                     
  115  00:E326            xfer_palette:
  116                     	maplibfunc	lib2_xfer_palette
       00:E326  A8        	tay
       00:E327  43 20     	tma	#page(lib2_xfer_palette)
       00:E329  48        	pha
       00:E32A  A9 01     	lda	#bank(lib2_xfer_palette)
       00:E32C  53 20     	tam	#page(lib2_xfer_palette)
       00:E32E  98        	tya
       00:E32F  20 2D A6  	jsr	lib2_xfer_palette
       00:E332  A8        	tay
       00:E333  68        	pla
       00:E334  53 20     	tam	#page(lib2_xfer_palette)
       00:E336  98        	tya
  117  00:E337  60        	rts
  118                     
  119           0001      	.bank	LIB2_BANK
  120  01:A600            lib2_load_palette:
  121  01:A600  AC B2 26  	ldy	color_queue_w
  122                     
  123  01:A603  A5 EE     	lda	<__si + 0
  124  01:A605  99 CB 26  	sta	color_addr_l,y
  125  01:A608  A5 EF     	lda	<__si + 1
  126  01:A60A  29 1F     	and	#$1F
  127  01:A60C  09 60     	ora	#$60
  128  01:A60E  99 D3 26  	sta	color_addr_h,y
  129  01:A611  A5 FA     	lda	<__bl
  130  01:A613  99 C3 26  	sta	color_bank,y
  131  01:A616  A5 F8     	lda	<__al
  132  01:A618  99 B3 26  	sta	color_index,y
  133  01:A61B  A5 FC     	lda	<__cl
  134  01:A61D  99 BB 26  	sta	color_count,y
  135                     
  136  01:A620  98        	tya
  137  01:A621  1A        	inc	a
  138  01:A622  29 07     	and	#7
  139  01:A624  CD B1 26  .wait:	cmp	color_queue_r
  140  01:A627  F0 FB     	beq	.wait
  141  01:A629  8D B2 26  	sta	color_queue_w
  142  01:A62C  60        	rts
  143                     
  144  01:A62D            lib2_xfer_palette:
  145  01:A62D  AC B1 26  	ldy	color_queue_r
  146  01:A630  CC B2 26  	cpy	color_queue_w
  147  01:A633  F0 5A     	beq	.done
  148                     
  149  01:A635  43 08     	tma3
  150  01:A637  48        	pha
  151  01:A638  43 10     	tma4
  152  01:A63A  48        	pha
  153                     
  154  01:A63B  73 90 A6  	tii	.func, color_tia, 8
       01:A63E  DB 26 08  
       01:A641  00        
  155                     
  156  01:A642  B9 B3 26  .next:	lda	color_index,y
  157  01:A645  0A        	asl	a
  158  01:A646  0A        	asl	a
  159  01:A647  0A        	asl	a
  160  01:A648  0A        	asl	a
  161  01:A649  8D 02 04  	sta	color_reg_l
  162  01:A64C  62        	cla
  163  01:A64D  2A        	rol	a
  164  01:A64E  8D 03 04  	sta	color_reg_h
  165                     
  166  01:A651  B9 C3 26  	lda	color_bank,y
  167  01:A654  53 08     	tam3
  168  01:A656  1A        	inc	a
  169  01:A657  53 10     	tam4
  170  01:A659  B9 CB 26  	lda	color_addr_l,y
  171  01:A65C  8D DC 26  	sta	color_tia + 1
  172  01:A65F  B9 D3 26  	lda	color_addr_h,y
  173  01:A662  8D DD 26  	sta	color_tia + 2
  174                     
  175  01:A665  BE BB 26  	ldx	color_count,y
  176  01:A668  20 DB 26  .loop:	jsr	color_tia
  177  01:A66B  18        	clc
  178  01:A66C  A9 20     	lda	#32
  179  01:A66E  6D DC 26  	adc	color_tia + 1
  180  01:A671  8D DC 26  	sta	color_tia + 1
  181  01:A674  90 03     	bcc	.skip
  182  01:A676  EE DD 26  	inc	color_tia + 2
  183  01:A679  CA        .skip:	dex
  184  01:A67A  D0 EC     	bne	.loop
  185                     
  186  01:A67C  C8        	iny
  187  01:A67D  98        	tya
  188  01:A67E  29 07     	and	#7
  189  01:A680  A8        	tay
  190                     
  191  01:A681  CC B2 26  	cpy	color_queue_w
  192  01:A684  D0 BC     	bne	.next
  193  01:A686  8C B1 26  	sty	color_queue_r
  194                     
  195  01:A689  68        	pla
  196  01:A68A  53 10     	tam4
  197  01:A68C  68        	pla
  198  01:A68D  53 08     	tam3
  199                     
  200  01:A68F  60        .done:	rts
  201                     
  202  01:A690  E3 00 00  .func:	tia	0, color_data, 32
       01:A693  04 04 20  
       01:A696  00        
  203  01:A697  60        	rts
  204                     
  205           0000      	.bank	LIB1_BANK
  206                     
  207                     ; ----
  208                     ; load_bat
  209                     ; ----
  210                     ; transfer a BAT in VRAM
  211                     ; ----
  212                     ; IN :	_DI = VRAM base address
  213                     ;	_BL = BAT bank
  214                     ;	_SI = BAT memory location
  215                     ;	_CL = nb of column to copy
  216                     ;	_CH = nb of row
  217                     ; ----
  218                     
  219           0001      .ifdef HUC
  220  00:E338            _load_bat.4:
  221                     .endif
  222  00:E338            load_bat:
  223                     	maplibfunc	lib2_load_bat
       00:E338  A8        	tay
       00:E339  43 20     	tma	#page(lib2_load_bat)
       00:E33B  48        	pha
       00:E33C  A9 01     	lda	#bank(lib2_load_bat)
       00:E33E  53 20     	tam	#page(lib2_load_bat)
       00:E340  98        	tya
       00:E341  20 98 A6  	jsr	lib2_load_bat
       00:E344  A8        	tay
       00:E345  68        	pla
       00:E346  53 20     	tam	#page(lib2_load_bat)
       00:E348  98        	tya
  224  00:E349  60        	rts
  225                     
  226           0001      	.bank	LIB2_BANK
  227                     
  228  01:A698            lib2_load_bat:
  229                     
  230                     	; ----
  231                     	; map data
  232                     	;
  233  01:A698  20 D4 E2  	jsr	map_data
  234                     
  235                     	; ----
  236                     	; copy BAT
  237                     	;
  238  01:A69B  C2        	cly
  239                     	; --
  240  01:A69C  20 02 E4  .l1:	jsr	set_write
  241  01:A69F  A6 FC     	ldx	<__cl
  242                     	; --
  243  01:A6A1  B1 EE     .l2:	lda	[__si],Y
  244  01:A6A3  8D 02 00  	sta	video_data_l
  245  01:A6A6  C8        	iny
  246  01:A6A7  B1 EE     	lda	[__si],Y
  247  01:A6A9  8D 03 00  	sta	video_data_h
  248  01:A6AC  C8        	iny
  249  01:A6AD  D0 02     	bne	.l3
  250  01:A6AF  E6 EF     	inc	<__si+1
  251  01:A6B1  CA        .l3:	dex
  252  01:A6B2  D0 ED     	bne	.l2
  253                     	; --
  254  01:A6B4  20 FF E2  	jsr	remap_data
  255                     	; --
  256                     	addw	bat_width,<__di
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:A6B7  18        	clc
       01:A6B8  A5 F0     	lda	LOW_BYTE <__di
       01:A6BA  6D 06 27  	adc	LOW_BYTE bat_width
       01:A6BD  85 F0     	sta	LOW_BYTE <__di
       01:A6BF  A5 F1     	lda	HIGH_BYTE <__di
       01:A6C1  6D 07 27  	adc	HIGH_BYTE bat_width
       01:A6C4  85 F1     	sta	HIGH_BYTE <__di
                          .endif
  257  01:A6C6  C6 FD     	dec	<__ch
  258  01:A6C8  D0 D2     	bne	.l1
  259                     
  260                     	; ----
  261                     	; unmap data
  262                     	;
  263  01:A6CA  4C F6 E2  	jmp	unmap_data
  264                     
  265           0000      	.bank	LIB1_BANK
  266                     
  267                     ; ----
  268                     ; load_map_8/16
  269                     ; ----
  270                     ; transfer a tiled map in VRAM
  271                     ; ----
  272                     ; IN :	_AL = x screen coordinate (tile unit)
  273                     ;	_AH = y screen coordinate
  274                     ;	_CL = x start coordinate in the map
  275                     ;	_CH = y start coordinate
  276                     ;	_DL = nb of column to copy
  277                     ;	_DH = nb of row
  278                     ; ----
  279                     
  280           26E3      	.bss
  281  --:26E3            mapbank		.ds 1
  282  --:26E4            mapaddr		.ds 2
  283  --:26E6            mapwidth	.ds 2
  284  --:26E8            mapheight	.ds 2
  285  --:26EA            maptiletype	.ds 1
  286  --:26EB            maptilebank	.ds 1
  287  --:26EC            maptileaddr	.ds 2
  288  --:26EE            maptilebase	.ds 2
  289  --:26F0            mapnbtile	.ds 2
  290  --:26F2            mapctablebank	.ds 1
  291  --:26F3            mapctable	.ds 2
  292  --:26F5            mapwrap		.ds 1
  293  --:26F6            mapbat_ptr	.ds 2
  294  --:26F8            mapbat_top_base .ds 2
  295  --:26FA            mapbat_top	.ds 1
  296  --:26FB            mapbat_bottom	.ds 1
  297  --:26FC            mapbat_x	.ds 2
  298           E34A      	.code
  299  00:E34A            load_map:
  300  00:E34A  AD EA 26  	lda	maptiletype
  301  00:E34D  C9 08     	cmp	#8
  302  00:E34F  F0 12     	beq	.l1
  303                     	; --
  304                     	maplibfunc	lib2_load_map_16
       00:E351  A8        	tay
       00:E352  43 20     	tma	#page(lib2_load_map_16)
       00:E354  48        	pha
       00:E355  A9 01     	lda	#bank(lib2_load_map_16)
       00:E357  53 20     	tam	#page(lib2_load_map_16)
       00:E359  98        	tya
       00:E35A  20 CD A6  	jsr	lib2_load_map_16
       00:E35D  A8        	tay
       00:E35E  68        	pla
       00:E35F  53 20     	tam	#page(lib2_load_map_16)
       00:E361  98        	tya
  305  00:E362  60        	rts
  306                     .l1:	maplibfunc	lib2_load_map_8
       00:E363  A8        	tay
       00:E364  43 20     	tma	#page(lib2_load_map_8)
       00:E366  48        	pha
       00:E367  A9 01     	lda	#bank(lib2_load_map_8)
       00:E369  53 20     	tam	#page(lib2_load_map_8)
       00:E36B  98        	tya
       00:E36C  20 CE A7  	jsr	lib2_load_map_8
       00:E36F  A8        	tay
       00:E370  68        	pla
       00:E371  53 20     	tam	#page(lib2_load_map_8)
       00:E373  98        	tya
  307  00:E374  60        	rts
  308                     
  309           0001      	.bank	LIB2_BANK
  310                     
  311  01:A6CD            lib2_load_map_16:
  312                     
  313                     	; ----
  314                     	; save bank mapping
  315                     	;
  316  01:A6CD  43 04     	tma	#2
  317  01:A6CF  48        	pha
  318  01:A6D0  43 08     	tma	#3
  319  01:A6D2  48        	pha
  320  01:A6D3  43 10     	tma	#4
  321  01:A6D5  48        	pha
  322                     
  323                     	; ----
  324                     	; init
  325                     	;
  326  01:A6D6  20 61 A8  	jsr	load_map_init
  327  01:A6D9  A5 FD     	lda	<__ch
  328  01:A6DB  8D FD 26  	sta	mapbat_x+1
  329                     
  330                     	; ----
  331                     	; vertical loop
  332                     	;
  333  01:A6DE  A4 F9     .l1:	ldy	<__ah
  334  01:A6E0  A5 FE     	lda	<__dl
  335  01:A6E2  85 F8     	sta	<__al
  336  01:A6E4  AD FD 26  	lda	mapbat_x+1
  337  01:A6E7  8D FC 26  	sta	mapbat_x
  338  01:A6EA  80 43     	bra	.l5
  339                     
  340                     	; ----
  341                     	; horizontal loop
  342                     	;
  343  01:A6EC  AD FC 26  .l2:	lda	mapbat_x	; bat wrapping
  344                     	add	#2
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A6EF  18        	clc
       01:A6F0  69 02     	adc	#2
                          .endif
  345  01:A6F2  2D 09 27  	and	bat_hmask
  346  01:A6F5  8D FC 26  	sta	mapbat_x
  347  01:A6F8  D0 0B     	bne	.l3
  348                     	; --
  349  01:A6FA  AD 09 27  	lda	bat_hmask
  350  01:A6FD  49 FF     	eor	#$ff
  351  01:A6FF  25 F0     	and	<__di
  352  01:A701  85 F0     	sta	<__di
  353  01:A703  80 0C     	bra	.l4
  354  01:A705            .l3:
  355                     	incw	<__di
       01:A705  E6 F0     	inc	<__di		; value at stated memory
       01:A707  D0 02     	bne	.x_00033		; location
       01:A709  E6 F1     	inc	<__di+1
       01:A70B            .x_00033:
  356                     	incw	<__di
       01:A70B  E6 F0     	inc	<__di		; value at stated memory
       01:A70D  D0 02     	bne	.x_00034		; location
       01:A70F  E6 F1     	inc	<__di+1
       01:A711            .x_00034:
  357  01:A711            .l4:
  358  01:A711  C8        	iny
  359                     	; --
  360  01:A712  CC E6 26  	cpy	mapwidth		; horizontal map wrapping
  361  01:A715  D0 18     	bne	.l5
  362  01:A717  C2        	cly
  363  01:A718  AE F5 26  	ldx	mapwrap
  364  01:A71B  D0 12     	bne	.l5
  365  01:A71D  AC E6 26  	ldy	mapwidth
  366  01:A720  AD EE 26  	lda	maptilebase
  367  01:A723  85 FC     	sta	<__cl
  368  01:A725  AD EF 26  	lda	maptilebase+1
  369  01:A728  12 EC     	ora	[__bp]
  370  01:A72A  85 FD     	sta	<__ch
  371  01:A72C  88        	dey
  372  01:A72D  80 1C     	bra	.l6
  373  01:A72F            .l5:
  374  01:A72F  B1 EE     	lda	[__si],Y		; get tile index
  375  01:A731  AA        	tax			; calculate BAT value (tile + palette)
  376  01:A732  02        	sxy
  377  01:A733  64 FD     	stz	<__ch
  378  01:A735  0A        	asl	A
  379  01:A736  26 FD     	rol	<__ch
  380  01:A738  0A        	asl	A
  381  01:A739  26 FD     	rol	<__ch
  382                     	add	maptilebase
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A73B  18        	clc
       01:A73C  6D EE 26  	adc	maptilebase
                          .endif
  383  01:A73F  85 FC     	sta	<__cl
  384  01:A741  A5 FD     	lda	<__ch
  385  01:A743  6D EF 26  	adc	maptilebase+1
  386  01:A746  71 EC     	adc	[__bp],Y
  387  01:A748  85 FD     	sta	<__ch
  388  01:A74A  02        	sxy
  389  01:A74B            .l6:
  390                     	vreg	#0		; copy tile
       01:A74B  A9 00     	lda	#0		
       01:A74D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A74F  03 00     	st0	#0		
                          .else
                          .endif
  391                     	stw	<__di,video_data
       01:A751  A5 F0     	lda	LOW_BYTE <__di
       01:A753  8D 02 00  	sta	LOW_BYTE video_data
       01:A756  A5 F1     	lda	HIGH_BYTE <__di
       01:A758  8D 03 00  	sta	HIGH_BYTE video_data
  392                     	vreg	#2
       01:A75B  A9 02     	lda	#2
       01:A75D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A75F  03 02     	st0	#2
                          .else
                          .endif
  393                     	stw	<__cx,video_data
       01:A761  A5 FC     	lda	LOW_BYTE <__cx
       01:A763  8D 02 00  	sta	LOW_BYTE video_data
       01:A766  A5 FD     	lda	HIGH_BYTE <__cx
       01:A768  8D 03 00  	sta	HIGH_BYTE video_data
  394                     	incw	<__cx
       01:A76B  E6 FC     	inc	<__cx		; value at stated memory
       01:A76D  D0 02     	bne	.x_00040		; location
       01:A76F  E6 FD     	inc	<__cx+1
       01:A771            .x_00040:
  395                     	stw	<__cx,video_data
       01:A771  A5 FC     	lda	LOW_BYTE <__cx
       01:A773  8D 02 00  	sta	LOW_BYTE video_data
       01:A776  A5 FD     	lda	HIGH_BYTE <__cx
       01:A778  8D 03 00  	sta	HIGH_BYTE video_data
  396                     	incw	<__cx
       01:A77B  E6 FC     	inc	<__cx		; value at stated memory
       01:A77D  D0 02     	bne	.x_00042		; location
       01:A77F  E6 FD     	inc	<__cx+1
       01:A781            .x_00042:
  397                     	vreg	#0
       01:A781  A9 00     	lda	#0
       01:A783  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A785  03 00     	st0	#0
                          .else
                          .endif
  398                     	addw	bat_width,<__di,video_data
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:A787  18        	clc
       01:A788  A5 F0     	lda	LOW_BYTE <__di
       01:A78A  6D 06 27  	adc	LOW_BYTE bat_width
       01:A78D  8D 02 00  	sta	LOW_BYTE video_data
       01:A790  A5 F1     	lda	HIGH_BYTE <__di
       01:A792  6D 07 27  	adc	HIGH_BYTE bat_width
       01:A795  8D 03 00  	sta	HIGH_BYTE video_data
                          .else
                          .endif
  399                     	vreg	#2
       01:A798  A9 02     	lda	#2
       01:A79A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A79C  03 02     	st0	#2
                          .else
                          .endif
  400                     	stw	<__cx,video_data
       01:A79E  A5 FC     	lda	LOW_BYTE <__cx
       01:A7A0  8D 02 00  	sta	LOW_BYTE video_data
       01:A7A3  A5 FD     	lda	HIGH_BYTE <__cx
       01:A7A5  8D 03 00  	sta	HIGH_BYTE video_data
  401                     	incw	<__cx
       01:A7A8  E6 FC     	inc	<__cx		; value at stated memory
       01:A7AA  D0 02     	bne	.x_00047		; location
       01:A7AC  E6 FD     	inc	<__cx+1
       01:A7AE            .x_00047:
  402                     	stw	<__cx,video_data
       01:A7AE  A5 FC     	lda	LOW_BYTE <__cx
       01:A7B0  8D 02 00  	sta	LOW_BYTE video_data
       01:A7B3  A5 FD     	lda	HIGH_BYTE <__cx
       01:A7B5  8D 03 00  	sta	HIGH_BYTE video_data
  403                     
  404  01:A7B8  C6 F8     	dec	<__al		; next tile
  405                     	lbne	.l2
       01:A7BA  F0 03     	beq	.x_00049
       01:A7BC  4C EC A6  	jmp	.l2
       01:A7BF            .x_00049
  406                     
  407                     	; ----
  408                     	; next line
  409                     	;
  410  01:A7BF  A2 02     	ldx	#2
  411  01:A7C1  20 EE A8  	jsr	load_map_next_line
  412  01:A7C4  C6 FF     	dec	<__dh
  413                     	lbne	.l1
       01:A7C6  F0 03     	beq	.x_00050
       01:A7C8  4C DE A6  	jmp	.l1
       01:A7CB            .x_00050
  414                     
  415                     	; ----
  416                     	; restore bank mapping
  417                     	;
  418  01:A7CB  4C 57 A8  	jmp	load_map_exit
  419                     
  420  01:A7CE            lib2_load_map_8:
  421                     
  422                     	; ----
  423                     	; save bank mapping
  424                     	;
  425  01:A7CE  43 04     	tma	#2
  426  01:A7D0  48        	pha
  427  01:A7D1  43 08     	tma	#3
  428  01:A7D3  48        	pha
  429  01:A7D4  43 10     	tma	#4
  430  01:A7D6  48        	pha
  431                     
  432                     	; ----
  433                     	; init
  434                     	;
  435  01:A7D7  20 61 A8  	jsr	load_map_init
  436  01:A7DA  80 05     	bra	.l2
  437                     
  438                     	; ----
  439                     	; vertical loop
  440                     	;
  441  01:A7DC  A2 01     .l1:	ldx	#1
  442  01:A7DE  20 EE A8  	jsr	load_map_next_line
  443                     	; --
  444  01:A7E1  A4 F9     .l2:	ldy	<__ah
  445  01:A7E3  A5 FE     	lda	<__dl
  446  01:A7E5  85 F8     	sta	<__al
  447  01:A7E7  A5 FD     	lda	<__ch
  448  01:A7E9  85 FC     	sta	<__cl
  449                     	vreg	#0		; set vram write ptr
       01:A7EB  A9 00     	lda	#0		
       01:A7ED  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A7EF  03 00     	st0	#0		
                          .else
                          .endif
  450                     	stw	<__di,video_data
       01:A7F1  A5 F0     	lda	LOW_BYTE <__di
       01:A7F3  8D 02 00  	sta	LOW_BYTE video_data
       01:A7F6  A5 F1     	lda	HIGH_BYTE <__di
       01:A7F8  8D 03 00  	sta	HIGH_BYTE video_data
  451                     	vreg	#2
       01:A7FB  A9 02     	lda	#2
       01:A7FD  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A7FF  03 02     	st0	#2
                          .else
                          .endif
  452  01:A801  80 38     	bra	.l5
  453                     
  454                     	; ----
  455                     	; horizontal loop
  456                     	;
  457  01:A803  A5 FC     .l3:	lda	<__cl		; bat wrapping
  458  01:A805  1A        	inc	A
  459  01:A806  2D 09 27  	and	bat_hmask
  460  01:A809  85 FC     	sta	<__cl
  461  01:A80B  D0 1B     	bne	.l4
  462                     	; --
  463                     	vreg	#0
       01:A80D  A9 00     	lda	#0
       01:A80F  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A811  03 00     	st0	#0
                          .else
                          .endif
  464  01:A813  AD 09 27  	lda	bat_hmask
  465  01:A816  49 FF     	eor	#$ff
  466  01:A818  25 F0     	and	<__di
  467  01:A81A  8D 02 00  	sta	video_data_l
  468  01:A81D  A5 F1     	lda	<__di+1
  469  01:A81F  8D 03 00  	sta	video_data_h
  470                     	vreg	#2
       01:A822  A9 02     	lda	#2
       01:A824  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A826  03 02     	st0	#2
                          .else
                          .endif
  471  01:A828            .l4:
  472  01:A828  C8        	iny			; next tile
  473                     	; --
  474  01:A829  CC E6 26  	cpy	mapwidth		; map wrapping
  475  01:A82C  D0 0D     	bne	.l5
  476                     	; --
  477  01:A82E  C2        	cly
  478  01:A82F  AD F5 26  	lda	mapwrap
  479  01:A832  D0 07     	bne	.l5
  480  01:A834  AC E6 26  	ldy	mapwidth
  481  01:A837  88        	dey
  482  01:A838  62        	cla
  483  01:A839  80 02     	bra	.l6
  484  01:A83B            .l5:
  485  01:A83B  B1 EE     	lda	[__si],Y		; get tile index
  486  01:A83D  AA        .l6:	tax			; calculate BAT value (tile + palette)
  487  01:A83E  02        	sxy
  488                     	add	maptilebase
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A83F  18        	clc
       01:A840  6D EE 26  	adc	maptilebase
                          .endif
  489  01:A843  8D 02 00  	sta	video_data_l
  490  01:A846  AD EF 26  	lda	maptilebase+1
  491  01:A849  71 EC     	adc	[__bp],Y
  492  01:A84B  8D 03 00  	sta	video_data_h
  493  01:A84E  02        	sxy
  494                     
  495  01:A84F  C6 F8     	dec	<__al
  496  01:A851  D0 B0     	bne	.l3
  497                     
  498                     	; ----
  499                     	; next line
  500                     	;
  501  01:A853  C6 FF     	dec	<__dh
  502  01:A855  D0 85     	bne	.l1
  503                     
  504                     	; ----
  505                     	; restore bank mapping
  506                     	;
  507  01:A857            load_map_exit:
  508  01:A857  68        	pla
  509  01:A858  53 10     	tam	#4
  510  01:A85A  68        	pla
  511  01:A85B  53 08     	tam	#3
  512  01:A85D  68        	pla
  513  01:A85E  53 04     	tam	#2
  514  01:A860  60        	rts
  515                     
  516                     
  517                     ; ----
  518                     ; load_map_init
  519                     ; ----
  520                     ; load_map sub routine
  521                     ; ----
  522                     ; OUT:	_DI = BAT address
  523                     ;	_SI = map address
  524                     ;	_BP = palette index table ptr
  525                     ;	_AH = map X pos
  526                     ;	_BH = map Y pos
  527                     ;	_CH = BAT X pos
  528                     ;	_BL = BAT Y pos
  529                     ; ----
  530                     
  531  01:A861            load_map_init:
  532                     
  533                     	; ----
  534                     	; calculate vram address
  535                     	;
  536  01:A861  A6 F8     	ldx	<__al
  537  01:A863  A5 F9     	lda	<__ah
  538  01:A865  AC EA 26  	ldy	maptiletype
  539  01:A868  C0 08     	cpy	#8
  540  01:A86A  F0 04     	beq	.l1
  541  01:A86C  0A        	asl	A
  542  01:A86D  22        	sax
  543  01:A86E  0A        	asl	A
  544  01:A86F  22        	sax
  545  01:A870  DA        .l1:	phx
  546  01:A871  48        	pha
  547  01:A872  20 19 E4  	jsr	calc_vram_addr
  548                     	stw	<__di,mapbat_ptr
       01:A875  A5 F0     	lda	LOW_BYTE <__di
       01:A877  8D F6 26  	sta	LOW_BYTE mapbat_ptr
       01:A87A  A5 F1     	lda	HIGH_BYTE <__di
       01:A87C  8D F7 26  	sta	HIGH_BYTE mapbat_ptr
  549                     
  550                     	; ----
  551                     	; calculate map address
  552                     	;
  553                     	stb	mapaddr,<__si
       01:A87F  AD E4 26  	lda	mapaddr
       01:A882  85 EE     	sta	<__si
  554  01:A884  AD E5 26  	lda	mapaddr+1
  555  01:A887  29 1F     	and	#$1F
  556  01:A889  85 EF     	sta	<__si+1
  557                     	; --
  558  01:A88B  A6 FC     	ldx	<__cl
  559  01:A88D  86 F9     	stx	<__ah
  560  01:A88F  A4 FD     	ldy	<__ch
  561  01:A891  84 FB     	sty	<__bh
  562                     	; --
  563  01:A893  AD E7 26  	lda	mapwidth+1
  564  01:A896  F0 08     	beq	.l2
  565  01:A898  98        	tya
  566                     	add	<__si+1
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A899  18        	clc
       01:A89A  65 EF     	adc	<__si+1
                          .endif
  567  01:A89C  85 EF     	sta	<__si+1
  568  01:A89E  80 17     	bra	.l3
  569                     	; --
  570  01:A8A0  84 F8     .l2:	sty	<__al
  571  01:A8A2  AD E6 26  	lda	mapwidth
  572  01:A8A5  85 FA     	sta	<__bl
  573  01:A8A7  20 1E E6  	jsr	mulu8
  574                     	addw	<__cx,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:A8AA  18        	clc
       01:A8AB  A5 EE     	lda	LOW_BYTE <__si
       01:A8AD  65 FC     	adc	LOW_BYTE <__cx
       01:A8AF  85 EE     	sta	LOW_BYTE <__si
       01:A8B1  A5 EF     	lda	HIGH_BYTE <__si
       01:A8B3  65 FD     	adc	HIGH_BYTE <__cx
       01:A8B5  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  575                     
  576                     	; ----
  577                     	; calculate map bank
  578                     	;
  579  01:A8B7  2A        .l3:	rol	A
  580  01:A8B8  2A        	rol	A
  581  01:A8B9  2A        	rol	A
  582  01:A8BA  2A        	rol	A
  583  01:A8BB  29 0F     	and	#$0F
  584                     	add	mapbank
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A8BD  18        	clc
       01:A8BE  6D E3 26  	adc	mapbank
                          .endif
  585                     
  586                     	; ----
  587                     	; map data
  588                     	;
  589  01:A8C1  53 08     	tam	#3
  590  01:A8C3  1A        	inc	A
  591  01:A8C4  53 10     	tam	#4
  592  01:A8C6  AD F2 26  	lda	mapctablebank
  593  01:A8C9  53 04     	tam	#2
  594                     
  595                     	; ----
  596                     	; adjust data addresses
  597                     	;
  598  01:A8CB  A5 EF     	lda	<__si+1		; tile ptr
  599  01:A8CD  29 1F     	and	#$1F
  600  01:A8CF  09 60     	ora	#$60
  601  01:A8D1  85 EF     	sta	<__si+1
  602                     	; --
  603                     	stb	mapctable,<__bp	; color table ptr
       01:A8D3  AD F3 26  	lda	mapctable
       01:A8D6  85 EC     	sta	<__bp	
  604  01:A8D8  AD F4 26  	lda	mapctable+1
  605  01:A8DB  29 1F     	and	#$1F
  606  01:A8DD  09 40     	ora	#$40
  607  01:A8DF  85 ED     	sta	<__bp+1
  608                     
  609                     	; ----
  610                     	; bat pos
  611                     	;
  612  01:A8E1  68        	pla
  613  01:A8E2  2D 0A 27  	and	bat_vmask
  614  01:A8E5  85 FA     	sta	<__bl
  615  01:A8E7  68        	pla
  616  01:A8E8  2D 09 27  	and	bat_hmask
  617  01:A8EB  85 FD     	sta	<__ch
  618  01:A8ED  60        	rts
  619                     
  620                     
  621                     ; ----
  622                     ; load_map_next_line
  623                     ; ----
  624                     ; load_map sub routine
  625                     ; ----
  626                     ; IN :	X = BAT line inc value (1-2)
  627                     ; ----
  628                     ; OUT:	_DI = BAT address
  629                     ;	_SI = map address
  630                     ; ----
  631                     ; USE:	_BL = BAT Y pos
  632                     ;	_BH = map Y pos
  633                     ;	_SI = map address
  634                     ; ----
  635                     
  636  01:A8EE            load_map_next_line:
  637                     
  638                     	; ----
  639                     	; incremente vram address
  640                     	;
  641  01:A8EE  8A        	txa
  642                     	add	<__bl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A8EF  18        	clc
       01:A8F0  65 FA     	adc	<__bl
                          .endif
  643  01:A8F2  CD FB 26  	cmp	mapbat_bottom
  644                     	blo	.l1
       01:A8F5  90 22     	bcc	.l1
  645                     	; --
  646                     	sub	mapbat_bottom	; 1/ vram wrapping
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:A8F7  38        	sec
       01:A8F8  ED FB 26  	sbc	mapbat_bottom	
                          .endif
  647  01:A8FB  AA        	tax
  648  01:A8FC  E8        	inx
  649                     	add	mapbat_top
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A8FD  18        	clc
       01:A8FE  6D FA 26  	adc	mapbat_top
                          .endif
  650  01:A901  85 FA     	sta	<__bl
  651  01:A903  AD F6 26  	lda	mapbat_ptr
  652  01:A906  2D 09 27  	and	bat_hmask
  653                     	add	mapbat_top_base
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A909  18        	clc
       01:A90A  6D F8 26  	adc	mapbat_top_base
                          .endif
  654  01:A90D  8D F6 26  	sta	mapbat_ptr
  655  01:A910  62        	cla
  656  01:A911  6D F9 26  	adc	mapbat_top_base+1
  657  01:A914  8D F7 26  	sta	mapbat_ptr+1
  658  01:A917  80 13     	bra	.l3
  659                     	; --
  660  01:A919  85 FA     .l1:	sta	<__bl		; 2/ vram inc
  661  01:A91B  AD 06 27  .l2:	lda	bat_width
  662                     	add	mapbat_ptr
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A91E  18        	clc
       01:A91F  6D F6 26  	adc	mapbat_ptr
                          .endif
  663  01:A922  8D F6 26  	sta	mapbat_ptr
  664  01:A925  62        	cla
  665  01:A926  6D F7 26  	adc	mapbat_ptr+1
  666  01:A929  8D F7 26  	sta	mapbat_ptr+1
  667                     	; --
  668  01:A92C  CA        .l3:	dex
  669  01:A92D  D0 EC     	bne	.l2
  670                     	; --
  671                     	stw	mapbat_ptr,<__di
       01:A92F  AD F6 26  	lda	LOW_BYTE mapbat_ptr
       01:A932  85 F0     	sta	LOW_BYTE <__di
       01:A934  AD F7 26  	lda	HIGH_BYTE mapbat_ptr
       01:A937  85 F1     	sta	HIGH_BYTE <__di
  672                     
  673                     	; ----
  674                     	; increment map address
  675                     	;
  676  01:A939  E6 FB     	inc	<__bh
  677  01:A93B  A5 FB     	lda	<__bh
  678  01:A93D  CD E8 26  	cmp	mapheight
  679  01:A940  D0 1A     	bne	.l4
  680                     	; --
  681  01:A942  AD E3 26  	lda	mapbank		; 1/ map wrapping
  682  01:A945  53 08     	tam	#3
  683  01:A947  1A        	inc	A
  684  01:A948  53 10     	tam	#4
  685                     	stb	mapaddr,<__si
       01:A94A  AD E4 26  	lda	mapaddr
       01:A94D  85 EE     	sta	<__si
  686  01:A94F  AD E5 26  	lda	mapaddr+1
  687  01:A952  29 1F     	and	#$1F
  688  01:A954  09 60     	ora	#$60
  689  01:A956  85 EF     	sta	<__si+1
  690  01:A958  64 FB     	stz	<__bh
  691  01:A95A  80 1F     	bra	.l5
  692                     	; --
  693                     .l4:	addw	mapwidth,<__si	; 2/ map inc
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:A95C  18        	clc
       01:A95D  A5 EE     	lda	LOW_BYTE <__si	
       01:A95F  6D E6 26  	adc	LOW_BYTE mapwidth
       01:A962  85 EE     	sta	LOW_BYTE <__si	
       01:A964  A5 EF     	lda	HIGH_BYTE <__si	
       01:A966  6D E7 26  	adc	HIGH_BYTE mapwidth
       01:A969  85 EF     	sta	HIGH_BYTE <__si	
                          .endif
  694  01:A96B  C9 80     	cmp	#$80
  695                     	blo	.l5
       01:A96D  90 0C     	bcc	.l5
  696                     	sub	#$20
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:A96F  38        	sec
       01:A970  E9 20     	sbc	#$20
                          .endif
  697  01:A972  85 EF     	sta	<__si+1
  698  01:A974  43 10     	tma	#4
  699  01:A976  53 08     	tam	#3
  700  01:A978  1A        	inc	A
  701  01:A979  53 10     	tam	#4
  702  01:A97B            .l5:
  703  01:A97B  60        	rts
  704                     
  705                     
  706           0000      	.bank	LIB1_BANK
  707                     
  708                     ; ----
  709                     ; load_font
  710                     ; ----
  711                     ; transfer a 8x8 monochrome font into VRAM, slow but can be useful
  712                     ; ----
  713                     ; IN :	_DI = VRAM base address
  714                     ;	_BL = font bank
  715                     ;	_SI = font memory location
  716                     ;	_AL = font color (0-15)
  717                     ;	_AH = bg color (0-15)
  718                     ;	_CL = number of characters to copy
  719                     ; ----
  720                     
  721  00:E375            load_font:
  722                     	maplibfunc	lib2_load_font
       00:E375  A8        	tay
       00:E376  43 20     	tma	#page(lib2_load_font)
       00:E378  48        	pha
       00:E379  A9 01     	lda	#bank(lib2_load_font)
       00:E37B  53 20     	tam	#page(lib2_load_font)
       00:E37D  98        	tya
       00:E37E  20 7C A9  	jsr	lib2_load_font
       00:E381  A8        	tay
       00:E382  68        	pla
       00:E383  53 20     	tam	#page(lib2_load_font)
       00:E385  98        	tya
  723  00:E386  60        	rts
  724                     
  725           0001      	.bank	LIB2_BANK
  726                     
  727                     	; ----
  728                     	; map data
  729                     	;
  730  01:A97C            lib2_load_font:
  731  01:A97C  20 D4 E2  	jsr	map_data
  732  01:A97F  20 02 E4  	jsr	set_write
  733                     
  734                     	; ----
  735                     	; init bg color
  736                     	;
  737  01:A982  A5 FC     	lda	<__cl
  738  01:A984  48        	pha
  739                     	; --
  740  01:A985  A2 03     	ldx	#3
  741  01:A987  62        .l1:	cla
  742  01:A988  46 F9     	lsr	<__ah
  743  01:A98A  90 02     	bcc	.l2
  744  01:A98C  A9 FF     	lda	#$FF
  745  01:A98E  95 FC     .l2:	sta	<__cl,X
  746  01:A990  CA        	dex
  747  01:A991  10 F4     	bpl	.l1
  748                     
  749                     	; ----
  750                     	; character loop
  751                     	;
  752  01:A993  FA        	plx
  753  01:A994            .copy:
  754                     
  755                     	; ----
  756                     	; plane 1
  757                     	;
  758  01:A994  C2        	cly
  759  01:A995  8F F8 08  .p1:	bbs0	<__al,.p2
  760  01:A998  B1 EE     	lda	[__si],Y
  761  01:A99A  49 FF     	eor	#$FF
  762  01:A99C  25 FF     	and	<__dh
  763  01:A99E  80 04     	bra	.p3
  764                     	; --
  765  01:A9A0  A5 FF     .p2:	lda	<__dh
  766  01:A9A2  11 EE     	ora	[__si],Y
  767  01:A9A4  8D 02 00  .p3:	sta	video_data_l
  768                     
  769                     	; ----
  770                     	; plane 2
  771                     	;
  772  01:A9A7  9F F8 08  	bbs1	<__al,.p4
  773  01:A9AA  B1 EE     	lda	[__si],Y
  774  01:A9AC  49 FF     	eor	#$FF
  775  01:A9AE  25 FE     	and	<__dl
  776  01:A9B0  80 04     	bra	.p5
  777                     	; --
  778  01:A9B2  A5 FE     .p4:	lda	<__dl
  779  01:A9B4  11 EE     	ora	[__si],Y
  780  01:A9B6  8D 03 00  .p5:	sta	video_data_h
  781                     	; --
  782  01:A9B9  C8        	iny
  783  01:A9BA  C0 08     	cpy	#8
  784  01:A9BC  D0 D7     	bne	.p1
  785                     
  786                     	; ----
  787                     	; plane 3
  788                     	;
  789  01:A9BE  C2        	cly
  790  01:A9BF  AF F8 08  .t1:	bbs2	<__al,.t2
  791  01:A9C2  B1 EE     	lda	[__si],Y
  792  01:A9C4  49 FF     	eor	#$FF
  793  01:A9C6  25 FD     	and	<__ch
  794  01:A9C8  80 04     	bra	.t3
  795                     	; --
  796  01:A9CA  A5 FD     .t2:	lda	<__ch
  797  01:A9CC  11 EE     	ora	[__si],Y
  798  01:A9CE  8D 02 00  .t3:	sta	video_data_l
  799                     
  800                     	; ----
  801                     	; plane 4
  802                     	;
  803  01:A9D1  BF F8 08  	bbs3	<__al,.t4
  804  01:A9D4  B1 EE     	lda	[__si],Y
  805  01:A9D6  49 FF     	eor	#$FF
  806  01:A9D8  25 FC     	and	<__cl
  807  01:A9DA  80 04     	bra	.t5
  808                     	; --
  809  01:A9DC  A5 FC     .t4:	lda	<__cl
  810  01:A9DE  11 EE     	ora	[__si],Y
  811  01:A9E0  8D 03 00  .t5:	sta	video_data_h
  812                     	; --
  813  01:A9E3  C8        	iny
  814  01:A9E4  C0 08     	cpy	#8
  815  01:A9E6  D0 D7     	bne	.t1
  816                     
  817                     	; ----
  818                     	; next character
  819                     	;
  820                     	addw	#8,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:A9E8  18        	clc
       01:A9E9  A5 EE     	lda	LOW_BYTE <__si
       01:A9EB  69 08     	adc	LOW_BYTE #8
       01:A9ED  85 EE     	sta	LOW_BYTE <__si
       01:A9EF  A5 EF     	lda	HIGH_BYTE <__si
       01:A9F1  69 00     	adc	HIGH_BYTE #8
       01:A9F3  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  821                     	; --
  822  01:A9F5  CA        	dex
  823  01:A9F6  D0 9C     	bne	.copy
  824                     
  825                     	; ----
  826                     	; unmap data
  827                     	;
  828  01:A9F8  4C F6 E2  	jmp	unmap_data
  829                     
  830                     	; ----
  831                     	; restore bank mapping
  832                     	;
  833           0000      	.bank	LIB1_BANK
  834                     
  835                     
  836                     ; ----
  837                     ; load_vram
  838                     ; ----
  839                     ; copy a block of memory to VRAM
  840                     ; ----
  841                     ; IN :	_DI = VRAM location
  842                     ;	_BL = data bank
  843                     ;	_SI = data memory location
  844                     ;	_CX = number of words to copy
  845                     ; ----
  846           26FE      	.bss
  847                     
  848                     ; This actually places a 'TIA' command
  849                     ; into RAM, from which to execute
  850                     ; for BLiT to VRAM for SATB transfer
  851                     ; and other VRAM load functions
  852                     
  853  --:26FE            ram_hdwr_tia		.ds	1
  854  --:26FF            ram_hdwr_tia_src	.ds	2
  855  --:2701            ram_hdwr_tia_dest	.ds	2
  856  --:2703            ram_hdwr_tia_size	.ds	2
  857  --:2705            ram_hdwr_tia_rts	.ds	1
  858                     
  859           E387      	.code
  860                     
  861           0001      .ifdef HUC
  862  00:E387            _load_vram.3:
  863                     .endif
  864  00:E387            load_vram:
  865                     
  866                     	; ----
  867                     	; map data
  868                     	;
  869  00:E387  20 D4 E2  	jsr	map_data
  870                     
  871                     	; ----
  872                     	; set vram address
  873                     	;
  874  00:E38A  20 02 E4  	jsr	set_write
  875                     
  876                     	; ----
  877                     	; copy data
  878                     	;
  879  00:E38D  A9 02     	lda	#<video_data
  880  00:E38F  8D 01 27  	sta	ram_hdwr_tia_dest+0
  881  00:E392  9C 02 27  	stz	ram_hdwr_tia_dest+1
  882  00:E395  A9 20     	lda	#$20
  883  00:E397  8D 03 27  	sta	ram_hdwr_tia_size+0
  884  00:E39A  9C 04 27  	stz	ram_hdwr_tia_size+1
  885                     
  886  00:E39D  A6 EE     	ldx	<__si+0
  887  00:E39F  8E FF 26  	stx	ram_hdwr_tia_src+0
  888  00:E3A2  A4 EF     	ldy	<__si+1
  889  00:E3A4  8C 00 27  	sty	ram_hdwr_tia_src+1
  890                     
  891  00:E3A7  A5 FC     	lda	<__cl			; length in chunks
  892  00:E3A9  46 FD     	lsr	<__ch
  893  00:E3AB  6A        	ror	a
  894  00:E3AC  46 FD     	lsr	<__ch
  895  00:E3AE  6A        	ror	a
  896  00:E3AF  46 FD     	lsr	<__ch
  897  00:E3B1  6A        	ror	a
  898  00:E3B2  46 FD     	lsr	<__ch
  899  00:E3B4  6A        	ror	a
  900  00:E3B5  22        	sax				; x=chunks-lo
  901  00:E3B6  F0 1F     	beq	.l4			; a=source-lo, y=source-hi
  902                     
  903                     	; ----
  904                     	; copy data (32-byte chunks)
  905                     	;
  906  00:E3B8  20 FE 26  .l1:	jsr	ram_hdwr_tia		; transfer 32-bytes
  907                     
  908  00:E3BB  18        	clc				; increment source
  909  00:E3BC  69 20     	adc	#$20
  910  00:E3BE  8D FF 26  	sta	ram_hdwr_tia_src+0
  911  00:E3C1  90 11     	bcc	.l3
  912  00:E3C3  C8        	iny
  913                     
  914  00:E3C4  10 0B     	bpl	.l2			; remap_data
  915  00:E3C6  A8        	tay
  916  00:E3C7  43 10     	tma4
  917  00:E3C9  53 08     	tam3
  918  00:E3CB  1A        	inc	a
  919  00:E3CC  53 10     	tam4
  920  00:E3CE  98        	tya
  921  00:E3CF  A0 60     	ldy	#$60
  922  00:E3D1  8C 00 27  .l2:	sty	ram_hdwr_tia_src+1
  923                     
  924  00:E3D4  CA        .l3:	dex
  925  00:E3D5  D0 E1     	bne	.l1
  926  00:E3D7  C6 FD     .l4:	dec	<__ch
  927  00:E3D9  10 DD     	bpl	.l1
  928                     
  929                     	; ----
  930                     	; copy data (remainder)
  931                     	;
  932  00:E3DB  A5 FC     	lda	<__cl
  933  00:E3DD  29 0F     	and	#15
  934  00:E3DF  F0 07     	beq	.l5
  935                     
  936  00:E3E1  0A        	asl	a
  937  00:E3E2  8D 03 27  	sta	ram_hdwr_tia_size+0
  938  00:E3E5  20 FE 26  	jsr	ram_hdwr_tia		; transfer remainder
  939                     
  940                     	; ----
  941                     	; unmap data
  942                     	;
  943                     
  944  00:E3E8  4C F6 E2  .l5:	jmp	unmap_data
  945                     
  946                     
  947                     ; ----
  948                     ; set_read
  949                     ; ----
  950                     ; set the VDC VRAM read pointer
  951                     ; ----
  952                     ; IN :	_DI = VRAM location
  953                     ; ----
  954                     
  955  00:E3EB            set_read:
  956                     	vreg	#$01
       00:E3EB  A9 01     	lda	#$01
       00:E3ED  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:E3EF  03 01     	st0	#$01
                          .else
                          .endif
  957  00:E3F1  A5 F0     	lda	<__di
  958  00:E3F3  8D 02 00  	sta	video_data_l
  959  00:E3F6  A5 F1     	lda	<__di+1
  960  00:E3F8  8D 03 00  	sta	video_data_h
  961                     	vreg	#$02
       00:E3FB  A9 02     	lda	#$02
       00:E3FD  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:E3FF  03 02     	st0	#$02
                          .else
                          .endif
  962  00:E401  60        	rts
  963                     
  964                     
  965                     ; ----
  966                     ; set_write
  967                     ; ----
  968                     ; set the VDC VRAM write pointer
  969                     ; ----
  970                     ; IN :	_DI = VRAM location
  971                     ; ----
  972                     
  973  00:E402            set_write:
  974                     	vreg	#$00
       00:E402  A9 00     	lda	#$00
       00:E404  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:E406  03 00     	st0	#$00
                          .else
                          .endif
  975  00:E408  A5 F0     	lda	<__di
  976  00:E40A  8D 02 00  	sta	video_data_l
  977  00:E40D  A5 F1     	lda	<__di+1
  978  00:E40F  8D 03 00  	sta	video_data_h
  979                     	vreg	#$02
       00:E412  A9 02     	lda	#$02
       00:E414  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:E416  03 02     	st0	#$02
                          .else
                          .endif
  980  00:E418  60        	rts
  981                     
  982                     
  983                     ; ----
  984                     ; calc_vram_addr
  985                     ; ----
  986                     ; calculate VRAM address
  987                     ; ----
  988                     ; IN :	X = x coordinates
  989                     ;	A = y	"
  990                     ; ----
  991                     ; OUT:	_DI = VRAM location
  992                     ; ----
  993                     
  994  00:E419            calc_vram_addr:
  995  00:E419  DA        	phx
  996  00:E41A  2D 0A 27  	and	bat_vmask
  997  00:E41D  64 F0     	stz	<__di
  998  00:E41F  AE 06 27  	ldx	bat_width
  999  00:E422  E0 40     	cpx	#64
 1000  00:E424  F0 07     	beq	.s64
 1001  00:E426  E0 80     	cpx	#128
 1002  00:E428  F0 06     	beq	.s128
 1003                     	; --
 1004  00:E42A  4A        .s32:	lsr	A
 1005  00:E42B  66 F0     	ror	<__di
 1006                     	; --
 1007  00:E42D  4A        .s64:	lsr	A
 1008  00:E42E  66 F0     	ror	<__di
 1009                     	; --
 1010  00:E430  4A        .s128:	lsr	A
 1011  00:E431  66 F0     	ror	<__di
 1012  00:E433  85 F1     	sta	<__di+1
 1013                     	; --
 1014  00:E435  68        	pla
 1015  00:E436  2D 09 27  	and	bat_hmask
 1016  00:E439  05 F0     	ora	<__di
 1017  00:E43B  85 F0     	sta	<__di
 1018  00:E43D  60        	rts
 1019                     
 1020                     ; ----
 1021                     ; HSR(xres)
 1022                     ; ----
 1023                     ; macros to calculate the value of the HSR VDC register
 1024                     ; ----
 1025                     ; IN :	xres, horizontal screen resolution
 1026                     ; ----
 1027                     
 1028                     HSR	.macro
 1029                     .if (\1 < 268)
 1030                     	; low res
 1031                     	.db $02
 1032                     	.db (18 - (\1 / 16))
 1033                     .else
 1034                     .if (\1 < 356)
 1035                     	; high res
 1036                     	.db $03
 1037                     	.db (25 - (\1 / 16))
 1038                     .else
 1039                     	; very high res
 1040                     	.db $05
 1041                     	.db (42 - (\1 / 16))
 1042                     .endif
 1043                     .endif
 1044                     .endm
 1045                     
 1046                     
 1047                     ; ----
 1048                     ; HDR(xres)
 1049                     ; ----
 1050                     ; macros to calculate the value of the HDR VDC register
 1051                     ; ----
 1052                     ; IN :	xres, horizontal screen resolution
 1053                     ; ----
 1054                     
 1055                     HDR	.macro
 1056                     	.db ((\1 / 8) - 1)
 1057                     .if (\1 < 268)
 1058                     	; low res
 1059                     	.db (38 - ((18 - (\1 / 16)) + (\1 / 8)))
 1060                     .else
 1061                     .if (\1 < 356)
 1062                     	; high res
 1063                     	.db (51 - ((25 - (\1 / 16)) + (\1 / 8)))
 1064                     .else
 1065                     	; high res
 1066                     	.db (82 - ((42 - (\1 / 16)) + (\1 / 8)))
 1067                     .endif
 1068                     .endif
 1069                     .endm
 1070                     
 1071                     
 1072                     ; ----
 1073                     ; init_vdc
 1074                     ; ----
 1075                     ; initialize the video controller
 1076                     ;  - 256x224 screen mode
 1077                     ;  - 64x32 virtual bgmap size
 1078                     ;  - display and sprites off
 1079                     ;  - interrupts disabled
 1080                     ;  - SATB at $7F00
 1081                     ;  - VRAM cleared
 1082                     ; ----
 1083                     
 1084           2706      	.bss
 1085  --:2706            bat_width	.ds 2
 1086  --:2708            bat_height	.ds 1
 1087  --:2709            bat_hmask	.ds 1
 1088  --:270A            bat_vmask	.ds 1
 1089  --:270B            scr_width	.ds 1
 1090  --:270C            scr_height	.ds 1
 1091                     
 1092           E43E      	.code
 1093                     
 1094  00:E43E            init_vdc:
 1095                     	maplibfunc lib2_init_vdc
       00:E43E  A8        	tay
       00:E43F  43 20     	tma	#page(lib2_init_vdc)
       00:E441  48        	pha
       00:E442  A9 01     	lda	#bank(lib2_init_vdc)
       00:E444  53 20     	tam	#page(lib2_init_vdc)
       00:E446  98        	tya
       00:E447  20 FB A9  	jsr	lib2_init_vdc
       00:E44A  A8        	tay
       00:E44B  68        	pla
       00:E44C  53 20     	tam	#page(lib2_init_vdc)
       00:E44E  98        	tya
 1096  00:E44F  60        	rts
 1097                     
 1098           0001      	.bank	LIB2_BANK
 1099  01:A9FB            lib2_init_vdc:
 1100                     ; ----
 1101                     ; default screen resolution
 1102                     ;
 1103           0000      .ifndef xres
 1105                     .endif
 1106                     
 1107                     	; ----
 1108                     	; initialize the VDC registers
 1109                     	;
 1110                     	stw	#.table,<__si 	; register table address in 'si'
       01:A9FB  A9 6B     	lda	LOW_BYTE #.table
       01:A9FD  85 EE     	sta	LOW_BYTE <__si 	
       01:A9FF  A9 AA     	lda	HIGH_BYTE #.table
       01:AA01  85 EF     	sta	HIGH_BYTE <__si 	
 1111  01:AA03  C2        	cly
 1112  01:AA04  B1 EE     .l1:	lda	[__si],Y		; select the VDC register
 1113  01:AA06  C8        	iny
 1114  01:AA07  85 F7     	sta	<vdc_reg
 1115  01:AA09  8D 00 00  	sta	video_reg
 1116  01:AA0C  B1 EE     	lda	[__si],Y		; send the 16-bit data
 1117  01:AA0E  C8        	iny
 1118  01:AA0F  8D 02 00  	sta	video_data_l
 1119  01:AA12  B1 EE     	lda	[__si],Y
 1120  01:AA14  C8        	iny
 1121  01:AA15  8D 03 00  	sta	video_data_h
 1122  01:AA18  C0 24     	cpy	#36		; loop if not at the end of the
 1123  01:AA1A  D0 E8     	bne	.l1		; table
 1124                     
 1125                     	; ----
 1126                     	; set the screen mode
 1127                     	;
 1128           0001      .if (xres < 268)
 1129  01:AA1C  A9 04     	lda	#(0 | XRES_SOFT)
 1130                     .else
 1136                     .endif
 1137                     
 1138                     ; This stuff alters display position from HuCard position
 1139                     
 1140                     ;	.if (CDROM)
 1141                     ;
 1142                     ;	ldx	#xres/8
 1143                     ;	ldy	#30
 1144                     ;	jsr	ex_scrmod
 1145                     ;	lda	#$01
 1146                     ;	jsr	ex_scrsiz
 1147                     ;	lda	#0
 1148                     ;	jsr	ex_imode
 1149                     ;
 1150                     ;	.else
 1151                     
 1152                     	; pixel clock frequency
 1153  01:AA1E  8D 00 04  	sta	color_ctrl
 1154                     ;
 1155                     ;	.endif
 1156                     
 1157                     
 1158                     	; ----
 1159                     	; set the background & border colors to black
 1160                     	;
 1161                     	stw	#256,color_reg
       01:AA21  A9 00     	lda	LOW_BYTE #256
       01:AA23  8D 02 04  	sta	LOW_BYTE color_reg
       01:AA26  A9 01     	lda	HIGH_BYTE #256
       01:AA28  8D 03 04  	sta	HIGH_BYTE color_reg
 1162                     	stwz	color_data
       01:AA2B  9C 04 04  	stz	LOW_BYTE color_data
       01:AA2E  9C 05 04  	stz	HIGH_BYTE color_data
 1163                     	stwz	color_reg
       01:AA31  9C 02 04  	stz	LOW_BYTE color_reg
       01:AA34  9C 03 04  	stz	HIGH_BYTE color_reg
 1164                     	stwz	color_data
       01:AA37  9C 04 04  	stz	LOW_BYTE color_data
       01:AA3A  9C 05 04  	stz	HIGH_BYTE color_data
 1165                     
 1166           0000      .if (CDROM)
 1186                     .endif	; (CDROM)
 1187                     
 1188                     	; ----
 1189                     	; clear the video RAM
 1190                     	;
 1191  01:AA3D  03 00     	st0	#0
 1192  01:AA3F  13 00     	st1	#0
 1193  01:AA41  23 00     	st2	#0
 1194  01:AA43  03 02     	st0	#2
 1195                     
 1196  01:AA45  A2 80     	ldx	#128
 1197  01:AA47  C2        .l2:	cly
 1198  01:AA48  13 00     .l3:	st1	#0
 1199  01:AA4A  23 00     	st2	#0
 1200  01:AA4C  88        	dey
 1201  01:AA4D  D0 F9     	bne	.l3
 1202  01:AA4F  CA        	dex
 1203  01:AA50  D0 F5     	bne	.l2
 1204                     
 1205                     	; ----
 1206                     	; save screen infos
 1207                     	;
 1208                     	stw	#xres,scr_width	; resolution
       01:AA52  A9 00     	lda	LOW_BYTE #xres
       01:AA54  8D 0B 27  	sta	LOW_BYTE scr_width	
       01:AA57  A9 01     	lda	HIGH_BYTE #xres
       01:AA59  8D 0C 27  	sta	HIGH_BYTE scr_width	
 1209                     	stw	#224,scr_height
       01:AA5C  A9 E0     	lda	LOW_BYTE #224
       01:AA5E  8D 0C 27  	sta	LOW_BYTE scr_height
       01:AA61  A9 00     	lda	HIGH_BYTE #224
       01:AA63  8D 0D 27  	sta	HIGH_BYTE scr_height
 1210                     	; --
 1211  01:AA66  A9 01     	lda	#BGMAP_SIZE_64x32	; virtual size
 1212  01:AA68  4C 62 E4  	jmp	set_bat_size
 1213                     
 1214                     	; ----
 1215                     	; VDC register table
 1216                     	;
 1217  01:AA6B            .table:
 1218           0000      .ifdef _SGX
 1220                     .endif
 1221  01:AA6B  05 00 00  	.db $05,$00,$00		; CR	control register
 1222  01:AA6E  06 00 00  	.db $06,$00,$00		; RCR	scanline interrupt counter
 1223  01:AA71  07 00 00  	.db $07,$00,$00		; BXR	background horizontal scroll offset
 1224  01:AA74  08 00 00  	.db $08,$00,$00		; BYR        "     vertical     "      "
 1225  01:AA77  09 10 00  	.db $09,$10,$00		; MWR	size of the virtual screen
 1226  01:AA7A  0A        	.db $0A			; HSR +
 1227                     	HSR xres		;     |			[$02,$02]
                0001      .if (xres		 < 268)
                          	; low res
       01:AA7B  02        	.db $02
       01:AA7C  02        	.db (18 - (xres		 / 16))
                          .else
                          .endif
 1228  01:AA7D  0B        	.db $0B			; HDR | display size
 1229                     	HDR xres		;     | and synchro	[$1F,$04]
       01:AA7E  1F        	.db ((xres		 / 8) - 1)
                0001      .if (xres		 < 268)
                          	; low res
       01:AA7F  04        	.db (38 - ((18 - (xres		 / 16)) + (xres		 / 8)))
                          .else
                          .endif
 1230  01:AA80  0C 02 17  	.db $0C,$02,$17		; VPR |
 1231  01:AA83  0D DF 00  	.db $0D,$DF,$00		; VDW |
 1232  01:AA86  0E 0C 00  	.db $0E,$0C,$00		; VCR +
 1233  01:AA89  0F 10 00  	.db $0F,$10,$00		; DCR	DMA control register
 1234  01:AA8C  13 00 7F  	.db $13,$00,$7F		; SATB	address of the SATB
 1235           0000      	.bank	LIB1_BANK
 1236                     
 1237                     
 1238                     ; ----
 1239                     ; set_xres
 1240                     ; ----
 1241                     ; set horizontal display resolution
 1242                     ; ----
 1243                     ; IN :	_AX = new x resolution (ie. 320)
 1244                     ;	_CL = 'blur bit' for color register
 1245                     ; USES: _BX
 1246                     ; ----
 1247                     
 1248  00:E450            set_xres:
 1249                     	maplibfunc	lib2_set_xres
       00:E450  A8        	tay
       00:E451  43 20     	tma	#page(lib2_set_xres)
       00:E453  48        	pha
       00:E454  A9 01     	lda	#bank(lib2_set_xres)
       00:E456  53 20     	tam	#page(lib2_set_xres)
       00:E458  98        	tya
       00:E459  20 8F AA  	jsr	lib2_set_xres
       00:E45C  A8        	tay
       00:E45D  68        	pla
       00:E45E  53 20     	tam	#page(lib2_set_xres)
       00:E460  98        	tya
 1250  00:E461  60        	rts
 1251                     
 1252                     
 1253           0001      	.bank	LIB2_BANK
 1254                     
 1255           270D      	.bss
 1256  --:270D            vdc_blur	.ds 1	; blur bit
 1257  --:270E            hsw		.ds 1	; temporary parameters for calculating video registers
 1258  --:270F            hds		.ds 1
 1259  --:2710            hdw		.ds 1
 1260  --:2711            hde		.ds 1
 1261                     
 1262           AA8F      	.code
 1263                     
 1264  01:AA8F            lib2_set_xres:
 1265  01:AA8F  A9 20     	lda	#$20		; reset resource-usage flag
 1266  01:AA91  04 F5     	tsb	<irq_m		; to skip joystick read portion of vsync
 1267                     				; (temporarily disable VSYNC processing)
 1268  01:AA93  A5 F9     	lda	<__ah
 1269  01:AA95  85 FB     	sta	<__bh
 1270  01:AA97  A5 F8     	lda	<__al
 1271  01:AA99  85 FA     	sta	<__bl		; bx now has x-res
 1272                     
 1273  01:AA9B  46 FB     	lsr	<__bh
 1274  01:AA9D  66 FA     	ror	<__bl
 1275  01:AA9F  46 FB     	lsr	<__bh
 1276  01:AAA1  66 FA     	ror	<__bl
 1277  01:AAA3  46 FA     	lsr	<__bl		; bl now has x/8
 1278                     
 1279  01:AAA5  C2        	cly			; offset into numeric tables
 1280                     				; 0=low-res, 1=mid-res, 2=high-res
 1281                     
 1282  01:AAA6  A5 F9     	lda	<__ah
 1283  01:AAA8  F0 1E     	beq	.xres_calc	; < 256
 1284  01:AAAA  C9 03     	cmp	#3
 1285                     	bhs	.xres_calc
       01:AAAC  B0 1A     	bcs	.xres_calc
 1286                     
 1287                     	cmpw	#$10C,<__ax
       01:AAAE  A5 F9     	lda	HIGH_BYTE <__ax
       01:AAB0  C9 01     	cmp	HIGH_BYTE #$10C
       01:AAB2  D0 04     	bne	.x_00092
       01:AAB4  A5 F8     	lda	LOW_BYTE <__ax
       01:AAB6  C9 0C     	cmp	LOW_BYTE #$10C
       01:AAB8            .x_00092:
 1288                     	blo	.xres_calc	; < 268
       01:AAB8  90 0E     	bcc	.xres_calc	
 1289                     
 1290  01:AABA  C8        	iny
 1291                     	cmpw	#$164,<__ax
       01:AABB  A5 F9     	lda	HIGH_BYTE <__ax
       01:AABD  C9 01     	cmp	HIGH_BYTE #$164
       01:AABF  D0 04     	bne	.x_00094
       01:AAC1  A5 F8     	lda	LOW_BYTE <__ax
       01:AAC3  C9 64     	cmp	LOW_BYTE #$164
       01:AAC5            .x_00094:
 1292                     	blo	.xres_calc	; < 356
       01:AAC5  90 01     	bcc	.xres_calc	
 1293                     
 1294  01:AAC7  C8        	iny			; 356 < x < 512
 1295                     
 1296  01:AAC8            .xres_calc:
 1297  01:AAC8  B9 24 AB  	lda	.vce_tab,Y
 1298  01:AACB  05 FC     	ora	<__cl
 1299  01:AACD  8D 00 04  	sta	color_ctrl	; dot-clock (x-resolution)
 1300                     
 1301  01:AAD0  B9 27 AB  	lda	.hsw_tab,Y	; example calc's (using "low-res" numbers)
 1302  01:AAD3  8D 0E 27  	sta	hsw		; hsw = $2
 1303  01:AAD6  A5 FA     	lda	<__bl
 1304  01:AAD8  8D 0F 27  	sta	hds		; hds = (x/8) temporarily
 1305  01:AADB  3A        	dec	A
 1306  01:AADC  8D 10 27  	sta	hdw		; hdw = (x/8)-1
 1307  01:AADF  4E 0F 27  	lsr	hds		; hds = (x/16) temporarily
 1308                     
 1309  01:AAE2  B9 2A AB  	lda	.hds_tab,Y
 1310                     	sub	hds
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AAE5  38        	sec
       01:AAE6  ED 0F 27  	sbc	hds
                          .endif
 1311  01:AAE9  8D 0F 27  	sta	hds		; hds = 18 - (x/16)
 1312                     
 1313  01:AAEC  B9 2D AB  	lda	.hde_tab,Y
 1314                     	sub	hds
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AAEF  38        	sec
       01:AAF0  ED 0F 27  	sbc	hds
                          .endif
 1315                     	sub	<__bl		; hde = (38 - ( (18-(x/16)) + (x/8) ))
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AAF3  38        	sec
       01:AAF4  E5 FA     	sbc	<__bl		
                          .endif
 1316  01:AAF6  8D 11 27  	sta	hde
 1317                     
 1318  01:AAF9            .xres_putit:
 1319  01:AAF9  A9 0A     	lda	#$0a
 1320  01:AAFB  85 F7     	sta	<vdc_reg
 1321  01:AAFD  8D 00 00  	sta	video_reg
 1322  01:AB00  AD 0E 27  	lda	hsw
 1323  01:AB03  8D 02 00  	sta	video_data_l
 1324  01:AB06  AD 0F 27  	lda	hds
 1325  01:AB09  8D 03 00  	sta	video_data_h
 1326                     
 1327  01:AB0C  A9 0B     	lda	#$0b
 1328  01:AB0E  85 F7     	sta	<vdc_reg
 1329  01:AB10  8D 00 00  	sta	video_reg
 1330  01:AB13  AD 10 27  	lda	hdw
 1331  01:AB16  8D 02 00  	sta	video_data_l
 1332  01:AB19  AD 11 27  	lda	hde
 1333  01:AB1C  8D 03 00  	sta	video_data_h
 1334                     
 1335  01:AB1F            .xres_err:
 1336  01:AB1F  A9 20     	lda	#$20
 1337  01:AB21  14 F5     	trb	<irq_m		; re-enable VSYNC processing
 1338  01:AB23  60        	rts
 1339                     
 1340  01:AB24  00 01 02  .vce_tab:	.db	0, 1, 2
 1341  01:AB27  02 03 05  .hsw_tab:	.db	2, 3, 5
 1342  01:AB2A  12 19 2A  .hds_tab:	.db	18,25,42
 1343  01:AB2D  26 33 52  .hde_tab:	.db	38,51,82
 1344                     
 1345           0000      	.bank	LIB1_BANK	; restore bank context
 1346                     
 1347                     ; ----
 1348                     ; set_bat_size
 1349                     ; ----
 1350                     ; set bg map virtual size
 1351                     ; ----
 1352                     ; IN : A = new size (0-7)
 1353                     ; ----
 1354                     
 1355  00:E462            set_bat_size:
 1356  00:E462  29 07     	and	#$07
 1357  00:E464  48        	pha
 1358                     	; --
 1359           0000      .if (CDROM)
 1362                     .else
 1363                     	vreg	#9
       00:E465  A9 09     	lda	#9
       00:E467  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:E469  03 09     	st0	#9
                          .else
                          .endif
 1364  00:E46B  68        	pla
 1365  00:E46C  AA        	tax
 1366  00:E46D  0A        	asl	A
 1367  00:E46E  0A        	asl	A
 1368  00:E46F  0A        	asl	A
 1369  00:E470  0A        	asl	A
 1370  00:E471  8D 02 00  	sta	video_data_l
 1371                     .endif
 1372                     	; --
 1373  00:E474  BD 98 E4  	lda	.width,X
 1374  00:E477  8D 06 27  	sta	bat_width
 1375  00:E47A  9C 07 27  	stz	bat_width+1
 1376  00:E47D  3A        	dec	A
 1377  00:E47E  8D 09 27  	sta	bat_hmask
 1378                     	; --
 1379  00:E481  BD A0 E4  	lda	.height,X
 1380  00:E484  8D 08 27  	sta	bat_height
 1381  00:E487  8D FB 26  	sta	mapbat_bottom
 1382  00:E48A  9C FA 26  	stz	mapbat_top
 1383  00:E48D  9C F8 26  	stz	mapbat_top_base
 1384  00:E490  9C F9 26  	stz	mapbat_top_base+1
 1385  00:E493  3A        	dec	A
 1386  00:E494  8D 0A 27  	sta	bat_vmask
 1387  00:E497  60        	rts
 1388                     
 1389  00:E498  20 40 80  .width:	.db $20,$40,$80,$80,$20,$40,$80,$80
       00:E49B  80 20 40  
       00:E49E  80 80     
 1390  00:E4A0  20 20 20  .height: .db $20,$20,$20,$20,$40,$40,$40,$40
       00:E4A3  20 40 40  
       00:E4A6  40 40     
 1391                     
 1392                     
 1393                     ; ----
 1394                     ; init_psg
 1395                     ; ----
 1396                     ; initialize the sound generator.
 1397                     ; ----
 1398                     
 1399  00:E4A8            init_psg:
 1400                     	maplibfunc lib2_init_psg
       00:E4A8  A8        	tay
       00:E4A9  43 20     	tma	#page(lib2_init_psg)
       00:E4AB  48        	pha
       00:E4AC  A9 01     	lda	#bank(lib2_init_psg)
       00:E4AE  53 20     	tam	#page(lib2_init_psg)
       00:E4B0  98        	tya
       00:E4B1  20 30 AB  	jsr	lib2_init_psg
       00:E4B4  A8        	tay
       00:E4B5  68        	pla
       00:E4B6  53 20     	tam	#page(lib2_init_psg)
       00:E4B8  98        	tya
 1401  00:E4B9  60        	rts
 1402                     
 1403           0001      	.bank	LIB2_BANK
 1404  01:AB30            lib2_init_psg:
 1405  01:AB30  9C 01 08  	stz	psg_mainvol	; main volume to zero
 1406  01:AB33  9C 09 08  	stz	psg_lfoctrl	; disable the LFO
 1407                     
 1408  01:AB36  A9 05     	lda	#5		; set volume to zero for each channel
 1409  01:AB38  8D 00 08  .clear:	sta	psg_ch		; and disable them
 1410  01:AB3B  9C 04 08  	stz	psg_ctrl
 1411  01:AB3E  9C 05 08  	stz	psg_pan
 1412  01:AB41  3A        	dec	A
 1413  01:AB42  10 F4     	bpl	.clear
 1414                     
 1415  01:AB44  A9 04     	lda	#4		; disable noise for channel 5 & 6
 1416  01:AB46  8D 00 08  	sta	psg_ch
 1417  01:AB49  9C 07 08  	stz	psg_noise
 1418  01:AB4C  A9 05     	lda	#5
 1419  01:AB4E  8D 00 08  	sta	psg_ch
 1420  01:AB51  9C 07 08  	stz	psg_noise
 1421  01:AB54  60        	rts
 1422           0000      	.bank	LIB1_BANK
 1423                     
 1424                     
 1425                     ; ----------------------------------
 1426                     ; Some simple copy/compare functions
 1427                     ; ----------------------------------
 1428                     
 1429                     ; ----
 1430                     ; char * _strncpy(char *dest [__di], char *src [__si], unsigned char count [acc])
 1431                     ; char * _strncat(char *dest [__di], char *src [__si], unsigned char count [acc])
 1432                     ; ----
 1433                     ; Copy/Concatenate a string to another string
 1434                     ; ----
 1435                     
 1436  00:E4BA  48        str_find_end:	pha
 1437  00:E4BB  B2 F0     .loop:		lda	[__di]
 1438  00:E4BD  F0 08     		beq	.found
 1439  00:E4BF  E6 F0     		inc	<__di
 1440  00:E4C1  D0 F8     		bne	.loop
 1441  00:E4C3  E6 F1     		inc	<__di+1
 1442  00:E4C5  80 F4     		bra	.loop
 1443  00:E4C7  68        .found:		pla
 1444  00:E4C8  60        		rts
 1445                     
 1446  00:E4C9  44 EF     _strncat.3:     bsr	str_find_end
 1447                     
 1448  00:E4CB  8A        _strncpy.3:	txa
 1449  00:E4CC  49 FF     		eor	#$ff
 1450  00:E4CE  AA        		tax
 1451                     
 1452  00:E4CF  C2        		cly
 1453  00:E4D0  E8        .loop:		inx
 1454  00:E4D1  F0 18     		beq	str_terminate
 1455  00:E4D3  B1 EE     .copy:		lda	[__si],y
 1456  00:E4D5  F0 14     		beq	str_terminate
 1457  00:E4D7  91 F0     		sta	[__di],y
 1458  00:E4D9  C8        		iny
 1459  00:E4DA  D0 F4     		bne	.loop
 1460  00:E4DC  80 0C     		bra	str_overflow
 1461                     
 1462                     ; ----
 1463                     ; char * _strcat(char *dest [__di], char *src [__si])
 1464                     ; char * _strcpy(char *dest [__di], char *src [__si])
 1465                     ; ----
 1466                     ; Copy/Concatenate a string to another string
 1467                     ; ----
 1468                     
 1469  00:E4DE  44 DA     _strcat.2:	bsr	str_find_end
 1470                     
 1471  00:E4E0  C2        _strcpy.2:	cly
 1472  00:E4E1  B1 EE     .loop:		lda	[__si],y
 1473  00:E4E3  91 F0     		sta	[__di],y
 1474  00:E4E5  F0 29     		beq	memstr_finish
 1475  00:E4E7  C8        		iny
 1476  00:E4E8  D0 F7     		bne	.loop
 1477  00:E4EA  88        str_overflow:	dey
 1478  00:E4EB  62        str_terminate:	cla
 1479  00:E4EC  91 F0     		sta	[__di],y
 1480  00:E4EE  80 20     		bra	memstr_finish
 1481                     
 1482                     ; ----
 1483                     ; char * _memcpy(char *dest [__di], char *src [__si], int count [acc])
 1484                     ; ----
 1485                     ; Copy memory
 1486                     ; ----
 1487                     
 1488  00:E4F0            _mempcpy.3:
 1489  00:E4F0  86 02     _memcpy.3:	stx	<__temp
 1490  00:E4F2  C2        		cly
 1491  00:E4F3  AA        		tax
 1492  00:E4F4  F0 0E     		beq	.done_pages
 1493  00:E4F6  B1 EE     .copy_page:	lda	[__si],y
 1494  00:E4F8  91 F0     		sta	[__di],y
 1495  00:E4FA  C8        		iny
 1496                     ;		lda	[__si],y
 1497                     ;		sta	[__di],y
 1498                     ;		iny
 1499  00:E4FB  D0 F9     		bne	.copy_page
 1500  00:E4FD  E6 EF     		inc	<__si+1
 1501  00:E4FF  E6 F1     		inc	<__di+1
 1502  00:E501  CA        		dex
 1503  00:E502  D0 F2     		bne	.copy_page
 1504                     
 1505                     ;.done_pages:	lsr	<__temp
 1506                     ;		ldx	<__temp
 1507                     ;		beq	memstr_finish
 1508                     ;		bcs	.copy_1byte
 1509                     ;		dex
 1510                     ;.copy_2bytes:	lda	[__si],y
 1511                     ;		sta	[__di],y
 1512                     ;		iny
 1513                     ;.copy_1byte:	lda	[__si],y
 1514                     ;		sta	[__di],y
 1515                     ;		iny
 1516                     ;		dex
 1517                     ;		bpl	.copy_2bytes
 1518                     ;.done_bytes:	bra	memstr_finish
 1519                     
 1520  00:E504  A6 02     .done_pages:	ldx	<__temp
 1521  00:E506  F0 08     		beq	memstr_finish
 1522  00:E508  B1 EE     .copy_byte:	lda	[__si],y
 1523  00:E50A  91 F0     		sta	[__di],y
 1524  00:E50C  C8        		iny
 1525  00:E50D  CA        		dex
 1526  00:E50E  D0 F8     		bne	.copy_byte
 1527  00:E510            .done_bytes: ;	bra	memstr_finish
 1528                     
 1529                     		; !!! WARNING : non-standard return value !!!
 1530                     		; it's actually a lot more useful to have these
 1531                     		; return a ptr to the end of the strcpy/strcat.
 1532                     
 1533  00:E510  98        memstr_finish:	tya
 1534  00:E511  18        		clc
 1535  00:E512  65 F0     		adc	<__di
 1536  00:E514  AA        		tax
 1537  00:E515  A5 F1     		lda	<__di+1
 1538  00:E517  90 01     		bcc	.exit
 1539  00:E519  1A        		inc	a
 1540  00:E51A  60        .exit:		rts
 1541                     
 1542                     ; ----
 1543                     ; char * _memset(char *s [__di], int c [__bx], int n [acc])
 1544                     ; ----
 1545                     ; Set memory
 1546                     ; ----
 1547                     
 1548  00:E51B  86 02     _memset.3:	stx	<__temp
 1549  00:E51D  C2        		cly
 1550  00:E51E  AA        		tax
 1551  00:E51F  F0 0E     		beq	.done_pages
 1552  00:E521  A5 FA     		lda	<__bx
 1553  00:E523  91 F0     .set_page:	sta	[__di],y
 1554  00:E525  C8        		iny
 1555                     ;		sta	[__di],y
 1556                     ;		iny
 1557  00:E526  D0 FB     		bne	.set_page
 1558  00:E528  E6 EF     		inc	<__si+1
 1559  00:E52A  E6 F1     		inc	<__di+1
 1560  00:E52C  CA        		dex
 1561  00:E52D  D0 F4     		bne	.set_page
 1562                     
 1563                     ;.done_pages:	lsr	<__temp
 1564                     ;		ldx	<__temp
 1565                     ;		beq	memstr_finish
 1566                     ;		bcs	.set_1byte
 1567                     ;		dex
 1568                     ;.set_2bytes:	sta	[__di],y
 1569                     ;		iny
 1570                     ;.set_1byte:	sta	[__di],y
 1571                     ;		iny
 1572                     ;		dex
 1573                     ;		bpl	.set_2bytes
 1574                     ;.done_bytes:	bra	memstr_finish
 1575                     
 1576  00:E52F  A6 02     .done_pages:	ldx	<__temp
 1577  00:E531  F0 DD     		beq	memstr_finish
 1578  00:E533  A5 FA     		lda	<__bx
 1579  00:E535  91 F0     .set_byte:	sta	[__di],y
 1580  00:E537  C8        		iny
 1581  00:E538  CA        		dex
 1582  00:E539  D0 FA     		bne	.set_byte
 1583  00:E53B  80 D3     .done_bytes:	bra	memstr_finish
 1584                     
 1585                     ; ----
 1586                     ; int _memcmp(char *dest [__di], char *src [__si], int count [acc])
 1587                     ; ----
 1588                     ; Compare memory
 1589                     ; ----
 1590                     
 1591  00:E53D  49 FF     _memcmp.3:	eor	#$ff
 1592  00:E53F  85 02     		sta	<__temp
 1593  00:E541  8A        		txa
 1594  00:E542  49 FF     		eor	#$ff
 1595  00:E544  AA        		tax
 1596  00:E545  C2        		cly
 1597  00:E546  E8        .loop:		inx
 1598  00:E547  F0 11     		beq	.page
 1599  00:E549  B1 F0     .test:		lda	[__di],y
 1600  00:E54B  D1 EE     		cmp	[__si],y
 1601  00:E54D  30 17     		bmi	cmp_minus
 1602  00:E54F  D0 11     		bne	cmp_plus
 1603  00:E551  C8        		iny
 1604  00:E552  D0 F2     		bne	.loop
 1605  00:E554  E6 EF     		inc	<__si+1
 1606  00:E556  E6 F1     		inc	<__di+1
 1607  00:E558  80 EC     		bra	.loop
 1608  00:E55A  E6 02     .page:		inc	<__temp
 1609  00:E55C  D0 EB     		bne	.test
 1610                     ;		bra	cmp_same
 1611                     
 1612  00:E55E  A2 00     cmp_same:	ldx	#$00
 1613  00:E560  62        		cla
 1614  00:E561  60        		rts
 1615                     
 1616  00:E562  A2 01     cmp_plus:	ldx	#$01
 1617  00:E564  62        		cla
 1618  00:E565  60        		rts
 1619                     
 1620  00:E566  A2 FF     cmp_minus:	ldx	#$FF
 1621  00:E568  8A        		txa
 1622  00:E569  60        		rts
 1623                     
 1624                     ; ----
 1625                     ; int _strcmp(char *dest [__di], char *src [__si])
 1626                     ; ----
 1627                     ; Compare strings
 1628                     ; ----
 1629                     
 1630  00:E56A  C2        _strcmp.2:	cly
 1631  00:E56B  B1 F0     .loop:		lda	[__di],y
 1632  00:E56D  D1 EE     		cmp	[__si],y
 1633  00:E56F  30 F5     		bmi	cmp_minus
 1634  00:E571  D0 EF     		bne	cmp_plus
 1635  00:E573  C9 00     		cmp	#0
 1636  00:E575  F0 E7     		beq	cmp_same
 1637  00:E577  C8        		iny
 1638  00:E578  D0 F1     		bne	.loop
 1639  00:E57A  80 E2     		bra	cmp_same
 1640                     
 1641                     ; ----
 1642                     ; int _strncmp(char *dest [__di], char *src [__si], unsigned char count [acc])
 1643                     ; ----
 1644                     ; Compare strings
 1645                     ; ----
 1646                     
 1647  00:E57C  8A        _strncmp.3:	txa
 1648  00:E57D  49 FF     		eor	#$ff
 1649  00:E57F  AA        		tax
 1650  00:E580  C2        		cly
 1651  00:E581  E8        .loop:		inx
 1652  00:E582  F0 DA     		beq	cmp_same
 1653  00:E584  B1 F0     .test:		lda	[__di],y
 1654  00:E586  D1 EE     		cmp	[__si],y
 1655  00:E588  30 DC     		bmi	cmp_minus
 1656  00:E58A  D0 D6     		bne	cmp_plus
 1657  00:E58C  C9 00     		cmp	#0
 1658  00:E58E  F0 CE     		beq	cmp_same
 1659  00:E590  C8        		iny
 1660  00:E591  D0 EE     		bne	.loop
 1661  00:E593  80 C9     		bra	cmp_same
 1662                     
 1663                     ; ----
 1664                     ; unsigned char _strlen(char *src [__si])
 1665                     ; ----
 1666                     ; Strings length
 1667                     ; ----
 1668                     
 1669  00:E595  C2        _strlen.1:	cly
 1670  00:E596  B1 EE     .loop:		lda	[__si],y
 1671  00:E598  F0 03     		beq	.done
 1672  00:E59A  C8        		iny
 1673  00:E59B  D0 F9     		bne	.loop
 1674  00:E59D  02        .done:		sxy
 1675  00:E59E  62        		cla
 1676  00:E59F  60        		rts
 1677                     
 1678                     ; ----
 1679                     
 1680  00:E5A0            ___builtin_ffs.1:
 1681                     	maplibfunc lib2____builtin_ffs.1
       00:E5A0  A8        	tay
       00:E5A1  43 20     	tma	#page(lib2____builtin_ffs.1)
       00:E5A3  48        	pha
       00:E5A4  A9 01     	lda	#bank(lib2____builtin_ffs.1)
       00:E5A6  53 20     	tam	#page(lib2____builtin_ffs.1)
       00:E5A8  98        	tya
       00:E5A9  20 55 AB  	jsr	lib2____builtin_ffs.1
       00:E5AC  A8        	tay
       00:E5AD  68        	pla
       00:E5AE  53 20     	tam	#page(lib2____builtin_ffs.1)
       00:E5B0  98        	tya
 1682  00:E5B1  60        	rts
 1683                     
 1684           0001      	.bank LIB2_BANK
 1685  01:AB55            lib2____builtin_ffs.1:
 1686  01:AB55  22        	sax
 1687  01:AB56  A0 F8     	ldy #-8
 1688  01:AB58  6A        .search_lo:	ror a
 1689  01:AB59  B0 14     	bcs .found_in_lo
 1690  01:AB5B  C8        	iny
 1691  01:AB5C  D0 FA     	bne .search_lo
 1692  01:AB5E  8A        	txa
 1693  01:AB5F  A0 F8     	ldy #-8
 1694  01:AB61  6A        .search_hi:	ror a
 1695  01:AB62  B0 05     	bcs .found_in_hi
 1696  01:AB64  C8        	iny
 1697  01:AB65  D0 FA     	bne .search_hi
 1698  01:AB67  82        	clx		; no bits set, return 0 (A is already 0)
 1699  01:AB68  60        	rts
 1700  01:AB69  98        .found_in_hi:tya		; found bit in the high byte
 1701  01:AB6A  69 10     	adc #16		; carry is set
 1702  01:AB6C  AA        	tax
 1703  01:AB6D  62        	cla		; return 17 + y
 1704  01:AB6E  60        	rts
 1705  01:AB6F  98        .found_in_lo:tya		; found bit in the low byte
 1706  01:AB70  69 08     	adc #8		; carry is set
 1707  01:AB72  AA        	tax
 1708  01:AB73  62        	cla		; return 9 + y
 1709  01:AB74  60        	rts
 1710           0000      	.bank LIB1_BANK
 1711                     
 1712  00:E5B2            _mem_mapdatabanks:
 1713  00:E5B2  A8        	tay		; y = new upper bank
 1714  00:E5B3  43 10     	tma #DATA_BANK+1; a = old upper bank
 1715  00:E5B5  42        	say		; y = old upper bank, a = new upper bank
 1716  00:E5B6  53 10     	tam #DATA_BANK+1
 1717  00:E5B8            do_mapdatabank:
 1718  00:E5B8  43 08     	tma #DATA_BANK	; a = old lower bank
 1719  00:E5BA  22        	sax		; x = old lower bank, a = new lower bank
 1720  00:E5BB  53 08     	tam #DATA_BANK
 1721  00:E5BD  98        	tya		; a = old upper bank
 1722  00:E5BE  60        	rts
 1723  00:E5BF            _mem_mapdatabank:
 1724  00:E5BF  C2        	cly
 1725  00:E5C0  80 F6     	bra do_mapdatabank
 1726                     
 1727  00:E5C2            _timer_set:
 1728  00:E5C2  8E 00 0C  	stx	timer_cnt
 1729  00:E5C5  60        	rts
 1730  00:E5C6            _timer_start:
 1731  00:E5C6  A9 01     	lda	#1
 1732  00:E5C8  8D 01 0C  	sta	timer_ctrl
 1733  00:E5CB  60        	rts
 1734  00:E5CC            _timer_stop:
 1735  00:E5CC  9C 01 0C  	stz	timer_ctrl
 1736  00:E5CF  60        	rts
 1737  00:E5D0            _timer_get:
 1738  00:E5D0  AD 00 0C  	lda	timer_cnt
 1739  00:E5D3  29 7F     	and	#$7f
 1740  00:E5D5  AA        	tax
 1741  00:E5D6  62        	cla
 1742  00:E5D7  60        	rts
 1743  00:E5D8            _irq_disable:
 1744  00:E5D8  8A        	txa
 1745  00:E5D9  78        	sei
 1746  00:E5DA  0D 02 14  	ora	irq_disable
 1747  00:E5DD  8D 02 14  	sta	irq_disable
 1748  00:E5E0  58        	cli
 1749  00:E5E1  60        	rts
 1750  00:E5E2            _irq_enable:
 1751  00:E5E2  8A        	txa
 1752  00:E5E3  49 FF     	eor	#$ff
 1753  00:E5E5  78        	sei
 1754  00:E5E6  2D 02 14  	and	irq_disable
 1755  00:E5E9  8D 02 14  	sta	irq_disable
 1756  00:E5EC  58        	cli
 1757  00:E5ED  60        	rts
 1758                     
 1759  00:E5EE            _abort:
 1760  00:E5EE  E2        	.db 0xe2
 1761                     
 1762  00:E5EF            _exit:
 1763  00:E5EF  63        	.db 0x63
 1764                     
 1765  00:E5F0            _dump_screen:
 1766  00:E5F0  33        	.db 0x33
#[2]   startup.asm
#[3]   scroll.asm
 1264                     .include "scroll.asm"
    1                     ;
    2                     ; SCROLL.ASM  -  MagicKit Scrolling Library
    3                     ;
    4                     ;
    5                     
    6                     ; [ 28] user scrolling vars
    7           2712      	.bss
    8  --:2712            scroll_xl:	.ds 4	; x       |
    9  --:2716            scroll_xh:	.ds 4	;         |
   10  --:271A            scroll_yl:	.ds 4	; y       |
   11  --:271E            scroll_yh:	.ds 4	;         | scrolling table
   12  --:2722            scroll_top:	.ds 4	; top     |
   13  --:2726            scroll_bottom:	.ds 4	; bottom  |
   14  --:272A            scroll_cr:	.ds 4	; control |
   15                     
   16                     ; [ 69] display list
   17           272E      	.bss
   18  --:272E            s_idx		.ds 1
   19  --:272F            s_xl		.ds 8
   20  --:2737            s_xh		.ds 8
   21  --:273F            s_yl		.ds 8
   22  --:2747            s_yh		.ds 8
   23  --:274F            s_cr		.ds 8
   24  --:2757            s_top		.ds 9
   25  --:2760            s_bottom	.ds 8
   26  --:2768            s_list		.ds 8
   27  --:2770            s_work		.ds 3
   28                     
   29           E5F1      	.code
   30           0001      	.bank	LIB2_BANK
   31                     ; ----
   32                     ; build_display_list
   33                     ; ----
   34                     
   35  01:AB75            build_disp_list:
   36                     	; ----
   37                     	; quick test
   38                     	;
   39  01:AB75  AD 2A 27  	lda	scroll_cr
   40  01:AB78  0D 2B 27  	ora	scroll_cr+1
   41  01:AB7B  0D 2C 27  	ora	scroll_cr+2
   42  01:AB7E  0D 2D 27  	ora	scroll_cr+3
   43  01:AB81  29 01     	and	#$01
   44  01:AB83  D0 02     	bne	.l0
   45                     	; --
   46  01:AB85  18        	clc
   47  01:AB86  60        	rts
   48                     
   49                     	; ----
   50                     	; parse user scroll list
   51                     	;
   52  01:AB87  82        .l0:	clx
   53  01:AB88  C2        	cly
   54                     	; --
   55  01:AB89  B9 2A 27  .l1:	lda	scroll_cr,Y
   56  01:AB8C  29 01     	and	#$01
   57  01:AB8E  F0 38     	beq	.l2
   58  01:AB90  B9 22 27  	lda	scroll_top,Y
   59  01:AB93  CD 0C 27  	cmp	scr_height
   60                     	bhs	.l2
       01:AB96  B0 30     	bcs	.l2
   61  01:AB98  3A        	dec a
   62  01:AB99  20 2F AC  	jsr	.check_list
   63  01:AB9C  B0 2A     	bcs	.l2
   64                     	; -- copy scanline
   65  01:AB9E  9D 57 27  	sta	s_top,X
   66  01:ABA1  B9 26 27  	lda	scroll_bottom,Y
   67  01:ABA4  9D 60 27  	sta	s_bottom,X
   68                     	; -- copy display control bits
   69  01:ABA7  B9 2A 27  	lda	scroll_cr,Y
   70  01:ABAA  29 C0     	and	#$C0
   71  01:ABAC  9D 4F 27  	sta	s_cr,X
   72                     	; -- copy bat coordinates
   73  01:ABAF  B9 12 27  	lda	scroll_xl,Y
   74  01:ABB2  9D 2F 27  	sta	s_xl,X
   75  01:ABB5  B9 16 27  	lda	scroll_xh,Y
   76  01:ABB8  9D 37 27  	sta	s_xh,X
   77  01:ABBB  B9 1A 27  	lda	scroll_yl,Y
   78  01:ABBE  9D 3F 27  	sta	s_yl,X
   79  01:ABC1  B9 1E 27  	lda	scroll_yh,Y
   80  01:ABC4  9D 47 27  	sta	s_yh,X
   81  01:ABC7  E8        	inx
   82  01:ABC8            .l2:
   83  01:ABC8  C8        	iny
   84  01:ABC9  C0 04     	cpy	#4
   85                     	blo	.l1
       01:ABCB  90 BC     	bcc	.l1
   86                     
   87                     	; ----
   88                     	; init display list
   89                     	;
   90  01:ABCD  A9 F0     	lda	#$F0
   91  01:ABCF  9D 57 27  	sta	s_top,X
   92  01:ABD2  9D 60 27  	sta	s_bottom,X
   93  01:ABD5  E8        	inx
   94  01:ABD6  8E 2E 27  	stx	s_idx
   95                     	; --
   96  01:ABD9  C2        	cly
   97  01:ABDA  62        	cla
   98  01:ABDB  99 68 27  .l3:	sta	s_list,Y
   99  01:ABDE  1A        	inc a
  100  01:ABDF  C8        	iny
  101  01:ABE0  CA        	dex
  102  01:ABE1  D0 F8     	bne	.l3
  103                     
  104                     	; ----
  105                     	; sort display list
  106                     	;
  107  01:ABE3  AD 2E 27  	lda	s_idx
  108  01:ABE6  8D 70 27  	sta	s_work
  109  01:ABE9  80 39     	bra	.t4
  110  01:ABEB            .t1:
  111  01:ABEB  9C 71 27  	stz	s_work+1
  112  01:ABEE  A0 01     	ldy	#1
  113  01:ABF0            .t2:
  114  01:ABF0  BE 67 27  	ldx	s_list-1,Y
  115  01:ABF3  BD 57 27  	lda	s_top,X
  116  01:ABF6  1A        	inc a
  117  01:ABF7  8D 72 27  	sta	s_work+2
  118  01:ABFA  BE 68 27  	ldx	s_list,Y
  119  01:ABFD  BD 57 27  	lda	s_top,X
  120  01:AC00  1A        	inc a
  121  01:AC01  CD 72 27  	cmp	s_work+2
  122                     	bhs	.t3
       01:AC04  B0 0D     	bcs	.t3
  123                     	; --
  124  01:AC06  B9 67 27  	lda	s_list-1,Y
  125  01:AC09  99 68 27  	sta	s_list,Y
  126  01:AC0C  8A        	txa
  127  01:AC0D  99 67 27  	sta	s_list-1,Y
  128  01:AC10  EE 71 27  	inc	s_work+1
  129  01:AC13            .t3:
  130  01:AC13  C8        	iny
  131  01:AC14  CC 70 27  	cpy	s_work
  132                     	blo	.t2
       01:AC17  90 D7     	bcc	.t2
  133  01:AC19  AD 71 27  	lda	s_work+1
  134  01:AC1C  F0 0A     	beq	.t5
  135  01:AC1E  CE 70 27  	dec	s_work
  136  01:AC21  AD 70 27  	lda	s_work
  137  01:AC24  C9 02     .t4:	cmp	#2
  138                     	bhs	.t1
       01:AC26  B0 C3     	bcs	.t1
  139  01:AC28            .t5:
  140                     	; ----
  141                     	; return
  142                     	;
  143  01:AC28  AD 2E 27  	lda	s_idx
  144                     	add	#$FE
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:AC2B  18        	clc
       01:AC2C  69 FE     	adc	#$FE
                          .endif
  145  01:AC2E  60        	rts
  146                     
  147                     	; ----
  148                     	; scan display list
  149                     	;
  150  01:AC2F            .check_list:
  151  01:AC2F  DA        	phx
  152  01:AC30  CA        .x1:	dex
  153  01:AC31  30 08     	bmi	.x2
  154  01:AC33  DD 57 27  	cmp	s_top,X
  155  01:AC36  D0 F8     	bne	.x1
  156  01:AC38  FA        	plx
  157  01:AC39  38        	sec
  158  01:AC3A  60        	rts
  159                     	; --
  160  01:AC3B  FA        .x2:	plx
  161  01:AC3C  18        	clc
  162  01:AC3D  60        	rts
  163                     
  164           0000      	.bank	LIB1_BANK	; restore context
#[2]   startup.asm
#[3]   math.asm
 1265                     .include "math.asm"
    1                     ;
    2                     ; MATH.ASM  -  MagicKit Standard Math Routines
    3                     ;
    4                     ;
    5                     
    6                     
    7                     ; ----
    8                     ; divu8
    9                     ; ----
   10                     ; 8-bit unsigned division
   11                     ; ----
   12                     ; OUT : _CL = _AL / _BL
   13                     ;	_DL = _AL % _BL
   14                     ; ----
   15                     
   16  00:E5F1            divu8:
   17  00:E5F1  A5 F8     	lda	<__al
   18  00:E5F3  0A        	asl a
   19  00:E5F4  85 FC     	sta	<__cl
   20  00:E5F6  62        	cla
   21  00:E5F7  A0 08     	ldy	#8
   22  00:E5F9            .l1:
   23  00:E5F9  2A        	rol a
   24  00:E5FA  C5 FA     	cmp	<__bl
   25  00:E5FC  90 02     	bcc	.l2
   26  00:E5FE  E5 FA     	sbc	<__bl
   27  00:E600            .l2:
   28  00:E600  26 FC     	rol	<__cl
   29  00:E602  88        	dey
   30  00:E603  D0 F4     	bne	.l1
   31                     
   32  00:E605  85 FE     	sta	<__dl
   33  00:E607  60        	rts
   34                     
   35                     
   36                     ; ----
   37                     ; divu10
   38                     ; ----
   39                     ; 16-bit unsigned division by 10
   40                     ; ----
   41                     ; OUT : _DX = _DX / 10
   42                     ;	A = _DX % 10
   43                     ; ----
   44                     
   45  00:E608            divu10:
   46  00:E608  A0 10     	ldy	#16
   47  00:E60A  62        	cla
   48  00:E60B  06 FE     	asl	<__dl
   49  00:E60D  26 FF     	rol	<__dh
   50  00:E60F  2A        .l1:	rol	a
   51  00:E610  C9 0A     	cmp	#10
   52                     	blo	.l2
       00:E612  90 02     	bcc	.l2
   53  00:E614  E9 0A     	sbc	#10
   54  00:E616  26 FE     .l2:	rol	<__dl
   55  00:E618  26 FF     	rol	<__dh
   56  00:E61A  88        	dey
   57  00:E61B  D0 F2     	bne	.l1
   58  00:E61D  60        	rts
   59                     
   60                     
   61           0001      .if (!CDROM)
   62                     
   63                     ; ----
   64                     ; mulu8
   65                     ; ----
   66                     ; 8-bit unsigned multiplication
   67                     ; ----
   68                     ; OUT : _CX = _AL * _BL
   69                     ; ----
   70                     
   71  00:E61E            mulu8:
   72  00:E61E  A5 FA     	lda	<__bl
   73  00:E620  85 FD     	sta	<__ch
   74                     
   75  00:E622  62        	cla
   76  00:E623  A0 08     	ldy	#8
   77  00:E625            .l1:
   78  00:E625  0A        	asl a
   79  00:E626  26 FD     	rol	<__ch
   80  00:E628  90 07     	bcc	.next
   81                     	add	<__al
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:E62A  18        	clc
       00:E62B  65 F8     	adc	<__al
                          .endif
   82  00:E62D  90 02     	bcc	.next
   83  00:E62F  E6 FD     	inc	<__ch
   84  00:E631            .next:
   85  00:E631  88        	dey
   86  00:E632  D0 F1     	bne	.l1
   87                     
   88  00:E634  85 FC     	sta	<__cl
   89  00:E636  60        	rts
   90                     
   91                     
   92                     ; ----
   93                     ; mulu16
   94                     ; ----
   95                     ; 16-bit unsigned multiplication
   96                     ; ----
   97                     ; OUT : _DX/CX = _AX * _BX
   98                     ; ----
   99                     
  100  00:E637            mulu16:
  101  00:E637  A5 F9     	lda	<__ah
  102  00:E639  05 FB     	ora	<__bh
  103  00:E63B  D0 07     	bne	.l1
  104                     
  105                     	stwz	<__dx		; 8-bit multiplication
       00:E63D  64 FE     	stz	LOW_BYTE <__dx		
       00:E63F  64 FF     	stz	HIGH_BYTE <__dx		
  106  00:E641  4C 1E E6  	jmp	mulu8
  107                     
  108                     .l1:	stw	<__bx,<__dx	; 16-bit multiplication
       00:E644  A5 FA     	lda	LOW_BYTE <__bx
       00:E646  85 FE     	sta	LOW_BYTE <__dx	
       00:E648  A5 FB     	lda	HIGH_BYTE <__bx
       00:E64A  85 FF     	sta	HIGH_BYTE <__dx	
  109                     	stwz	<__cx
       00:E64C  64 FC     	stz	LOW_BYTE <__cx
       00:E64E  64 FD     	stz	HIGH_BYTE <__cx
  110  00:E650  A0 10     	ldy	#16
  111                     
  112                     .l2:	aslw	<__cx
       00:E652  06 FC     	asl	<__cx		; word-sized value (at stated
       00:E654  26 FD     	rol	<__cx+1		; memory location)
  113                     	rolw	<__dx
       00:E656  26 FE     	rol	<__dx		; (at stated memory location)
       00:E658  26 FF     	rol	<__dx+1
  114  00:E65A  90 15     	bcc	.l3
  115                     
  116                     	addw	<__ax,<__cx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:E65C  18        	clc
       00:E65D  A5 FC     	lda	LOW_BYTE <__cx
       00:E65F  65 F8     	adc	LOW_BYTE <__ax
       00:E661  85 FC     	sta	LOW_BYTE <__cx
       00:E663  A5 FD     	lda	HIGH_BYTE <__cx
       00:E665  65 F9     	adc	HIGH_BYTE <__ax
       00:E667  85 FD     	sta	HIGH_BYTE <__cx
                          .endif
  117  00:E669  90 06     	bcc	.l3
  118                     	incw	<__dx
       00:E66B  E6 FE     	inc	<__dx		; value at stated memory
       00:E66D  D0 02     	bne	.x_00116		; location
       00:E66F  E6 FF     	inc	<__dx+1
       00:E671            .x_00116:
  119                     
  120  00:E671  88        .l3:	dey
  121  00:E672  D0 DE     	bne	.l2
  122  00:E674  60        	rts
  123                     
  124                     .endif ; (!CDROM)
  125                     
  126                     
  127                     ; ----
  128                     ; mulu32
  129                     ; ----
  130                     ; 32-bit unsigned multiplication
  131                     ; ----
  132                     ; OUT : _DX/CX = _BX/AX * _DX/CX
  133                     ; ----
  134                     
  135  00:E675            mulu32:
  136                     	stw	<__cx,<__si
       00:E675  A5 FC     	lda	LOW_BYTE <__cx
       00:E677  85 EE     	sta	LOW_BYTE <__si
       00:E679  A5 FD     	lda	HIGH_BYTE <__cx
       00:E67B  85 EF     	sta	HIGH_BYTE <__si
  137                     	stw	<__dx,<__di
       00:E67D  A5 FE     	lda	LOW_BYTE <__dx
       00:E67F  85 F0     	sta	LOW_BYTE <__di
       00:E681  A5 FF     	lda	HIGH_BYTE <__dx
       00:E683  85 F1     	sta	HIGH_BYTE <__di
  138                     	stwz	<__cx
       00:E685  64 FC     	stz	LOW_BYTE <__cx
       00:E687  64 FD     	stz	HIGH_BYTE <__cx
  139                     	stwz	<__dx
       00:E689  64 FE     	stz	LOW_BYTE <__dx
       00:E68B  64 FF     	stz	HIGH_BYTE <__dx
  140  00:E68D  A0 20     	ldy	#32
  141  00:E68F            .loop:
  142                     	aslw	<__cx
       00:E68F  06 FC     	asl	<__cx		; word-sized value (at stated
       00:E691  26 FD     	rol	<__cx+1		; memory location)
  143                     	rolw	<__dx
       00:E693  26 FE     	rol	<__dx		; (at stated memory location)
       00:E695  26 FF     	rol	<__dx+1
  144                     	rolw	<__si
       00:E697  26 EE     	rol	<__si		; (at stated memory location)
       00:E699  26 EF     	rol	<__si+1
  145                     	rolw	<__di
       00:E69B  26 F0     	rol	<__di		; (at stated memory location)
       00:E69D  26 F1     	rol	<__di+1
  146  00:E69F  90 19     	bcc	.next
  147                     
  148                     	addw	<__ax,<__cx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:E6A1  18        	clc
       00:E6A2  A5 FC     	lda	LOW_BYTE <__cx
       00:E6A4  65 F8     	adc	LOW_BYTE <__ax
       00:E6A6  85 FC     	sta	LOW_BYTE <__cx
       00:E6A8  A5 FD     	lda	HIGH_BYTE <__cx
       00:E6AA  65 F9     	adc	HIGH_BYTE <__ax
       00:E6AC  85 FD     	sta	HIGH_BYTE <__cx
                          .endif
  149                     	adcw	<__bx,<__dx
       00:E6AE  A5 FE     	lda	LOW_BYTE <__dx
       00:E6B0  65 FA     	adc	LOW_BYTE <__bx
       00:E6B2  85 FE     	sta	LOW_BYTE <__dx
       00:E6B4  A5 FF     	lda	HIGH_BYTE <__dx
       00:E6B6  65 FB     	adc	HIGH_BYTE <__bx
       00:E6B8  85 FF     	sta	HIGH_BYTE <__dx
  150  00:E6BA            .next:
  151  00:E6BA  88        	dey
  152  00:E6BB  D0 D2     	bne	.loop
  153  00:E6BD  60        	rts
  154                     
  155                     
  156                     ; ----
  157                     ; srand
  158                     ; ----
  159                     ; set random seed
  160                     ; ----
  161                     ; IN : _DX/CX = 32-bit seed
  162                     ; ----
  163                     
  164           2773      	.bss
  165  --:2773            rndptr		.ds 2
  166  --:2775            rndseed2	.ds 2
  167  --:2777            rndn1		.ds 1
  168  --:2778            rndn2		.ds 1
  169                     
  170           E6BE      	.code
  171  00:E6BE            srand:
  172                     	stw	<__cx,rndptr
       00:E6BE  A5 FC     	lda	LOW_BYTE <__cx
       00:E6C0  8D 73 27  	sta	LOW_BYTE rndptr
       00:E6C3  A5 FD     	lda	HIGH_BYTE <__cx
       00:E6C5  8D 74 27  	sta	HIGH_BYTE rndptr
  173                     	stw	<__dx,rndn1
       00:E6C8  A5 FE     	lda	LOW_BYTE <__dx
       00:E6CA  8D 77 27  	sta	LOW_BYTE rndn1
       00:E6CD  A5 FF     	lda	HIGH_BYTE <__dx
       00:E6CF  8D 78 27  	sta	HIGH_BYTE rndn1
  174  00:E6D2  AD 74 27  	lda	rndptr+1
  175  00:E6D5  09 E0     	ora	#$e0
  176  00:E6D7  8D 74 27  	sta	rndptr+1
  177  00:E6DA  C9 F4     	cmp	#$f4
  178                     	blo	.exit
       00:E6DC  90 05     	bcc	.exit
  179  00:E6DE  A9 E0     	lda	#$e0
  180  00:E6E0  8D 74 27  	sta	rndptr+1
  181  00:E6E3            .exit:
  182  00:E6E3  60        	rts
  183                     
  184                     
  185                     ; ----
  186                     ; rand
  187                     ; ----
  188                     ; return 16-bit random number
  189                     ; ----
  190                     ; OUT: _DX
  191                     ; ----
  192                     
  193           200D      	.zp
  194  --:200D            rndzp	.ds	2
  195                     
  196           E6E4      	.code
  197  00:E6E4  20 F2 E6  rand:	jsr	randomize
  198                     	stw	rndn1,<__dx
       00:E6E7  AD 77 27  	lda	LOW_BYTE rndn1
       00:E6EA  85 FE     	sta	LOW_BYTE <__dx
       00:E6EC  AD 78 27  	lda	HIGH_BYTE rndn1
       00:E6EF  85 FF     	sta	HIGH_BYTE <__dx
  199  00:E6F1  60        	rts
  200                     
  201  00:E6F2            randomize:
  202                     	stw	rndptr,<rndzp
       00:E6F2  AD 73 27  	lda	LOW_BYTE rndptr
       00:E6F5  85 0D     	sta	LOW_BYTE <rndzp
       00:E6F7  AD 74 27  	lda	HIGH_BYTE rndptr
       00:E6FA  85 0E     	sta	HIGH_BYTE <rndzp
  203                     
  204  00:E6FC  AD 77 27  	lda	rndn1	; rotate 3 bits right
  205  00:E6FF  AE 78 27  	ldx	rndn2
  206  00:E702  6A        	ror a
  207  00:E703  22        	sax
  208  00:E704  6A        	ror a
  209  00:E705  22        	sax
  210  00:E706  6A        	ror a
  211  00:E707  22        	sax
  212  00:E708  6A        	ror a
  213  00:E709  22        	sax
  214  00:E70A  6A        	ror a
  215  00:E70B  22        	sax
  216  00:E70C  6A        	ror a
  217  00:E70D  8E 77 27  	stx	rndn1
  218  00:E710  8D 78 27  	sta	rndn2
  219                     
  220                     	addw	#$05A2,rndn1 ; add #$05A2 to number
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:E713  18        	clc
       00:E714  AD 77 27  	lda	LOW_BYTE rndn1
       00:E717  69 A2     	adc	LOW_BYTE #$05A2
       00:E719  8D 77 27  	sta	LOW_BYTE rndn1
       00:E71C  AD 78 27  	lda	HIGH_BYTE rndn1
       00:E71F  69 05     	adc	HIGH_BYTE #$05A2
       00:E721  8D 78 27  	sta	HIGH_BYTE rndn1
                          .endif
  221                     
  222                     	incw	<rndzp	; eor with next 2 bytes of ROM
       00:E724  E6 0D     	inc	<rndzp			; value at stated memory
       00:E726  D0 02     	bne	.x_00133		; location
       00:E728  E6 0E     	inc	<rndzp	+1
       00:E72A            .x_00133:
  223  00:E72A  AD 78 27  	lda	rndn2
  224  00:E72D  52 0D     	eor	[rndzp]
  225  00:E72F  29 7F     	and	#$7f
  226  00:E731  8D 78 27  	sta	rndn2
  227                     
  228                     	incw	<rndzp
       00:E734  E6 0D     	inc	<rndzp		; value at stated memory
       00:E736  D0 02     	bne	.x_00134		; location
       00:E738  E6 0E     	inc	<rndzp+1
       00:E73A            .x_00134:
  229  00:E73A  AD 77 27  	lda	rndn1
  230  00:E73D  52 0D     	eor	[rndzp]
  231  00:E73F  8D 77 27  	sta	rndn1
  232                     
  233                     	incw	<rndzp		; don't use every consecutive byte
       00:E742  E6 0D     	inc	<rndzp				; value at stated memory
       00:E744  D0 02     	bne	.x_00135		; location
       00:E746  E6 0E     	inc	<rndzp		+1
       00:E748            .x_00135:
  234                     
  235  00:E748  A5 0E     	lda	<rndzp+1	; reset pointer to $e000 if > $f400
  236  00:E74A  C9 F4     	cmp	#$f4
  237                     	blo	.l1
       00:E74C  90 04     	bcc	.l1
  238  00:E74E  A9 E0     	lda	#$e0
  239  00:E750  85 0E     	sta	<rndzp+1
  240  00:E752            .l1:
  241                     	stw	<rndzp,rndptr
       00:E752  A5 0D     	lda	LOW_BYTE <rndzp
       00:E754  8D 73 27  	sta	LOW_BYTE rndptr
       00:E757  A5 0E     	lda	HIGH_BYTE <rndzp
       00:E759  8D 74 27  	sta	HIGH_BYTE rndptr
  242  00:E75C  60        	rts
  243                     
  244                     
  245                     ; ----
  246                     ; random
  247                     ; ----
  248                     ; return a random number in the interval 0 <= x < A
  249                     ; ----
  250                     ; IN :	A = range (1 - 128)
  251                     ; ----
  252                     ; OUT : A = random number
  253                     ; ----
  254                     ;
  255                     
  256  00:E75D            random:
  257  00:E75D  48        	pha
  258  00:E75E  20 E4 E6  	jsr	rand
  259  00:E761  68        	pla
  260                     	; ----
  261  00:E762  C9 80     	cmp	#128
  262                     	blo	.l1
       00:E764  90 05     	bcc	.l1
  263                     
  264  00:E766  A5 FF     	lda	<__dh
  265  00:E768  29 7F     	and	#$7f
  266  00:E76A  60        	rts
  267                     
  268  00:E76B            .l1:	; asl a
  269  00:E76B  85 F8     	sta	<__al
  270  00:E76D  A5 FE     	lda	<__dl
  271  00:E76F  85 FA     	sta	<__bl
  272  00:E771  20 1E E6  	jsr	mulu8
  273                     
  274  00:E774  A5 FD     	lda	<__ch
  275  00:E776  60        	rts
#[2]   startup.asm
 1266                     
 1267           0001      .ifdef HUC
 1268                     
#[3]   huc.asm
 1269                     .include "huc.asm"
    1                     ;
    2                     ; HUC.ASM  -  HuC Internal Library
    3                     ;
    4                     
    5                     ; ----
    6                     ; local variables
    7                     
    8           200F      		.zp
    9  --:200F            __sign:		.ds 1
   10  --:2010            __remain:	.ds 2
   11                     
   12           E777      		.code
   14                     
   15                     ; ----
   16                     ; eq
   17                     ; ----
   18                     ; test egality of two words
   19                     ; ----
   20                     ; IN :  First word on the C stack
   21                     ;	Another word in A:X
   22                     ; ----
   23                     ; OUT : word A:X equals 0 is the two args are egals
   24                     ;	else non nul
   25                     ; ----
   26                     ; REMARK : signed compatible
   27                     ; ----
   28                     
   29  00:E777            eq:
   30  00:E777  22        	sax
   31  00:E778  D2 00     	cmp [__stack]
   32  00:E77A  D0 18     	bne eq_endno
   33                     
   34  00:E77C  A0 01     	ldy #1
   35  00:E77E  22        	sax
   36  00:E77F  D1 00     	cmp [__stack],Y
   37  00:E781  D0 11     	bne eq_endno
   38                     
   39  00:E783            eq_endyes:
   40                     	__addmi	2,__stack	; don't push A/X; they are thrown away
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E783  A8        	tay			; 2
       00:E784  18        	clc			; 2
       00:E785  A5 00     	lda	<__stack			; 4
       00:E787  69 02     	adc	#low(2)	; 2
       00:E789  85 00     	sta	<__stack			; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E78B  90 02     	bcc	.x00139		; 4(2)
       00:E78D  E6 01     	inc	<__stack	+1		; 0(6)
       00:E78F            .x00139:
                          .else
                          .endif
       00:E78F  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
   41  00:E790  A2 01     	ldx #1
   42  00:E792  62        	cla
   43  00:E793  60        	rts
   44                     
   45  00:E794            eq_endno:
   46                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E794  A8        	tay			; 2
       00:E795  18        	clc			; 2
       00:E796  A5 00     	lda	<__stack		; 4
       00:E798  69 02     	adc	#low(2)	; 2
       00:E79A  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E79C  90 02     	bcc	.x00140		; 4(2)
       00:E79E  E6 01     	inc	<__stack+1		; 0(6)
       00:E7A0            .x00140:
                          .else
                          .endif
       00:E7A0  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
   47  00:E7A1  82        	clx
   48  00:E7A2  62        	cla
   49  00:E7A3  60        	rts
   50                     
   51  00:E7A4            eqb:
   52  00:E7A4  8A        	txa
   53  00:E7A5  D2 00     	cmp [__stack]
   54  00:E7A7  D0 EB     	bne eq_endno
   55  00:E7A9  80 D8     	bra eq_endyes
   56                     
   57                     ; streamlined version - uses zp ( <__temp ) instead of stack
   58                     ; returns A:X = 0 if false, 1 if true
   59                     
   60  00:E7AB            eqzp:
   61  00:E7AB  C5 03     	cmp	<__temp+1
   62  00:E7AD  D0 09     	bne	.x_ne
   63  00:E7AF  22        	sax
   64  00:E7B0  C5 02     	cmp	<__temp
   65  00:E7B2  D0 04     	bne	.x_ne
   66  00:E7B4  62        	cla
   67  00:E7B5  A2 01     	ldx	#1	; ensure Z flag not set
   68  00:E7B7  60        	rts
   69  00:E7B8            .x_ne:
   70  00:E7B8  62        	cla
   71  00:E7B9  82        	clx
   72  00:E7BA  60        	rts
   73                     
   74  00:E7BB            eqbzp:
   75  00:E7BB  8A        	txa
   76  00:E7BC  C5 02     	cmp	<__temp
   77  00:E7BE  62        	cla
   78  00:E7BF  D0 03     	bne	.x_ne
   79  00:E7C1  A2 01     	ldx	#1
   80  00:E7C3  60        	rts
   81  00:E7C4            .x_ne:
   82  00:E7C4  82        	clx
   83  00:E7C5  60        	rts
   84                     
   85                     ; ----
   86                     ; lt
   87                     ; ----
   88                     ; compare two words
   89                     ; ----
   90                     ; IN :  First word on the C stack
   91                     ;	Another word in A:X
   92                     ; ----
   93                     ; OUT : word A:X is non nul if pushed word is strictly lower than
   94                     ;	the word in A:X else nul
   95                     ; ----
   96                     
   97  00:E7C6            ltb:	; XXX: missing optimized byte version
   98  00:E7C6            lt:	; signed version
   99  00:E7C6  A0 01     	ldy #1
  100  00:E7C8  C9 80     	cmp #$80
  101  00:E7CA  B0 0A     	bcs lt_primary_minus
  102                     
  103                     	; if here, the A:X value is positive
  104                     
  105  00:E7CC  85 02     	sta <__temp
  106  00:E7CE  B1 00     	lda [__stack], Y
  107  00:E7D0  30 71     	bmi cmp_ok	; stack value is negative, so reply OK
  108                     
  109  00:E7D2  A5 02     	lda <__temp	; stack value is also positive, so just go for the unsigned version
  110  00:E7D4  80 1B     	bra ult_y1
  111                     
  112  00:E7D6            lt_primary_minus:
  113                     
  114                     	; if here, the A:X value is negative
  115                     
  116  00:E7D6  85 02     	sta <__temp
  117  00:E7D8  B1 00     	lda [__stack], Y
  118  00:E7DA  30 11     	bmi getA_ult ; stack value is also negative, so restore A val from
  119                     			; __temp and call ult
  120                     
  121  00:E7DC            cmp_false:
  122                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E7DC  A8        	tay			; 2
       00:E7DD  18        	clc			; 2
       00:E7DE  A5 00     	lda	<__stack		; 4
       00:E7E0  69 02     	adc	#low(2)	; 2
       00:E7E2  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E7E4  90 02     	bcc	.x00141		; 4(2)
       00:E7E6  E6 01     	inc	<__stack+1		; 0(6)
       00:E7E8            .x00141:
                          .else
                          .endif
       00:E7E8  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  123  00:E7E9  A2 00     	ldx	#0
  124  00:E7EB  62        	cla
  125  00:E7EC  60        	rts
  126                     
  127  00:E7ED            getA_ult:
  128  00:E7ED  A5 02     	lda <__temp
  129                     
  130  00:E7EF            ult:	; unsigned version
  131  00:E7EF  A0 01     	ldy #1	; false by default
  132                     
  133  00:E7F1            ult_y1: ; same thing but Y is assumed to be equal to 1
  134                     
  135  00:E7F1  D1 00     	cmp [__stack],Y
  136  00:E7F3  F0 04     	beq .lt_must_test_lobyte
  137  00:E7F5  B0 4C     	bcs cmp_ok
  138  00:E7F7  80 07     	bra .lt_end ; hibyte of the reg var < hibyte of the pushed var
  139                     
  140  00:E7F9            .lt_must_test_lobyte:
  141  00:E7F9  22        	sax
  142  00:E7FA  D2 00     	cmp [__stack]
  143  00:E7FC  F0 02     	beq .lt_end
  144  00:E7FE  B0 43     	bcs cmp_ok	; set result to true
  145                     	; lobyte of the reg var < lobyte of the pushed var
  146                     
  147  00:E800            .lt_end:
  148  00:E800  98        	tya		; __addmi does not preserve Y
  149                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E801  A8        	tay			; 2
       00:E802  18        	clc			; 2
       00:E803  A5 00     	lda	<__stack		; 4
       00:E805  69 02     	adc	#low(2)	; 2
       00:E807  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E809  90 02     	bcc	.x00142		; 4(2)
       00:E80B  E6 01     	inc	<__stack+1		; 0(6)
       00:E80D            .x00142:
                          .else
                          .endif
       00:E80D  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  150                     			; if Y was 1, return A=X=0 -> false
  151  00:E80E  49 FF     	eor #$ff	; if Y was 0, return A=0, X=1 -> true
  152  00:E810  1A        	inc a
  153  00:E811  1A        	inc a
  154  00:E812  AA        	tax
  155  00:E813  62        	cla
  156  00:E814  60        	rts
  157                     
  158  00:E815            ublt:	; unsigned version
  159  00:E815  8A        	txa
  160  00:E816  D2 00     	cmp [__stack]
  161  00:E818  F0 02     	beq .lt_end
  162  00:E81A  B0 27     	bcs cmp_ok	; set result to true
  163                     	; lobyte of the reg var < lobyte of the pushed var
  164                     
  165  00:E81C            .lt_end:
  166                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E81C  A8        	tay			; 2
       00:E81D  18        	clc			; 2
       00:E81E  A5 00     	lda	<__stack		; 4
       00:E820  69 02     	adc	#low(2)	; 2
       00:E822  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E824  90 02     	bcc	.x00143		; 4(2)
       00:E826  E6 01     	inc	<__stack+1		; 0(6)
       00:E828            .x00143:
                          .else
                          .endif
       00:E828  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  167  00:E829  A2 00     	ldx	#0
  168  00:E82B  62        	cla
  169  00:E82C  60        	rts
  170                     
  171                     
  172                     
  173                     ; ----
  174                     ; gt
  175                     ; ----
  176                     ; compare two words
  177                     ; ----
  178                     ; IN :  First word on the C stack
  179                     ;	Another word in A:X
  180                     ; ----
  181                     ; OUT : word A:X is non nul if pushed word is strictly greater than
  182                     ;	the word in A:X else nul
  183                     ; ----
  184                     
  185  00:E82D            gtb:	; XXX: missing optimized byte version
  186  00:E82D            gt:	; signed version of >
  187  00:E82D  A0 01     	ldy #1
  188  00:E82F  C9 80     	cmp #$80
  189  00:E831  B0 0A     	bcs .gt_primary_minus
  190                     
  191                     	; if here, the A:X value is positive
  192                     
  193  00:E833  85 02     	sta <__temp
  194  00:E835  B1 00     	lda [__stack], Y
  195  00:E837  30 A3     	bmi cmp_false ; stack value is negative, so reply False
  196                     
  197  00:E839  A5 02     	lda <__temp	; stack value is also positive, so just go for the unsigned version
  198  00:E83B  80 1B     	bra ugt_y1	; we spare one instruction, since we already have Y=1
  199                     
  200  00:E83D            .gt_primary_minus:
  201                     
  202                     	; if here, the A:X value is negative
  203                     
  204  00:E83D  85 02     	sta <__temp
  205  00:E83F  B1 00     	lda [__stack], Y
  206  00:E841  30 11     	bmi getA_ugt ; stack value is also negative, so restore A val from
  207                     			; __temp and call ugt
  208                     
  209  00:E843            cmp_ok:
  210                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E843  A8        	tay			; 2
       00:E844  18        	clc			; 2
       00:E845  A5 00     	lda	<__stack		; 4
       00:E847  69 02     	adc	#low(2)	; 2
       00:E849  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E84B  90 02     	bcc	.x00144		; 4(2)
       00:E84D  E6 01     	inc	<__stack+1		; 0(6)
       00:E84F            .x00144:
                          .else
                          .endif
       00:E84F  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  211  00:E850  A2 01     	ldx #1
  212  00:E852  62        	cla
  213  00:E853  60        	rts
  214                     
  215  00:E854            getA_ugt:	; we grab back the value of A before entering the unsigned
  216                     		; version of >
  217  00:E854  A5 02     	lda <__temp
  218                     
  219  00:E856            ugt:	; unsigned version of >
  220                     
  221  00:E856  A0 01     	ldy #1
  222                     
  223  00:E858            ugt_y1: ; unsigned version of >, assuming Y = 1
  224                     
  225  00:E858  D1 00     	cmp [__stack],Y
  226  00:E85A  F0 05     	beq .gt_must_test_lobyte
  227  00:E85C  B0 09     	bcs .gt_end ; hibyte of the reg var >= hibyte of the pushed var
  228  00:E85E  C2        	cly
  229  00:E85F  80 06     	bra .gt_end
  230                     
  231  00:E861            .gt_must_test_lobyte
  232  00:E861  22        	sax
  233  00:E862  D2 00     	cmp [__stack]
  234  00:E864  B0 01     	bcs .gt_end	; lobyte of the reg var >= lobyte of the pushed var
  235  00:E866  C2        	cly
  236                     
  237  00:E867            .gt_end:
  238  00:E867  98        	tya
  239                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E868  A8        	tay			; 2
       00:E869  18        	clc			; 2
       00:E86A  A5 00     	lda	<__stack		; 4
       00:E86C  69 02     	adc	#low(2)	; 2
       00:E86E  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E870  90 02     	bcc	.x00145		; 4(2)
       00:E872  E6 01     	inc	<__stack+1		; 0(6)
       00:E874            .x00145:
                          .else
                          .endif
       00:E874  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  240  00:E875  49 FF     	eor #$ff
  241  00:E877  1A        	inc a
  242  00:E878  1A        	inc a
  243  00:E879  AA        	tax
  244  00:E87A  62        	cla
  245  00:E87B  60        	rts
  246                     
  247  00:E87C            ubgt:	; unsigned byte version of >
  248  00:E87C  8A        	txa
  249  00:E87D  D2 00     	cmp [__stack]
  250  00:E87F  90 10     	bcc .gt_true
  251                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E881  A8        	tay			; 2
       00:E882  18        	clc			; 2
       00:E883  A5 00     	lda	<__stack		; 4
       00:E885  69 02     	adc	#low(2)	; 2
       00:E887  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E889  90 02     	bcc	.x00146		; 4(2)
       00:E88B  E6 01     	inc	<__stack+1		; 0(6)
       00:E88D            .x00146:
                          .else
                          .endif
       00:E88D  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  252  00:E88E  82        	clx
  253  00:E88F  62        	cla
  254  00:E890  60        	rts
  255  00:E891            .gt_true:
  256                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E891  A8        	tay			; 2
       00:E892  18        	clc			; 2
       00:E893  A5 00     	lda	<__stack		; 4
       00:E895  69 02     	adc	#low(2)	; 2
       00:E897  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E899  90 02     	bcc	.x00147		; 4(2)
       00:E89B  E6 01     	inc	<__stack+1		; 0(6)
       00:E89D            .x00147:
                          .else
                          .endif
       00:E89D  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  257  00:E89E  A2 01     	ldx #1
  258  00:E8A0  62        	cla
  259  00:E8A1  60        	rts
  260                     
  261                     
  262                     ; ----
  263                     ; zero page versions of lt/gt/ult/ugt:
  264                     ; ----
  265                     
  266  00:E8A2            ltbzp:
  267  00:E8A2            ltzp:	; signed, zero page
  268  00:E8A2  85 04     	sta	<__temp+2
  269  00:E8A4  45 03     	eor	<__temp+1
  270  00:E8A6  10 0B     	bpl	.geta_ult
  271  00:E8A8  A5 04     	lda	<__temp+2
  272  00:E8AA  10 03     	bpl	.true
  273  00:E8AC  82        .false:	clx
  274  00:E8AD  62        	cla
  275  00:E8AE  60        	rts
  276  00:E8AF  A2 01     .true:	ldx	#1
  277  00:E8B1  62        	cla
  278  00:E8B2  60        	rts
  279  00:E8B3            .geta_ult:
  280  00:E8B3  A5 04     	lda	<__temp+2	; and fall through to unsigned test
  281                     
  282  00:E8B5  C5 03     ultzp:	cmp	<__temp+1
  283  00:E8B7  F0 06     	beq	.test_lo
  284  00:E8B9  90 0B     	bcc	.false
  285  00:E8BB  A2 01     .true:	ldx	#1
  286  00:E8BD  62        	cla
  287  00:E8BE  60        	rts
  288  00:E8BF            .test_lo:
  289  00:E8BF  22        	sax
  290  00:E8C0  C5 02     	cmp	<__temp
  291  00:E8C2  F0 02     	beq	.false
  292  00:E8C4  B0 F5     	bcs	.true
  293  00:E8C6  82        .false:	clx
  294  00:E8C7  62        	cla
  295  00:E8C8  60        	rts
  296                     
  297  00:E8C9            ubltzp:
  298  00:E8C9  8A        	txa
  299  00:E8CA  C5 02     	cmp	<__temp
  300  00:E8CC  62        	cla
  301  00:E8CD  F0 05     	beq	.false
  302  00:E8CF  90 03     	bcc	.false
  303  00:E8D1  A2 01     	ldx	#1
  304  00:E8D3  60        	rts
  305  00:E8D4  82        .false: clx
  306  00:E8D5  60        	rts
  307                     
  308                     ; ----
  309  00:E8D6            gtbzp:
  310  00:E8D6            gtzp:	; signed, zero page
  311  00:E8D6  85 04     	sta	<__temp+2
  312  00:E8D8  45 03     	eor	<__temp+1
  313  00:E8DA  10 0B     	bpl	.geta_ugt
  314  00:E8DC  A5 04     	lda	<__temp+2
  315  00:E8DE  10 04     	bpl	.false
  316  00:E8E0  A2 01     .true:	ldx	#1
  317  00:E8E2  62        	cla
  318  00:E8E3  60        	rts
  319  00:E8E4  82        .false:	clx
  320  00:E8E5  62        	cla
  321  00:E8E6  60        	rts
  322  00:E8E7            .geta_ugt:
  323  00:E8E7  A5 04     	lda	<__temp+2	; and fall through to unsigned test
  324                     
  325  00:E8E9            ugtzp:
  326  00:E8E9  C5 03     	cmp	<__temp+1
  327  00:E8EB  F0 06     	beq	.test_lo
  328  00:E8ED  B0 0B     	bcs	.false
  329  00:E8EF  A2 01     .true:	ldx	#1
  330  00:E8F1  62        	cla
  331  00:E8F2  60        	rts
  332  00:E8F3            .test_lo:
  333  00:E8F3  22        	sax
  334  00:E8F4  C5 02     	cmp	<__temp
  335  00:E8F6  F0 02     	beq	.false
  336  00:E8F8  90 F5     	bcc	.true
  337  00:E8FA  82        .false:	clx
  338  00:E8FB  62        	cla
  339  00:E8FC  60        	rts
  340                     
  341  00:E8FD            ubgtzp:
  342  00:E8FD  8A        	txa
  343  00:E8FE  C5 02     	cmp	<__temp
  344  00:E900  62        	cla
  345  00:E901  F0 05     	beq	.false
  346  00:E903  B0 03     	bcs	.false
  347  00:E905  A2 01     	ldx	#1
  348  00:E907  60        	rts
  349  00:E908  82        .false:	clx
  350  00:E909  60        	rts
  351                     
  352                     
  353                     ; ----
  354                     ; ge
  355                     ; ----
  356                     ; compare two signed words
  357                     ; ----
  358                     ; IN :  First word on the C stack
  359                     ;	Another word in A:X
  360                     ; ----
  361                     ; OUT : word A:X is non nul if pushed word is greater or egal to
  362                     ;	the word in A:X else nul
  363                     ; ----
  364                     
  365                     ; XXX: can these be optimized?
  366  00:E90A            ge:	; signed version of >
  367  00:E90A  20 C6 E7  	jsr lt
  368  00:E90D  22        	sax
  369  00:E90E  3A        	dec a
  370  00:E90F  3A        	dec a
  371  00:E910  49 FF     	eor #$ff
  372  00:E912  22        	sax
  373  00:E913  60        	rts
  374                     
  375  00:E914            geb:	; signed byte version of >
  376  00:E914  20 C6 E7  	jsr ltb
  377  00:E917  22        	sax
  378  00:E918  3A        	dec a
  379  00:E919  3A        	dec a
  380  00:E91A  49 FF     	eor #$ff
  381  00:E91C  22        	sax
  382  00:E91D  60        	rts
  383                     
  384  00:E91E  20 A2 E8  gezp:	jsr	ltzp
  385  00:E921  22        	sax
  386  00:E922  3A        	dec a
  387  00:E923  3A        	dec a
  388  00:E924  49 FF     	eor	#$ff
  389  00:E926  22        	sax
  390  00:E927  60        	rts
  391                     
  392  00:E928  20 A2 E8  gebzp:	jsr	ltbzp
  393  00:E92B  22        	sax
  394  00:E92C  3A        	dec a
  395  00:E92D  3A        	dec a
  396  00:E92E  49 FF     	eor	#$ff
  397  00:E930  22        	sax
  398  00:E931  60        	rts
  399                     
  400                     ; ----
  401                     ; uge
  402                     ; ----
  403                     ; compare two unsigned signed words
  404                     ; ----
  405                     ; IN :  First word on the C stack
  406                     ;	Another word in A:X
  407                     ; ----
  408                     ; OUT : word A:X is non nul if pushed word is greater or egal to
  409                     ;	the word in A:X else nul
  410                     ; ----
  411                     
  412                     ; XXX: can these be optimized?
  413  00:E932            uge:	; unsigned version of >
  414  00:E932  20 EF E7  	jsr ult
  415  00:E935  22        	sax
  416  00:E936  3A        	dec a
  417  00:E937  3A        	dec a
  418  00:E938  49 FF     	eor #$ff
  419  00:E93A  22        	sax
  420  00:E93B  60        	rts
  421                     
  422  00:E93C            ubge:	; unsigned byte version of >
  423  00:E93C  20 15 E8  	jsr ublt
  424  00:E93F  22        	sax
  425  00:E940  3A        	dec a
  426  00:E941  3A        	dec a
  427  00:E942  49 FF     	eor #$ff
  428  00:E944  22        	sax
  429  00:E945  60        	rts
  430                     
  431  00:E946  20 B5 E8  ugezp:	jsr	ultzp
  432  00:E949  22        	sax
  433  00:E94A  3A        	dec a
  434  00:E94B  3A        	dec a
  435  00:E94C  49 FF     	eor	#$ff
  436  00:E94E  22        	sax
  437  00:E94F  60        	rts
  438                     
  439  00:E950  20 C9 E8  ubgezp:	jsr	ubltzp
  440  00:E953  22        	sax
  441  00:E954  3A        	dec a
  442  00:E955  3A        	dec a
  443  00:E956  49 FF     	eor	#$ff
  444  00:E958  22        	sax
  445  00:E959  60        	rts
  446                     
  447                     ; ----
  448                     ; ne
  449                     ; ----
  450                     ; compare two words
  451                     ; ----
  452                     ; IN :  First word on the C stack
  453                     ;	Another word in A:X
  454                     ; ----
  455                     ; OUT : word A:X is non null if pushed word is different from
  456                     ;	the word in A:X else null
  457                     ; ----
  458                     ; REMARK : signed compatible
  459                     ; ----
  460                     
  461                     	; previous version called 'eq' as subroutine and returned
  462                     	; opposite value; should be fully implemented for speed
  463                     	; since '!=' is such a common operator
  464  00:E95A            ne:
  465  00:E95A  22        	sax
  466  00:E95B  D2 00     	cmp [__stack]
  467  00:E95D  D0 17     	bne .ne_endne
  468                     
  469  00:E95F  A0 01     	ldy #1
  470  00:E961  22        	sax
  471  00:E962  D1 00     	cmp [__stack],Y
  472  00:E964  D0 10     	bne .ne_endne
  473                     
  474  00:E966            .ne_endeq:
  475                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E966  A8        	tay			; 2
       00:E967  18        	clc			; 2
       00:E968  A5 00     	lda	<__stack		; 4
       00:E96A  69 02     	adc	#low(2)	; 2
       00:E96C  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E96E  90 02     	bcc	.x00148		; 4(2)
       00:E970  E6 01     	inc	<__stack+1		; 0(6)
       00:E972            .x00148:
                          .else
                          .endif
       00:E972  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  476  00:E973  82        	clx
  477  00:E974  62        	cla
  478  00:E975  60        	rts
  479                     
  480  00:E976            .ne_endne:
  481                     	__addmi 2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E976  A8        	tay			; 2
       00:E977  18        	clc			; 2
       00:E978  A5 00     	lda	<__stack		; 4
       00:E97A  69 02     	adc	#low(2)	; 2
       00:E97C  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E97E  90 02     	bcc	.x00149		; 4(2)
       00:E980  E6 01     	inc	<__stack+1		; 0(6)
       00:E982            .x00149:
                          .else
                          .endif
       00:E982  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  482  00:E983  A2 01     	ldx	#1
  483  00:E985  62        	cla
  484  00:E986  60        	rts
  485                     
  486  00:E987            neb:
  487  00:E987  8A        	txa
  488  00:E988  D2 00     	cmp [__stack]
  489  00:E98A  D0 10     	bne .ne_endne
  490                     
  491  00:E98C            .ne_endeq:
  492                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E98C  A8        	tay			; 2
       00:E98D  18        	clc			; 2
       00:E98E  A5 00     	lda	<__stack		; 4
       00:E990  69 02     	adc	#low(2)	; 2
       00:E992  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E994  90 02     	bcc	.x00150		; 4(2)
       00:E996  E6 01     	inc	<__stack+1		; 0(6)
       00:E998            .x00150:
                          .else
                          .endif
       00:E998  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  493  00:E999  82        	clx
  494  00:E99A  62        	cla
  495  00:E99B  60        	rts
  496                     
  497  00:E99C            .ne_endne:
  498                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:E99C  A8        	tay			; 2
       00:E99D  18        	clc			; 2
       00:E99E  A5 00     	lda	<__stack		; 4
       00:E9A0  69 02     	adc	#low(2)	; 2
       00:E9A2  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:E9A4  90 02     	bcc	.x00151		; 4(2)
       00:E9A6  E6 01     	inc	<__stack+1		; 0(6)
       00:E9A8            .x00151:
                          .else
                          .endif
       00:E9A8  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  499  00:E9A9  A2 01     	ldx	#1
  500  00:E9AB  62        	cla
  501  00:E9AC  60        	rts
  502                     
  503                     ; streamlined version - uses zp ( <__temp ) instead of stack
  504                     ; returns A:X = 0 if false, 1 if true
  505                     
  506  00:E9AD            nezp:
  507  00:E9AD  C5 03     	cmp	<__temp+1
  508  00:E9AF  D0 08     	bne	.x_ne
  509  00:E9B1  22        	sax
  510  00:E9B2  C5 02     	cmp	<__temp
  511  00:E9B4  D0 03     	bne	.x_ne
  512  00:E9B6  62        	cla
  513  00:E9B7  82        	clx
  514  00:E9B8  60        	rts
  515  00:E9B9            .x_ne:
  516  00:E9B9  62        	cla
  517  00:E9BA  A2 01     	ldx	#1	; ensure Z flag not set
  518  00:E9BC  60        	rts
  519                     
  520  00:E9BD            nebzp:
  521  00:E9BD  8A        	txa
  522  00:E9BE  C5 02     	cmp	<__temp
  523  00:E9C0  62        	cla
  524  00:E9C1  D0 02     	bne	.x_ne
  525  00:E9C3  82        	clx
  526  00:E9C4  60        	rts
  527  00:E9C5            .x_ne:
  528  00:E9C5  A2 01     	ldx	#1	; ensure Z flag not set
  529  00:E9C7  60        	rts
  530                     
  531                     ; ----
  532                     ; le
  533                     ; ----
  534                     ; compare two signed words
  535                     ; ----
  536                     ; IN :  First word on the C stack
  537                     ;	Another word in A:X
  538                     ; ----
  539                     ; OUT : word A:X is non nul if pushed word is lower or egal to
  540                     ;	the word in A:X else nul
  541                     ; ----
  542                     
  543                     ; XXX: can these be optimized?
  544  00:E9C8            le:	; signed version
  545  00:E9C8  20 2D E8  	jsr gt
  546  00:E9CB  22        	sax
  547  00:E9CC  49 FF     	eor #$ff
  548  00:E9CE  1A        	inc a
  549  00:E9CF  1A        	inc a
  550  00:E9D0  22        	sax
  551  00:E9D1  60        	rts
  552                     
  553  00:E9D2            leb:	; signed version
  554  00:E9D2  20 2D E8  	jsr gtb
  555  00:E9D5  22        	sax
  556  00:E9D6  49 FF     	eor #$ff
  557  00:E9D8  1A        	inc a		; assuming that A=1 if true
  558  00:E9D9  1A        	inc a
  559  00:E9DA  22        	sax
  560  00:E9DB  60        	rts
  561                     
  562  00:E9DC  20 D6 E8  lezp:	jsr	gtzp
  563  00:E9DF  22        	sax
  564  00:E9E0  49 FF     	eor	#$ff
  565  00:E9E2  1A        	inc a
  566  00:E9E3  1A        	inc a
  567  00:E9E4  22        	sax
  568  00:E9E5  60        	rts
  569                     
  570  00:E9E6  20 D6 E8  lebzp:	jsr	gtbzp
  571  00:E9E9  22        	sax
  572  00:E9EA  49 FF     	eor	#$ff
  573  00:E9EC  1A        	inc a
  574  00:E9ED  1A        	inc a
  575  00:E9EE  22        	sax
  576  00:E9EF  60        	rts
  577                     
  578                     ; ----
  579                     ; ule
  580                     ; ----
  581                     ; compare two unsigned words
  582                     ; ----
  583                     ; IN :  First word on the C stack
  584                     ;	Another word in A:X
  585                     ; ----
  586                     ; OUT : word A:X is non nul if pushed word is lower or egal to
  587                     ;	the word in A:X else nul
  588                     ; ----
  589                     
  590                     ; XXX: can these be optimized?
  591  00:E9F0            ule:	; unsigned version
  592  00:E9F0  20 56 E8  	jsr ugt
  593  00:E9F3  22        	sax
  594  00:E9F4  49 FF     	eor #$ff
  595  00:E9F6  1A        	inc A	; assuming that A=1 if true
  596  00:E9F7  1A        	inc a
  597  00:E9F8  22        	sax
  598  00:E9F9  60        	rts
  599                     
  600  00:E9FA            uble:	; unsigned byte version
  601  00:E9FA  20 7C E8  	jsr ubgt
  602  00:E9FD  22        	sax
  603  00:E9FE  49 FF     	eor #$ff
  604  00:EA00  1A        	inc A	; assuming that A=255 if true
  605  00:EA01  1A        	inc a
  606  00:EA02  22        	sax
  607  00:EA03  60        	rts
  608                     
  609  00:EA04  20 E9 E8  ulezp:	jsr	ugtzp
  610  00:EA07  22        	sax
  611  00:EA08  49 FF     	eor	#$ff
  612  00:EA0A  1A        	inc a
  613  00:EA0B  1A        	inc a
  614  00:EA0C  22        	sax
  615  00:EA0D  60        	rts
  616                     
  617  00:EA0E  20 FD E8  ublezp:	jsr	ubgtzp
  618  00:EA11  22        	sax
  619  00:EA12  49 FF     	eor	#$ff
  620  00:EA14  1A        	inc a
  621  00:EA15  1A        	inc a
  622  00:EA16  22        	sax
  623  00:EA17  60        	rts
  624                     
  625                     ; ----
  626                     ; asl
  627                     ; ----
  628                     ; shift the pushed word left by the register word
  629                     ; ----
  630                     ; IN :  First word on the C stack
  631                     ;	Another word in A:X
  632                     ; ----
  633                     ; OUT : Register word egals the previous pushed value
  634                     ;	shifted left by A:X
  635                     ; ----
  636                     ; REMARK :	only the lower byte of the right operand is taken in account
  637                     ;		signed compatible
  638                     ; ----
  639  00:EA18            asl:
  640  00:EA18  86 02     	stx <__temp
  641                     	__ldwp __stack
       00:EA1A  B2 00     	lda	[__stack]
       00:EA1C  AA        	tax
       00:EA1D  A0 01     	ldy	#1
       00:EA1F  B1 00     	lda	[__stack],Y
  642  00:EA21  A4 02     	ldy <__temp
  643  00:EA23  F0 0C     	beq .asl_end
  644  00:EA25  85 02     	sta <__temp
  645  00:EA27  22        	sax
  646                     
  647  00:EA28            .asl_begin
  648  00:EA28  0A        	asl a
  649  00:EA29  26 02     	rol <__temp
  650  00:EA2B  88        	dey
  651  00:EA2C  D0 FA     	bne .asl_begin
  652                     
  653  00:EA2E  22        	sax
  654  00:EA2F  A5 02     	lda <__temp
  655                     
  656  00:EA31            .asl_end
  657                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:EA31  A8        	tay			; 2
       00:EA32  18        	clc			; 2
       00:EA33  A5 00     	lda	<__stack		; 4
       00:EA35  69 02     	adc	#low(2)	; 2
       00:EA37  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:EA39  90 02     	bcc	.x00153		; 4(2)
       00:EA3B  E6 01     	inc	<__stack+1		; 0(6)
       00:EA3D            .x00153:
                          .else
                          .endif
       00:EA3D  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  658  00:EA3E  60        	rts
  659                     
  660  00:EA3F            aslzp:
  661  00:EA3F  F0 0C     	beq .asl_end
  662  00:EA41  85 02     	sta <__temp
  663  00:EA43  22        	sax
  664                     
  665  00:EA44            .asl_begin
  666  00:EA44  0A        	asl a
  667  00:EA45  26 02     	rol <__temp
  668  00:EA47  88        	dey
  669  00:EA48  D0 FA     	bne .asl_begin
  670                     
  671  00:EA4A  22        	sax
  672  00:EA4B  A5 02     	lda <__temp
  673  00:EA4D            .asl_end
  674  00:EA4D  60        	rts
  675                     
  676                     
  677                     ; ----
  678                     ; asr
  679                     ; ----
  680                     ; shift the pushed word right by the register word
  681                     ; ----
  682                     ; IN :  First word on the C stack
  683                     ;	Another word in A:X
  684                     ; ----
  685                     ; OUT : Register word egals the previous pushed value
  686                     ;	shifted right by A:X
  687                     ; ----
  688                     ; REMARK :	only the lower byte of the right operand is taken in account
  689                     ;		signed compatible
  690                     ; ----
  691  00:EA4E            asr:
  692  00:EA4E  86 02     	stx <__temp
  693                     	__ldwp __stack
       00:EA50  B2 00     	lda	[__stack]
       00:EA52  AA        	tax
       00:EA53  A0 01     	ldy	#1
       00:EA55  B1 00     	lda	[__stack],Y
  694  00:EA57  A4 02     	ldy <__temp
  695  00:EA59  F0 0E     	beq .asr_end
  696  00:EA5B  85 02     	sta <__temp
  697  00:EA5D  22        	sax
  698                     
  699  00:EA5E            .asr_begin
  700  00:EA5E  E0 80     	cpx #$80
  701  00:EA60  66 02     	ror <__temp
  702  00:EA62  6A        	ror a
  703                     
  704  00:EA63  88        	dey
  705  00:EA64  D0 F8     	bne .asr_begin
  706                     
  707  00:EA66  22        	sax
  708  00:EA67  A5 02     	lda <__temp
  709                     
  710  00:EA69            .asr_end
  711                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:EA69  A8        	tay			; 2
       00:EA6A  18        	clc			; 2
       00:EA6B  A5 00     	lda	<__stack		; 4
       00:EA6D  69 02     	adc	#low(2)	; 2
       00:EA6F  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:EA71  90 02     	bcc	.x00155		; 4(2)
       00:EA73  E6 01     	inc	<__stack+1		; 0(6)
       00:EA75            .x00155:
                          .else
                          .endif
       00:EA75  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  712  00:EA76  60        	rts
  713                     
  714  00:EA77            asrzp:
  715  00:EA77  F0 0E     	beq .asr_end
  716  00:EA79  85 02     	sta <__temp
  717  00:EA7B  22        	sax
  718                     
  719  00:EA7C            .asr_begin
  720  00:EA7C  E0 80     	cpx #$80
  721  00:EA7E  66 02     	ror <__temp
  722  00:EA80  6A        	ror a
  723  00:EA81  88        	dey
  724  00:EA82  D0 F8     	bne .asr_begin
  725                     
  726  00:EA84  22        	sax
  727  00:EA85  A5 02     	lda <__temp
  728  00:EA87            .asr_end
  729  00:EA87  60        	rts
  730                     
  731  00:EA88            lsr:
  732  00:EA88  86 02     	stx <__temp
  733                     	__ldwp __stack
       00:EA8A  B2 00     	lda	[__stack]
       00:EA8C  AA        	tax
       00:EA8D  A0 01     	ldy	#1
       00:EA8F  B1 00     	lda	[__stack],Y
  734  00:EA91  A4 02     	ldy <__temp
  735  00:EA93  F0 0C     	beq .lsr_end
  736  00:EA95  85 02     	sta <__temp
  737  00:EA97  22        	sax
  738                     
  739  00:EA98            .lsr_begin
  740  00:EA98  46 02     	lsr <__temp
  741  00:EA9A  6A        	ror a
  742  00:EA9B  88        	dey
  743  00:EA9C  D0 FA     	bne .lsr_begin
  744                     
  745  00:EA9E  22        	sax
  746  00:EA9F  A5 02     	lda <__temp
  747                     
  748  00:EAA1            .lsr_end
  749                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:EAA1  A8        	tay			; 2
       00:EAA2  18        	clc			; 2
       00:EAA3  A5 00     	lda	<__stack		; 4
       00:EAA5  69 02     	adc	#low(2)	; 2
       00:EAA7  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:EAA9  90 02     	bcc	.x00157		; 4(2)
       00:EAAB  E6 01     	inc	<__stack+1		; 0(6)
       00:EAAD            .x00157:
                          .else
                          .endif
       00:EAAD  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  750  00:EAAE  60        	rts
  751                     
  752  00:EAAF            lsrzp:
  753  00:EAAF  F0 0C     	beq .lsr_end
  754  00:EAB1  85 02     	sta <__temp
  755  00:EAB3  22        	sax
  756                     
  757  00:EAB4            .lsr_begin
  758  00:EAB4  46 02     	lsr <__temp
  759  00:EAB6  6A        	ror a
  760  00:EAB7  88        	dey
  761  00:EAB8  D0 FA     	bne .lsr_begin
  762                     
  763  00:EABA  22        	sax
  764  00:EABB  A5 02     	lda <__temp
  765  00:EABD            .lsr_end
  766  00:EABD  60        	rts
  767                     
  768                     ; ----
  769                     ; smul
  770                     ; ----
  771                     ; multiply two SIGNED words
  772                     ; ----
  773                     ; IN :  First word on the C stack
  774                     ;	Another word in A:X
  775                     ; ----
  776                     ; OUT : Register word egals the previous pushed value
  777                     ;	multiplied by A:X
  778                     ; ----
  779                     
  780  00:EABE            smul:
  781  00:EABE  64 0F     	stz	<__sign	; until we call umul, sign keeps the sign parity
  782                     			; of operand
  783  00:EAC0  C9 80     	cmp	#$80
  784  00:EAC2  90 0D     	bcc	smul_no_invert_primary
  785                     
  786                     	__negw
       00:EAC4  22        	sax
       00:EAC5  49 FF     	eor	#$FF
       00:EAC7  18        	clc
       00:EAC8  69 01     	adc	#1
       00:EACA  22        	sax
       00:EACB  49 FF     	eor	#$FF
       00:EACD  69 00     	adc	#0
  787                     
  788  00:EACF  E6 0F     	inc	<__sign	; sign ++
  789                     
  790  00:EAD1            smul_no_invert_primary:
  791  00:EAD1  85 02     	sta	<__temp
  792  00:EAD3  A0 01     	ldy	#1
  793  00:EAD5  B1 00     	lda	[__stack],Y
  794  00:EAD7  C9 80     	cmp	#$80
  795  00:EAD9  90 1B     	bcc	smul_no_invert_secondary
  796                     
  797  00:EADB  E6 0F     	inc	<__sign	; this time, no optimisation possible, IMHO :)
  798                     			; are you sure? :))
  799  00:EADD  86 03     	stx	<__temp+1
  800                     
  801  00:EADF  B2 00     	lda	[__stack]
  802  00:EAE1  AA        	tax
  803  00:EAE2  B1 00     	lda	[__stack],Y	; we assumed Y = 1 since we set it at the
  804                     				; beginning of smul_no_invert_primary
  805                     	__negw
       00:EAE4  22        	sax
       00:EAE5  49 FF     	eor	#$FF
       00:EAE7  18        	clc
       00:EAE8  69 01     	adc	#1
       00:EAEA  22        	sax
       00:EAEB  49 FF     	eor	#$FF
       00:EAED  69 00     	adc	#0
  806  00:EAEF  91 00     	sta [__stack],Y
  807  00:EAF1  22        	sax
  808  00:EAF2  92 00     	sta [__stack]
  809                     
  810  00:EAF4  A6 03     	ldx <__temp+1
  811                     
  812  00:EAF6            smul_no_invert_secondary:
  813  00:EAF6  A5 0F     	lda <__sign
  814  00:EAF8  48        	pha
  815  00:EAF9  A5 02     	lda <__temp	; saved at the beginning of smul_no_invert_primary
  816                     			; where we're sure we passed
  817                     
  818  00:EAFB  20 13 EB  	jsr umul
  819                     
  820  00:EAFE  42        	say
  821  00:EAFF  68        	pla
  822  00:EB00  29 01     	and #$01
  823  00:EB02  F0 0D     	beq smul_end
  824                     
  825  00:EB04  42        	say
  826                     	__negw
       00:EB05  22        	sax
       00:EB06  49 FF     	eor	#$FF
       00:EB08  18        	clc
       00:EB09  69 01     	adc	#1
       00:EB0B  22        	sax
       00:EB0C  49 FF     	eor	#$FF
       00:EB0E  69 00     	adc	#0
  827  00:EB10  60        	rts
  828                     
  829  00:EB11            smul_end:
  830  00:EB11  42        	say
  831  00:EB12  60        	rts
  832                     
  833                     
  834                     ; ----
  835                     ; umul
  836                     ; ----
  837                     ; multiply two UNSIGNED words
  838                     ; ----
  839                     ; IN :  First word on the C stack
  840                     ;	Another word in A:X
  841                     ; ----
  842                     ; OUT : Register word egals the previous pushed value
  843                     ;       multiplied by A:X
  844                     ; ----
  845                     
  846  00:EB13            umul:
  847                     	__stw	<__temp+2 ; bx
       00:EB13  86 04     	stx	<__temp+2
       00:EB15  85 05     	sta	<__temp+2+1
  848                     	__ldwp	__stack
       00:EB17  B2 00     	lda	[__stack]
       00:EB19  AA        	tax
       00:EB1A  A0 01     	ldy	#1
       00:EB1C  B1 00     	lda	[__stack],Y
  849                     	__stw	<__temp   ; ax
       00:EB1E  86 02     	stx	<__temp
       00:EB20  85 03     	sta	<__temp+1
  850  00:EB22  20 37 EB  	  jsr	umul16
  851                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:EB25  A8        	tay			; 2
       00:EB26  18        	clc			; 2
       00:EB27  A5 00     	lda	<__stack		; 4
       00:EB29  69 02     	adc	#low(2)	; 2
       00:EB2B  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:EB2D  90 02     	bcc	.x00164		; 4(2)
       00:EB2F  E6 01     	inc	<__stack+1		; 0(6)
       00:EB31            .x00164:
                          .else
                          .endif
       00:EB31  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  852                     	__ldw	<__ptr
                0000      .if (1 = 2)
                          .else
       00:EB32  A6 06     	ldx	<__ptr
       00:EB34  A5 07     	lda	<__ptr+1
                          .endif
  853  00:EB36  60        	  rts
  854                     
  855  00:EB37            umul16:
  856  00:EB37  A5 05     	  lda	<__temp+3
  857  00:EB39  05 03     	  ora	<__temp+1
  858  00:EB3B  F0 21     	  beq	umul8
  859                     
  860                     	  stwz	<__ptr
       00:EB3D  64 06     	stz	LOW_BYTE <__ptr
       00:EB3F  64 07     	stz	HIGH_BYTE <__ptr
  861  00:EB41  A0 10     	  ldy	#16
  862                     
  863                     .l1:	  aslw	<__ptr
       00:EB43  06 06     	asl	<__ptr		; word-sized value (at stated
       00:EB45  26 07     	rol	<__ptr+1		; memory location)
  864                     	  aslw	<__temp+2
       00:EB47  06 04     	asl	<__temp+2		; word-sized value (at stated
       00:EB49  26 05     	rol	<__temp+2+1		; memory location)
  865  00:EB4B  90 0D     	  bcc	.l2
  866                     	  addw	<__temp,<__ptr
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:EB4D  18        	clc
       00:EB4E  A5 06     	lda	LOW_BYTE <__ptr
       00:EB50  65 02     	adc	LOW_BYTE <__temp
       00:EB52  85 06     	sta	LOW_BYTE <__ptr
       00:EB54  A5 07     	lda	HIGH_BYTE <__ptr
       00:EB56  65 03     	adc	HIGH_BYTE <__temp
       00:EB58  85 07     	sta	HIGH_BYTE <__ptr
                          .endif
  867  00:EB5A  88        .l2:	  dey
  868  00:EB5B  D0 E6     	  bne	.l1
  869                     
  870  00:EB5D  60        	  rts
  871                     
  872  00:EB5E            umul8:
  873  00:EB5E  A5 04     	  lda	<__temp+2
  874  00:EB60  85 07     	  sta	<__ptr+1
  875  00:EB62  62        	  cla
  876  00:EB63  A0 08     	  ldy	#8
  877                     
  878  00:EB65  0A        .l1:	  asl	A
  879  00:EB66  26 07     	  rol	<__ptr+1
  880  00:EB68  90 07     	  bcc	.l2
  881                     	  add	<__temp
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:EB6A  18        	clc
       00:EB6B  65 02     	adc	<__temp
                          .endif
  882  00:EB6D  90 02     	  bcc	.l2
  883  00:EB6F  E6 07     	  inc	<__ptr+1
  884  00:EB71  88        .l2:	  dey
  885  00:EB72  D0 F1     	  bne	.l1
  886                     
  887  00:EB74  85 06     	  sta	<__ptr
  888  00:EB76  60        	  rts
  889                     
  890                     
  891                     ; ----
  892                     ; sdiv
  893                     ; ----
  894                     ; divide two SIGNED words
  895                     ; ----
  896                     ; IN :  First word on the C stack
  897                     ;       Another word in A:X
  898                     ; ----
  899                     ; OUT : Register word egals the previous pushed value
  900                     ;       divided by A:X
  901                     ; ----
  902                     
  903  00:EB77            sdiv:
  904  00:EB77  64 0F     	stz	<__sign	; until we call udiv, sign keeps the sign parity
  905                     			; of operand
  906  00:EB79  C9 80     	cmp	#$80
  907  00:EB7B  90 0D     	bcc	sdiv_no_invert_primary
  908                     
  909                     	__negw
       00:EB7D  22        	sax
       00:EB7E  49 FF     	eor	#$FF
       00:EB80  18        	clc
       00:EB81  69 01     	adc	#1
       00:EB83  22        	sax
       00:EB84  49 FF     	eor	#$FF
       00:EB86  69 00     	adc	#0
  910                     
  911  00:EB88  E6 0F     	inc	<__sign	; sign ++
  912                     
  913  00:EB8A            sdiv_no_invert_primary:
  914  00:EB8A  85 02     	sta	<__temp
  915  00:EB8C  A0 01     	ldy	#1
  916  00:EB8E  B1 00     	lda	[__stack],Y
  917  00:EB90  C9 80     	cmp	#$80
  918  00:EB92  90 1B     	bcc	sdiv_no_invert_secondary
  919                     
  920  00:EB94  E6 0F     	inc	<__sign
  921                     
  922  00:EB96  86 03     	stx	<__temp+1
  923                     
  924  00:EB98  B2 00     	lda	[__stack]
  925  00:EB9A  AA        	tax
  926  00:EB9B  B1 00     	lda	[__stack],Y	; we assumed Y = 1 since we set it at the beginning of
  927                     				; sdiv_no_invert_primary
  928                     	__negw
       00:EB9D  22        	sax
       00:EB9E  49 FF     	eor	#$FF
       00:EBA0  18        	clc
       00:EBA1  69 01     	adc	#1
       00:EBA3  22        	sax
       00:EBA4  49 FF     	eor	#$FF
       00:EBA6  69 00     	adc	#0
  929  00:EBA8  91 00     	sta	[__stack],Y
  930  00:EBAA  22        	sax
  931  00:EBAB  92 00     	sta	[__stack]
  932                     
  933  00:EBAD  A6 03     	ldx	<__temp+1
  934                     
  935  00:EBAF            sdiv_no_invert_secondary:
  936  00:EBAF  A5 0F     	lda	<__sign
  937  00:EBB1  48        	pha
  938  00:EBB2  A5 02     	lda	<__temp	; saved at the beginning of sdiv_no_invert_primary
  939                     			; where we're sure we passed
  940  00:EBB4  20 CC EB  	jsr	udiv
  941                     
  942  00:EBB7  42        	say
  943  00:EBB8  68        	pla
  944  00:EBB9  29 01     	and	#$01
  945  00:EBBB  F0 0D     	beq	sdiv_end
  946                     
  947  00:EBBD  42        	say
  948                     	__negw
       00:EBBE  22        	sax
       00:EBBF  49 FF     	eor	#$FF
       00:EBC1  18        	clc
       00:EBC2  69 01     	adc	#1
       00:EBC4  22        	sax
       00:EBC5  49 FF     	eor	#$FF
       00:EBC7  69 00     	adc	#0
  949  00:EBC9  60        	rts
  950                     
  951  00:EBCA            sdiv_end:
  952  00:EBCA  42        	say
  953  00:EBCB  60        	rts
  954                     
  955                     
  956                     ; ----
  957                     ; udiv
  958                     ; ----
  959                     ; divide two UNSIGNED words
  960                     ; ----
  961                     ; IN :  First word on the C stack
  962                     ;       Another word in A:X
  963                     ; ----
  964                     ; OUT : Register word egals the previous pushed value
  965                     ;       divided by A:X
  966                     ; ----
  967                     
  968  00:EBCC            udiv:
  969                     	__stw	<__ptr
       00:EBCC  86 06     	stx	<__ptr
       00:EBCE  85 07     	sta	<__ptr+1
  970                     	__ldwp	__stack
       00:EBD0  B2 00     	lda	[__stack]
       00:EBD2  AA        	tax
       00:EBD3  A0 01     	ldy	#1
       00:EBD5  B1 00     	lda	[__stack],Y
  971                     	__stw	<__temp
       00:EBD7  86 02     	stx	<__temp
       00:EBD9  85 03     	sta	<__temp+1
  972                     
  973  00:EBDB  A9 00     	lda	#0
  974  00:EBDD  85 11     	sta	<__remain+1
  975  00:EBDF  A0 10     	ldy	#16
  976  00:EBE1  06 02     .sdiv_begin:	asl	<__temp
  977  00:EBE3  26 03     	rol	<__temp+1
  978  00:EBE5  2A        	rol	a
  979  00:EBE6  26 11     	rol	<__remain+1
  980  00:EBE8  48        	pha
  981  00:EBE9  C5 06     	cmp	<__ptr
  982  00:EBEB  A5 11     	lda	<__remain+1
  983  00:EBED  E5 07     	sbc	<__ptr+1
  984  00:EBEF  90 08     	bcc	.sdiv_end
  985  00:EBF1  85 11     	sta	<__remain+1
  986  00:EBF3  68        	pla
  987  00:EBF4  E5 06     	sbc	<__ptr
  988  00:EBF6  48        	pha
  989  00:EBF7  E6 02     	inc	<__temp
  990  00:EBF9  68        .sdiv_end:	pla
  991  00:EBFA  88        	dey
  992  00:EBFB  D0 E4     	bne	.sdiv_begin
  993  00:EBFD  85 10     	sta	<__remain
  994                     
  995                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:EBFF  A8        	tay			; 2
       00:EC00  18        	clc			; 2
       00:EC01  A5 00     	lda	<__stack		; 4
       00:EC03  69 02     	adc	#low(2)	; 2
       00:EC05  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:EC07  90 02     	bcc	.x00177		; 4(2)
       00:EC09  E6 01     	inc	<__stack+1		; 0(6)
       00:EC0B            .x00177:
                          .else
                          .endif
       00:EC0B  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  996                     	__ldw	<__temp
                0000      .if (1 = 2)
                          .else
       00:EC0C  A6 02     	ldx	<__temp
       00:EC0E  A5 03     	lda	<__temp+1
                          .endif
  997                     
  998  00:EC10  60        	rts
  999                     
 1000                     
 1001                     ; ----
 1002                     ; smod
 1003                     ; ----
 1004                     ; give the integer remainder of the two words
 1005                     ; ----
 1006                     ; IN :  First word on the C stack
 1007                     ;       Another word in A:X
 1008                     ; ----
 1009                     ; OUT : Register word egals the remainder of the division of the
 1010                     ;       pushed value by A:X
 1011                     ; ----
 1012                     
 1013  00:EC11            smod:
 1014  00:EC11  64 0F     	stz	<__sign
 1015                     	__stw	<__ptr
       00:EC13  86 06     	stx	<__ptr
       00:EC15  85 07     	sta	<__ptr+1
 1016                     	__ldwp	__stack
       00:EC17  B2 00     	lda	[__stack]
       00:EC19  AA        	tax
       00:EC1A  A0 01     	ldy	#1
       00:EC1C  B1 00     	lda	[__stack],Y
 1017  00:EC1E  C9 80     	cmp	#$80
 1018  00:EC20  90 15     	bcc	.skip1
 1019  00:EC22  E6 0F     	inc	<__sign
 1020                     	__negw
       00:EC24  22        	sax
       00:EC25  49 FF     	eor	#$FF
       00:EC27  18        	clc
       00:EC28  69 01     	adc	#1
       00:EC2A  22        	sax
       00:EC2B  49 FF     	eor	#$FF
       00:EC2D  69 00     	adc	#0
 1021                     	__stwp	__stack
       00:EC2F  22        	sax
       00:EC30  92 00     	sta	[__stack]
       00:EC32  22        	sax
       00:EC33  A0 01     	ldy	#1
       00:EC35  91 00     	sta	[__stack],Y
 1022                     .skip1:	__ldw	<__ptr
                0000      .if (1 = 2)
                          .else
       00:EC37  A6 06     	ldx	<__ptr
       00:EC39  A5 07     	lda	<__ptr+1
                          .endif
 1023  00:EC3B  C9 80     	cmp	#$80
 1024  00:EC3D  90 0B     	bcc	.skip2
 1025                     	__negw
       00:EC3F  22        	sax
       00:EC40  49 FF     	eor	#$FF
       00:EC42  18        	clc
       00:EC43  69 01     	adc	#1
       00:EC45  22        	sax
       00:EC46  49 FF     	eor	#$FF
       00:EC48  69 00     	adc	#0
 1026  00:EC4A  20 5D EC  .skip2:	jsr	umod
 1027  00:EC4D  A4 0F     	ldy	<__sign
 1028  00:EC4F  F0 0B     	beq	.noinv
 1029                     	__negw
       00:EC51  22        	sax
       00:EC52  49 FF     	eor	#$FF
       00:EC54  18        	clc
       00:EC55  69 01     	adc	#1
       00:EC57  22        	sax
       00:EC58  49 FF     	eor	#$FF
       00:EC5A  69 00     	adc	#0
 1030  00:EC5C  60        .noinv:	rts
 1031                     
 1032  00:EC5D            umod:
 1033                     	__stw	<__ptr
       00:EC5D  86 06     	stx	<__ptr
       00:EC5F  85 07     	sta	<__ptr+1
 1034                     	__ldwp	__stack
       00:EC61  B2 00     	lda	[__stack]
       00:EC63  AA        	tax
       00:EC64  A0 01     	ldy	#1
       00:EC66  B1 00     	lda	[__stack],Y
 1035                     	__stw	<__temp
       00:EC68  86 02     	stx	<__temp
       00:EC6A  85 03     	sta	<__temp+1
 1036                     
 1037  00:EC6C  A9 00     	lda	#0
 1038  00:EC6E  85 11     	sta	<__remain+1
 1039  00:EC70  A0 10     	ldy	#16
 1040  00:EC72  06 02     .umod_begin:	asl	<__temp
 1041  00:EC74  26 03     	rol	<__temp+1
 1042  00:EC76  2A        	rol	a
 1043  00:EC77  26 11     	rol	<__remain+1
 1044  00:EC79  48        	pha
 1045  00:EC7A  C5 06     	cmp	<__ptr
 1046  00:EC7C  A5 11     	lda	<__remain+1
 1047  00:EC7E  E5 07     	sbc	<__ptr+1
 1048  00:EC80  90 08     	bcc	.umod_end
 1049  00:EC82  85 11     	sta	<__remain+1
 1050  00:EC84  68        	pla
 1051  00:EC85  E5 06     	sbc	<__ptr
 1052  00:EC87  48        	pha
 1053  00:EC88  E6 02     	inc	<__temp
 1054  00:EC8A  68        .umod_end:	pla
 1055  00:EC8B  88        	dey
 1056  00:EC8C  D0 E4     	bne	.umod_begin
 1057  00:EC8E  85 10     	sta	<__remain
 1058                     
 1059                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:EC90  A8        	tay			; 2
       00:EC91  18        	clc			; 2
       00:EC92  A5 00     	lda	<__stack		; 4
       00:EC94  69 02     	adc	#low(2)	; 2
       00:EC96  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:EC98  90 02     	bcc	.x00189		; 4(2)
       00:EC9A  E6 01     	inc	<__stack+1		; 0(6)
       00:EC9C            .x00189:
                          .else
                          .endif
       00:EC9C  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
 1060                     	__ldw	<__remain
                0000      .if (1 = 2)
                          .else
       00:EC9D  A6 10     	ldx	<__remain
       00:EC9F  A5 11     	lda	<__remain+1
                          .endif
 1061                     
 1062  00:ECA1  60        	rts
 1063                     
 1064                     ; ----
 1065                     ; ___case
 1066                     ; ----
 1067                     ; implement a switch instruction in C
 1068                     ; ----
 1069                     ; IN :  primary register (A:X) contain the discriminant value
 1070                     ;       i.e. the one that will be checked against those indicated in the
 1071                     ;       various case instructions
 1072                     ;       On the stack, a pointer is passed
 1073                     ;       This is a pointer toward an array
 1074                     ;       Each item of this array is a 4 bytes long structure
 1075                     ;       The structure is the following :
 1076                     ;         WORD value_to_check
 1077                     ;         WORD label_to_jump_to
 1078                     ;       We have to parse the whole array in order to compare the primary
 1079                     ;       register with all the 'value_to_check' field. If we ever find that
 1080                     ;       the primary register is egal to such a value, we must jump to the
 1081                     ;       corresponding 'label_to_jump_to'.
 1082                     ;       The default value (which also means that we reached the end of the
 1083                     ;       array) can be recognized with its 'label_to_jump_to' field set to 0.
 1084                     ;       Then the 'value_to_check' field become the default label we have to
 1085                     ;       use for the rest of the execution.
 1086                     ; ----
 1087                     ; OUT : The execution goes to another place
 1088                     ; ----
 1089                     ; REMARK : Also use remain variable as a temporary value
 1090                     ; ----
 1091                     
 1092  00:ECA2            ___case:
 1093                     	__stw	<__remain		; store the value to check to
       00:ECA2  86 10     	stx	<__remain		
       00:ECA4  85 11     	sta	<__remain		+1
 1094                     	__ldwp	__stack
       00:ECA6  B2 00     	lda	[__stack]
       00:ECA8  AA        	tax
       00:ECA9  A0 01     	ldy	#1
       00:ECAB  B1 00     	lda	[__stack],Y
 1095                     	__stw	<__ptr		; __ptr contain the address of the array
       00:ECAD  86 06     	stx	<__ptr		
       00:ECAF  85 07     	sta	<__ptr		+1
 1096                     
 1097                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:ECB1  A8        	tay			; 2
       00:ECB2  18        	clc			; 2
       00:ECB3  A5 00     	lda	<__stack		; 4
       00:ECB5  69 02     	adc	#low(2)	; 2
       00:ECB7  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:ECB9  90 02     	bcc	.x00194		; 4(2)
       00:ECBB  E6 01     	inc	<__stack+1		; 0(6)
       00:ECBD            .x00194:
                          .else
                          .endif
       00:ECBD  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
 1098                     
 1099  00:ECBE  C2        	cly
 1100  00:ECBF  80 02     	bra	.begin_case
 1101                     
 1102  00:ECC1            .next_case_lo:
 1103  00:ECC1  C8        	iny
 1104  00:ECC2            .next_case_hi:
 1105  00:ECC2  C8        	iny
 1106  00:ECC3            .begin_case:
 1107  00:ECC3  C8        	iny			; skip func lo-byte
 1108  00:ECC4  B1 06     	lda	[__ptr],y	; test func hi-byte
 1109  00:ECC6  F0 1C     	beq	.case_default
 1110  00:ECC8  C8        	iny
 1111  00:ECC9  B1 06     	lda	[__ptr],y
 1112  00:ECCB  C5 10     	cmp	<__remain+0
 1113  00:ECCD  D0 F2     	bne	.next_case_lo
 1114  00:ECCF  C8        	iny
 1115  00:ECD0  B1 06     	lda	[__ptr],y
 1116  00:ECD2  C5 11     	cmp	<__remain+1
 1117  00:ECD4  D0 EC     	bne	.next_case_hi
 1118  00:ECD6  88        	dey			; found match
 1119  00:ECD7  88        	dey
 1120  00:ECD8            .case_vector:
 1121  00:ECD8  B1 06     	lda	[__ptr],y	; read func hi-byte
 1122  00:ECDA  85 03     	sta	<__temp+1
 1123  00:ECDC  88        	dey
 1124  00:ECDD  B1 06     	lda	[__ptr],y	; read func lo-byte
 1125  00:ECDF  85 02     	sta	<__temp+0
 1126  00:ECE1  6C 02 20  	jmp	[__temp]
 1127  00:ECE4            .case_default:
 1128  00:ECE4  C8        	iny
 1129  00:ECE5  C8        	iny
 1130  00:ECE6  80 F0     	bra	.case_vector
 1131                     
 1132                     
 1133                     ; ----
 1134                     ; hook
 1135                     ; ----
 1136                     ; indirect call to sub-routine
 1137                     ; ----
 1138                     ; IN :  sub-routine addr in __ptr
 1139                     ; ----
 1140                     
 1141  00:ECE8            hook:
 1142  00:ECE8  6C 06 20  	jmp	[__ptr]
 1143                     
 1144                     ; ----
 1145                     ; setvdc
 1146                     ; ----
 1147                     ; set a vdc register
 1148                     ; ----
 1149                     ; IN : - reg index on the C stack
 1150                     ;      - value in A:X
 1151                     ; ----
 1152                     
 1153  00:ECEB  A8        setvdc:	tay
 1154  00:ECEC  B2 00     	lda	[__sp]
 1155  00:ECEE  4A        	lsr	a
 1156  00:ECEF  C9 09     	cmp	#$09
 1157  00:ECF1  F0 19     	beq	.l3
 1158                     
 1159  00:ECF3  85 F7     .l1:	sta	<vdc_reg
 1160  00:ECF5  8D 00 00  	sta	video_reg
 1161  00:ECF8  8E 02 00  	stx	video_data_l
 1162  00:ECFB  8C 03 00  	sty	video_data_h
 1163                     .l2:	__addmi	2,__sp
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:ECFE  A8        	tay			; 2
       00:ECFF  18        	clc			; 2
       00:ED00  A5 00     	lda	<__sp		; 4
       00:ED02  69 02     	adc	#low(2)	; 2
       00:ED04  85 00     	sta	<__sp		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:ED06  90 02     	bcc	.x00195		; 4(2)
       00:ED08  E6 01     	inc	<__sp+1		; 0(6)
       00:ED0A            .x00195:
                          .else
                          .endif
       00:ED0A  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
 1164  00:ED0B  60        	rts
 1165                     	; -- reg $09
 1166  00:ED0C  8A        .l3:	txa
 1167  00:ED0D  29 70     	and	#$70
 1168  00:ED0F  4A        	lsr	A
 1169  00:ED10  4A        	lsr	A
 1170  00:ED11  4A        	lsr	A
 1171  00:ED12  4A        	lsr	A
 1172  00:ED13  20 62 E4  	jsr	set_bat_size
 1173  00:ED16  80 E6     	bra	.l2
 1174                     
 1175                     ; ----
 1176                     ; getvdc
 1177                     ; ----
 1178                     ; get vdc register content
 1179                     ; ----
 1180                     ; IN : reg index in A:X
 1181                     ; ----
 1182                     ; OUT: vdc register in A:X
 1183                     ; ----
 1184                     
 1185  00:ED18  E0 04     getvdc:	cpx	#4
 1186  00:ED1A  D0 0E     	bne	.l1
 1187  00:ED1C  A9 02     	lda	#2
 1188  00:ED1E  85 F7     	sta	<vdc_reg
 1189  00:ED20  8D 00 00  	sta	video_reg
 1190  00:ED23  AE 02 00  	ldx	video_data_l
 1191  00:ED26  AD 03 00  	lda	video_data_h
 1192  00:ED29  60        	rts
 1193  00:ED2A  82        .l1:    clx
 1194  00:ED2B  62        	cla
 1195  00:ED2C  60        	rts
#[2]   startup.asm
#[3]   huc_gfx.asm
 1270                     .include "huc_gfx.asm"
    1                     ;
    2                     ; HUC_GFX.ASM  -  HuC Graphic Library
    3                     ;
    4                     
    5                     ; ----
    6                     ; local variables
    7                     
    8           2012      	.zp
    9  --:2012            spr_ptr		.ds 2
   10  --:2014            spr_max		.ds 1
   11  --:2015            spr_flag	.ds 1
   12                     
   13           2779      	.bss
   14  --:2779            _font_base	.ds 2
   15  --:277B            font_color	.ds 2
   16  --:277D            satb		.ds 512	; the local SATB
   17                     
   18  --:297D            gfx_pal		.ds 1
   19                     
   20  --:297E            line_currx	.ds 2
   21  --:2980            line_curry	.ds 2
   22  --:2982            line_deltax	.ds 2
   23  --:2984            line_deltay	.ds 2
   24  --:2986            line_error	.ds 2
   25  --:2988            line_adjust	.ds 2
   26  --:298A            line_xdir	.ds 1
   27  --:298B            line_color	.ds 1
   28                     
   29                     
   30                     ; ----
   31                     ; library code
   32                     
   33           ED2D      	 .code
   34                     
   35                     ; cls(int val [__dx])
   36                     ; ----
   37                     
   38  00:ED2D            _cls:
   39                     	stw	_font_base,<__dx
       00:ED2D  AD 79 27  	lda	LOW_BYTE _font_base
       00:ED30  85 FE     	sta	LOW_BYTE <__dx
       00:ED32  AD 7A 27  	lda	HIGH_BYTE _font_base
       00:ED35  85 FF     	sta	HIGH_BYTE <__dx
   40  00:ED37            _cls.1:
   41                     	setvwaddr $0
                          	stw	#$0,<__di
       00:ED37  A9 00     	lda	LOW_BYTE #$0
       00:ED39  85 F0     	sta	LOW_BYTE <__di
       00:ED3B  A9 00     	lda	HIGH_BYTE #$0
       00:ED3D  85 F1     	sta	HIGH_BYTE <__di
       00:ED3F  20 02 E4  	jsr	set_write
   42                     	; --
   43  00:ED42  AC 08 27  	ldy	bat_height
   44  00:ED45  AE 06 27  .l2:	ldx	bat_width
   45                     	; --
   46                     .l3:	stw	<__dx,video_data
       00:ED48  A5 FE     	lda	LOW_BYTE <__dx
       00:ED4A  8D 02 00  	sta	LOW_BYTE video_data
       00:ED4D  A5 FF     	lda	HIGH_BYTE <__dx
       00:ED4F  8D 03 00  	sta	HIGH_BYTE video_data
   47  00:ED52  CA        	dex
   48  00:ED53  D0 F3     	bne	.l3
   49  00:ED55  88        	dey
   50  00:ED56  D0 ED     	bne	.l2
   51  00:ED58  60        	rts
   52                     
   53                     ; set_font_pal(int pal)
   54                     ; ----
   55                     
   56  00:ED59            _set_font_pal:
   57  00:ED59  8A        	txa
   58  00:ED5A  0A        	asl	A
   59  00:ED5B  0A        	asl	A
   60  00:ED5C  0A        	asl	A
   61  00:ED5D  0A        	asl	A
   62  00:ED5E  85 02     	sta	<__temp
   63  00:ED60  AD 7A 27  	lda	_font_base+1
   64  00:ED63  29 0F     	and	#$0F
   65  00:ED65  05 02     	ora	<__temp
   66  00:ED67  8D 7A 27  	sta	_font_base+1
   67  00:ED6A  60        	rts
   68                     
   69                     ; set_font_color(char color, char bg)
   70                     ; ----
   71                     
   72  00:ED6B            _set_font_color.2:
   73  00:ED6B  8A        	txa
   74  00:ED6C  29 0F     	and	#$F
   75  00:ED6E  8D 7C 27  	sta	font_color+1
   76  00:ED71  A5 F8     	lda	<__al
   77  00:ED73  29 0F     	and	#$F
   78  00:ED75  8D 7B 27  	sta	font_color
   79  00:ED78  60        	rts
   80                     
   81                     ; set_font_addr(int addr)
   82                     ; ----
   83                     
   84  00:ED79            _set_font_addr:
   85                     	; --
   86  00:ED79  8E 79 27  	stx	_font_base
   87  00:ED7C  4A        	lsr	A
   88  00:ED7D  6E 79 27  	ror	_font_base
   89  00:ED80  4A        	lsr	A
   90  00:ED81  6E 79 27  	ror	_font_base
   91  00:ED84  4A        	lsr	A
   92  00:ED85  6E 79 27  	ror	_font_base
   93  00:ED88  4A        	lsr	A
   94  00:ED89  6E 79 27  	ror	_font_base
   95  00:ED8C  85 F8     	sta	<__al
   96                     	; --
   97  00:ED8E  AD 7A 27  	lda	_font_base+1
   98  00:ED91  29 F0     	and	#$F0
   99  00:ED93  05 F8     	ora	<__al
  100  00:ED95  8D 7A 27  	sta	_font_base+1
  101  00:ED98  60        	rts
  102                     
  103                     ; get_font_pal()
  104                     ; ----
  105                     
  106  00:ED99            _get_font_pal:
  107  00:ED99  AD 7A 27  	lda	_font_base+1
  108  00:ED9C  4A        	lsr	A
  109  00:ED9D  4A        	lsr	A
  110  00:ED9E  4A        	lsr	A
  111  00:ED9F  4A        	lsr	A
  112  00:EDA0  82        	clx
  113  00:EDA1  22        	sax
  114  00:EDA2  60        	rts
  115                     
  116                     ; get_font_addr()
  117                     ; ----
  118                     
  119  00:EDA3            _get_font_addr:
  120                     	; --
  121  00:EDA3  AD 7A 27  	lda	_font_base+1
  122  00:EDA6  85 F8     	sta	<__al
  123  00:EDA8  AD 79 27  	lda	_font_base
  124  00:EDAB  0A        	asl	A
  125  00:EDAC  26 F8     	rol	<__al
  126  00:EDAE  0A        	asl	A
  127  00:EDAF  26 F8     	rol	<__al
  128  00:EDB1  0A        	asl	A
  129  00:EDB2  26 F8     	rol	<__al
  130  00:EDB4  0A        	asl	A
  131  00:EDB5  26 F8     	rol	<__al
  132  00:EDB7  A6 F8     	ldx	<__al
  133  00:EDB9  22        	sax
  134  00:EDBA  60        	rts
  135                     
  136                     ; load_default_font(char num [__dl], int addr [__di])
  137                     ; ----
  138                     
  139  00:EDBB            _load_default_font:
  140                     	; --
  141  00:EDBB  64 FE     	stz	<__dl
  142                     
  143  00:EDBD            _load_default_font.1:
  144                     	; --
  145  00:EDBD  A2 FF     	ldx	#$FF
  146  00:EDBF  A9 FF     	lda	#$FF
  147  00:EDC1  20 19 E4  	jsr	calc_vram_addr
  148                     	incw	<__di
       00:EDC4  E6 F0     	inc	<__di		; value at stated memory
       00:EDC6  D0 02     	bne	.x_00200		; location
       00:EDC8  E6 F1     	inc	<__di+1
       00:EDCA            .x_00200:
  149                     
  150  00:EDCA            _load_default_font.2:
  151                     	; --
  152  00:EDCA  A5 F0     	lda	<__di
  153  00:EDCC  05 F1     	ora	<__di+1
  154  00:EDCE  D0 09     	bne	.l1
  155  00:EDD0  20 A3 ED  	jsr	_get_font_addr
  156                     	__stw	<__di
       00:EDD3  86 F0     	stx	<__di
       00:EDD5  85 F1     	sta	<__di+1
  157  00:EDD7  80 07     	bra	.l2
  158                     	; --
  159                     .l1:	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:EDD9  A6 F0     	ldx	<__di
       00:EDDB  A5 F1     	lda	<__di+1
                          .endif
  160  00:EDDD  20 79 ED  	jsr	_set_font_addr
  161                     	; --
  162                     .l2:	stb	#FONT_BANK+_bank_base,<__bl
       00:EDE0  A9 01     	lda	#FONT_BANK+_bank_base
       00:EDE2  85 FA     	sta	<__bl
  163                     	stb	#96,<__cl
       00:EDE4  A9 60     	lda	#96
       00:EDE6  85 FC     	sta	<__cl
  164                     	stb	font_color+1,<__ah
       00:EDE8  AD 7C 27  	lda	font_color+1
       00:EDEB  85 F9     	sta	<__ah
  165  00:EDED  AD 7B 27  	lda	font_color
  166  00:EDF0  D0 01     	bne	.l3
  167  00:EDF2  1A        	inc	A
  168  00:EDF3  85 F8     .l3:	sta	<__al
  169  00:EDF5  A5 FE     	lda	<__dl
  170  00:EDF7  29 03     	and	#$03
  171  00:EDF9  0A        	asl	A
  172  00:EDFA  AA        	tax
  173  00:EDFB  BD CC E2  	lda	font_table,X
  174  00:EDFE  85 EE     	sta	<__si
  175  00:EE00  E8        	inx
  176  00:EE01  BD CC E2  	lda	font_table,X
  177  00:EE04  85 EF     	sta	<__si+1
  178  00:EE06  4C 75 E3  	jmp	load_font
  179                     
  180                     ; load_font(farptr font [__bl:__si], char nb [__cl], int addr [__di])
  181                     ; ----
  182                     
  183  00:EE09            _load_font.2:
  184                     	; --
  185  00:EE09  A2 FF     	ldx	#$FF
  186  00:EE0B  A9 FF     	lda	#$FF
  187  00:EE0D  20 19 E4  	jsr	calc_vram_addr
  188                     	incw	<__di
       00:EE10  E6 F0     	inc	<__di		; value at stated memory
       00:EE12  D0 02     	bne	.x_00206		; location
       00:EE14  E6 F1     	inc	<__di+1
       00:EE16            .x_00206:
  189                     
  190  00:EE16            _load_font.3:
  191                     	; --
  192  00:EE16  A5 F0     	lda	<__di
  193  00:EE18  05 F1     	ora	<__di+1
  194  00:EE1A  D0 09     	bne	.l1
  195  00:EE1C  20 A3 ED  	jsr	_get_font_addr
  196                     	__stw	<__di
       00:EE1F  86 F0     	stx	<__di
       00:EE21  85 F1     	sta	<__di+1
  197  00:EE23  80 07     	bra	.l2
  198                     	; --
  199                     .l1:	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:EE25  A6 F0     	ldx	<__di
       00:EE27  A5 F1     	lda	<__di+1
                          .endif
  200  00:EE29  20 79 ED  	jsr	_set_font_addr
  201                     	; --
  202  00:EE2C  A5 FC     .l2:	lda	<__cl
  203  00:EE2E  64 FD     	stz	<__ch
  204  00:EE30  0A        	asl	A
  205  00:EE31  26 FD     	rol	<__ch
  206  00:EE33  0A        	asl	A
  207  00:EE34  26 FD     	rol	<__ch
  208  00:EE36  0A        	asl	A
  209  00:EE37  26 FD     	rol	<__ch
  210  00:EE39  0A        	asl	A
  211  00:EE3A  26 FD     	rol	<__ch
  212  00:EE3C  85 FC     	sta	<__cl
  213  00:EE3E  4C 87 E3  	jmp	load_vram
  214                     
  215                     ; put_digit(char digit, int offset)
  216                     ; put_digit(char digit, char x, char y)
  217                     ; ----
  218                     
  219  00:EE41            _put_digit.3:
  220  00:EE41  A5 FC     	lda	<__cl
  221  00:EE43  20 64 EE  	jsr	_put.xy
  222  00:EE46  80 03     	bra	_put_digit.main
  223  00:EE48            _put_digit.2:
  224  00:EE48  20 6B EE  	jsr	_put.vram
  225  00:EE4B            _put_digit.main:
  226  00:EE4B  A5 FE     	lda	<__dl
  227  00:EE4D            _put_digit.sub:
  228  00:EE4D  C9 0A     	cmp	#10
  229                     	blo	.l1
       00:EE4F  90 03     	bcc	.l1
  230                     	add	#$07
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:EE51  18        	clc
       00:EE52  69 07     	adc	#$07
                          .endif
  231  00:EE54  69 10     .l1:	adc	#$10
  232  00:EE56  6D 79 27  	adc	_font_base
  233  00:EE59  8D 02 00  	sta	video_data_l
  234  00:EE5C  62        	cla
  235  00:EE5D  6D 7A 27  	adc	_font_base+1
  236  00:EE60  8D 03 00  	sta	video_data_h
  237  00:EE63  60        	rts
  238  00:EE64            _put.xy:
  239  00:EE64  22        	sax
  240  00:EE65  20 19 E4  	jsr	calc_vram_addr
  241  00:EE68  4C 02 E4  	jmp	set_write
  242  00:EE6B            _put.vram:
  243  00:EE6B  64 F7     	stz	<vdc_reg
  244  00:EE6D  9C 00 00  	stz	video_reg
  245  00:EE70  8E 02 00  	stx	video_data_l
  246  00:EE73  8D 03 00  	sta	video_data_h
  247                     	vreg	#$02
       00:EE76  A9 02     	lda	#$02
       00:EE78  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:EE7A  03 02     	st0	#$02
                          .else
                          .endif
  248  00:EE7C  60        	rts
  249                     
  250                     ; put_char(char character, int offset)
  251                     ; put_char(char character, char x, char y)
  252                     ; ----
  253                     
  254  00:EE7D            _put_char.3:
  255  00:EE7D  A5 FC     	lda	<__cl
  256  00:EE7F  20 64 EE  	jsr	_put.xy
  257  00:EE82  80 03     	bra	_put_char.main
  258  00:EE84            _put_char.2:
  259  00:EE84  20 6B EE  	jsr	_put.vram
  260  00:EE87            _put_char.main:
  261  00:EE87  A5 FE     	lda	<__dl
  262                     	; --
  263  00:EE89  C9 20     	cmp	#32
  264                     	bhs	.l1
       00:EE8B  B0 03     	bcs	.l1
  265  00:EE8D  A9 20     	lda	#32
  266  00:EE8F  38        	sec
  267  00:EE90  E9 20     .l1:	sbc	#32
  268                     	add	_font_base
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:EE92  18        	clc
       00:EE93  6D 79 27  	adc	_font_base
                          .endif
  269  00:EE96  8D 02 00  	sta	video_data_l
  270  00:EE99  62        	cla
  271  00:EE9A  6D 7A 27  	adc	_font_base+1
  272  00:EE9D  8D 03 00  	sta	video_data_h
  273  00:EEA0  60        	rts
  274                     
  275                     ; put_raw(int character, int offset)
  276                     ; put_raw(int character, char x, char y)
  277                     ; ----
  278                     
  279  00:EEA1            _put_raw.3:
  280  00:EEA1  A5 FC     	lda	<__cl
  281  00:EEA3  20 64 EE  	jsr	_put.xy
  282  00:EEA6  80 03     	bra	_put_raw.main
  283  00:EEA8            _put_raw.2:
  284  00:EEA8  20 6B EE  	jsr	_put.vram
  285  00:EEAB            _put_raw.main:
  286  00:EEAB  A5 FE     	lda	<__dl
  287  00:EEAD  8D 02 00  	sta	video_data_l
  288  00:EEB0  A5 FF     	lda	<__dh
  289  00:EEB2  8D 03 00  	sta	video_data_h
  290  00:EEB5  60        	rts
  291                     
  292                     ; put_number(int number, char n, int offset)
  293                     ; put_number(int number, char n, char x, char y)
  294                     ; ----
  295                     
  296                     
  297                     _put_number.3:	maplibfunc	lib2_put_number.3
       00:EEB6  A8        	tay
       00:EEB7  43 20     	tma	#page(lib2_put_number.3)
       00:EEB9  48        	pha
       00:EEBA  A9 01     	lda	#bank(lib2_put_number.3)
       00:EEBC  53 20     	tam	#page(lib2_put_number.3)
       00:EEBE  98        	tya
       00:EEBF  20 8A AC  	jsr	lib2_put_number.3
       00:EEC2  A8        	tay
       00:EEC3  68        	pla
       00:EEC4  53 20     	tam	#page(lib2_put_number.3)
       00:EEC6  98        	tya
  298  00:EEC7  60        		rts
  299                     
  300                     _put_number.4:	maplibfunc	lib2_put_number.4
       00:EEC8  A8        	tay
       00:EEC9  43 20     	tma	#page(lib2_put_number.4)
       00:EECB  48        	pha
       00:EECC  A9 01     	lda	#bank(lib2_put_number.4)
       00:EECE  53 20     	tam	#page(lib2_put_number.4)
       00:EED0  98        	tya
       00:EED1  20 83 AC  	jsr	lib2_put_number.4
       00:EED4  A8        	tay
       00:EED5  68        	pla
       00:EED6  53 20     	tam	#page(lib2_put_number.4)
       00:EED8  98        	tya
  301  00:EED9  60        		rts
  302                     
  303                     
  304                     ; put_hex(int number, char n, int offset)
  305                     ; put_hex(int number, char n, char x, char y)
  306                     ; ----
  307                     
  308  00:EEDA            _put_hex.4:
  309  00:EEDA  A5 FA     	lda	<__bl
  310  00:EEDC  20 64 EE  	jsr	_put.xy
  311  00:EEDF  80 03     	bra	_put_hex.main
  312  00:EEE1            _put_hex.3:
  313  00:EEE1  20 6B EE  	jsr	_put.vram
  314  00:EEE4            _put_hex.main:
  315  00:EEE4  A6 FC     	ldx	<__cl
  316  00:EEE6  F0 12     	beq	.l3
  317  00:EEE8  E0 05     .l1:	cpx	#5
  318                     	blo	.l2
       00:EEEA  90 07     	bcc	.l2
  319  00:EEEC  62        	cla
  320  00:EEED  20 4D EE  	jsr	_put_digit.sub
  321  00:EEF0  CA        	dex
  322  00:EEF1  80 F5     	bra	.l1
  323                     	; --
  324  00:EEF3  8A        .l2:	txa
  325  00:EEF4  3A        	dec	A
  326  00:EEF5  0A        	asl	A
  327  00:EEF6  AA        	tax
  328  00:EEF7  7C FB EE  	jmp	[.tbl,X]
  329  00:EEFA  60        .l3:	rts
  330                     	; --
  331  00:EEFB  1C EF     .tbl:	.dw	.h1,.h2,.h3,.h4
       00:EEFD  13 EF     
       00:EEFF  0C EF     
       00:EF01  03 EF     
  332                     	; --
  333  00:EF03  A5 FF     .h4:	lda	<__dh
  334  00:EF05  4A        	lsr	A
  335  00:EF06  4A        	lsr	A
  336  00:EF07  4A        	lsr	A
  337  00:EF08  4A        	lsr	A
  338  00:EF09  20 4D EE  	jsr	_put_digit.sub
  339                     	; --
  340  00:EF0C  A5 FF     .h3:	lda	<__dh
  341  00:EF0E  29 0F     	and	#$0F
  342  00:EF10  20 4D EE  	jsr	_put_digit.sub
  343                     	; --
  344  00:EF13  A5 FE     .h2:	lda	<__dl
  345  00:EF15  4A        	lsr	A
  346  00:EF16  4A        	lsr	A
  347  00:EF17  4A        	lsr	A
  348  00:EF18  4A        	lsr	A
  349  00:EF19  20 4D EE  	jsr	_put_digit.sub
  350                     	; --
  351  00:EF1C  A5 FE     .h1:	lda	<__dl
  352  00:EF1E  29 0F     	and	#$0F
  353  00:EF20  4C 4D EE  	jmp	_put_digit.sub
  354                     
  355                     ; put_string(char *string, int offset)
  356                     ; put_string(char *string, char x, char y)
  357                     ; ----
  358                     
  359  00:EF23            _put_string.3:
  360  00:EF23  A5 FA     	lda	<__bl
  361  00:EF25  20 64 EE  	jsr	_put.xy
  362  00:EF28  80 03     	bra	_put_string.main
  363  00:EF2A            _put_string.2:
  364  00:EF2A  20 6B EE  	jsr	_put.vram
  365  00:EF2D            _put_string.main:
  366  00:EF2D  80 1D     	bra	.l3
  367                     	; --
  368  00:EF2F  C9 20     .l1:	cmp	#32
  369                     	bhs	.l2
       00:EF31  B0 03     	bcs	.l2
  370  00:EF33  A9 20     	lda	#32
  371  00:EF35  38        	sec
  372  00:EF36  E9 20     .l2:	sbc	#32
  373                     	add	_font_base
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:EF38  18        	clc
       00:EF39  6D 79 27  	adc	_font_base
                          .endif
  374  00:EF3C  8D 02 00  	sta	video_data_l
  375  00:EF3F  62        	cla
  376  00:EF40  6D 7A 27  	adc	_font_base+1
  377  00:EF43  8D 03 00  	sta	video_data_h
  378                     	incw	<__si
       00:EF46  E6 EE     	inc	<__si		; value at stated memory
       00:EF48  D0 02     	bne	.x_00219		; location
       00:EF4A  E6 EF     	inc	<__si+1
       00:EF4C            .x_00219:
  379  00:EF4C  B2 EE     .l3:	lda	[__si]
  380  00:EF4E  D0 DF     	bne	.l1
  381  00:EF50  60        	rts
  382                     
  383                     ; vsync()
  384                     ; vsync(char nb_frame)
  385                     ; ----
  386                     
  387  00:EF51            _vsync:
  388  00:EF51  62        	cla
  389  00:EF52  4C F1 FA  	jmp	wait_vsync
  390                     
  391  00:EF55            _vsync.1:
  392  00:EF55  8A        	txa
  393  00:EF56  4C F1 FA  	jmp	wait_vsync
  394                     
  395                     ; vreg(char reg)
  396                     ; vreg(char reg, int data)
  397                     ; ----
  398                     
  399  00:EF59            _vreg.1:
  400  00:EF59  86 F7     	stx	<vdc_reg
  401  00:EF5B  8E 00 00  	stx	video_reg
  402  00:EF5E  60        	rts
  403                     
  404  00:EF5F            _vreg.2:
  405  00:EF5F  A4 F8     	ldy	<__al
  406  00:EF61  84 F7     	sty	<vdc_reg
  407  00:EF63  8C 00 00  	sty	video_reg
  408  00:EF66  8E 02 00  	stx	video_data
  409  00:EF69  8D 03 00  	sta	video_data+1
  410  00:EF6C  60        	rts
  411                     
  412                     ; vram_addr(char x [__al], char y)
  413                     ; ----
  414                     
  415  00:EF6D            _vram_addr.2:
  416  00:EF6D  A5 F8     	lda	<__al
  417  00:EF6F  22        	sax
  418  00:EF70  20 19 E4  	jsr	calc_vram_addr
  419                     	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:EF73  A6 F0     	ldx	<__di
       00:EF75  A5 F1     	lda	<__di+1
                          .endif
  420  00:EF77  60        	rts
  421                     
  422                     ; scan_map_table(int *tbl [__si], int *x [__ax], int *y [__cx])
  423                     ; ----
  424                     ; tbl,
  425                     ; x,
  426                     ; y,
  427                     ; ----
  428                     
  429  00:EF78            _scan_map_table.3:
  430                     
  431  00:EF78  A0 01     	ldy	#1
  432  00:EF7A  B2 F8     	lda	[__ax]
  433  00:EF7C  85 FA     	sta	<__bl
  434  00:EF7E  B1 F8     	lda	[__ax],Y
  435  00:EF80  85 FB     	sta	<__bh
  436  00:EF82  B2 FC     	lda	[__cx]
  437  00:EF84  85 FE     	sta	<__dl
  438  00:EF86  B1 FC     	lda	[__cx],Y
  439  00:EF88  85 FF     	sta	<__dh
  440                     	; --
  441                     	addw	#4,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:EF8A  18        	clc
       00:EF8B  A5 EE     	lda	LOW_BYTE <__si
       00:EF8D  69 04     	adc	LOW_BYTE #4
       00:EF8F  85 EE     	sta	LOW_BYTE <__si
       00:EF91  A5 EF     	lda	HIGH_BYTE <__si
       00:EF93  69 00     	adc	HIGH_BYTE #4
       00:EF95  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  442                     
  443                     	; ----
  444                     	; check bounds
  445                     	;
  446                     	; -- bottom
  447  00:EF97  A0 07     .l1:	ldy	#7
  448  00:EF99  B1 EE     	lda	[__si],Y
  449  00:EF9B  C5 FF     	cmp	<__dh
  450                     	blo	.x1
       00:EF9D  90 3B     	bcc	.x1
  451  00:EF9F  D0 07     	bne	.l2
  452  00:EFA1  88        	dey
  453  00:EFA2  B1 EE     	lda	[__si],Y
  454  00:EFA4  C5 FE     	cmp	<__dl
  455                     	blo	.x1
       00:EFA6  90 32     	bcc	.x1
  456                     	; -- top
  457  00:EFA8  A0 03     .l2:	ldy	#3
  458  00:EFAA  A5 FF     	lda	<__dh
  459  00:EFAC  D1 EE     	cmp	[__si],Y
  460                     	blo	.x1
       00:EFAE  90 2A     	bcc	.x1
  461  00:EFB0  D0 07     	bne	.l3
  462  00:EFB2  88        	dey
  463  00:EFB3  A5 FE     	lda	<__dl
  464  00:EFB5  D1 EE     	cmp	[__si],Y
  465                     	blo	.x1
       00:EFB7  90 21     	bcc	.x1
  466                     	; -- right
  467  00:EFB9  A0 05     .l3:	ldy	#5
  468  00:EFBB  B1 EE     	lda	[__si],Y
  469  00:EFBD  C5 FB     	cmp	<__bh
  470                     	blo	.x1
       00:EFBF  90 19     	bcc	.x1
  471  00:EFC1  D0 07     	bne	.l4
  472  00:EFC3  88        	dey
  473  00:EFC4  B1 EE     	lda	[__si],Y
  474  00:EFC6  C5 FA     	cmp	<__bl
  475                     	blo	.x1
       00:EFC8  90 10     	bcc	.x1
  476                     	; -- left
  477  00:EFCA  A0 01     .l4:	ldy	#1
  478  00:EFCC  A5 FB     	lda	<__bh
  479  00:EFCE  D1 EE     	cmp	[__si],Y
  480                     	blo	.x1
       00:EFD0  90 08     	bcc	.x1
  481  00:EFD2  D0 20     	bne	.x2
  482  00:EFD4  A5 FA     	lda	<__bl
  483  00:EFD6  D2 EE     	cmp	[__si]
  484                     	bhs	.x2
       00:EFD8  B0 1A     	bcs	.x2
  485                     
  486                     	; ----
  487                     	; next
  488                     	;
  489                     .x1:	addw	#12,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:EFDA  18        	clc
       00:EFDB  A5 EE     	lda	LOW_BYTE <__si
       00:EFDD  69 0C     	adc	LOW_BYTE #12
       00:EFDF  85 EE     	sta	LOW_BYTE <__si
       00:EFE1  A5 EF     	lda	HIGH_BYTE <__si
       00:EFE3  69 00     	adc	HIGH_BYTE #12
       00:EFE5  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  490  00:EFE7  A0 01     	ldy	#1
  491  00:EFE9  B2 EE     	lda	[__si]
  492  00:EFEB  31 EE     	and	[__si],Y
  493  00:EFED  C9 FF     	cmp	#$FF
  494  00:EFEF  D0 A6     	bne	.l1
  495                     
  496                     	; ----
  497                     	; didn't find map...
  498                     	;
  499  00:EFF1  82        	clx
  500  00:EFF2  62        	cla
  501  00:EFF3  60        	rts
  502                     
  503                     	; ----
  504                     	; found map!
  505                     	;
  506  00:EFF4  A0 01     .x2:	ldy	#1
  507  00:EFF6  A5 FA     	lda	<__bl
  508                     	sub	[__si]
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:EFF8  38        	sec
       00:EFF9  F2 EE     	sbc	[__si]
                          .endif
  509  00:EFFB  92 F8     	sta	[__ax]
  510  00:EFFD  A5 FB     	lda	<__bh
  511  00:EFFF  F1 EE     	sbc	[__si],Y
  512  00:F001  91 F8     	sta	[__ax],Y
  513                     	; --
  514  00:F003  C8        	iny
  515  00:F004  A5 FE     	lda	<__dl
  516                     	sub	[__si],Y
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:F006  38        	sec
       00:F007  F1 EE     	sbc	[__si],Y
                          .endif
  517  00:F009  92 FC     	sta	[__cx]
  518  00:F00B  C8        	iny
  519  00:F00C  A5 FF     	lda	<__dh
  520  00:F00E  F1 EE     	sbc	[__si],Y
  521  00:F010  A0 01     	ldy	#1
  522  00:F012  91 FC     	sta	[__cx],Y
  523                     	; --
  524                     	__ldw	<__si
                0000      .if (1 = 2)
                          .else
       00:F014  A6 EE     	ldx	<__si
       00:F016  A5 EF     	lda	<__si+1
                          .endif
  525  00:F018  60        	rts
  526                     
  527                     ; set_map_data(int *ptr)
  528                     ; set_map_data(char *map [__bl:__si], int w [__ax], int h)
  529                     ; set_map_data(char *map [__bl:__si], int w [__ax], int h [__dx], char wrap)
  530                     ; ----
  531                     ; map,	map base address
  532                     ; w,	map width
  533                     ; h,	map height
  534                     ; wrap, wrap flag (1 = wrap, 0 = do not wrap)
  535                     ; ----
  536                     
  537  00:F019            _set_map_data.1:
  538                     	__stw	<__si
       00:F019  86 EE     	stx	<__si
       00:F01B  85 EF     	sta	<__si+1
  539  00:F01D  05 EE     	ora	<__si
  540  00:F01F  F0 54     	beq	.l1
  541                     	; -- calculate width
  542  00:F021  A0 04 B1  	lda	[__si].4
       00:F024  EE        
  543                     	sub	[__si]
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:F025  38        	sec
       00:F026  F2 EE     	sbc	[__si]
                          .endif
  544  00:F028  8D E6 26  	sta	mapwidth
  545  00:F02B  A0 05 B1  	lda	[__si].5
       00:F02E  EE        
  546  00:F02F  A0 01 F1  	sbc	[__si].1
       00:F032  EE        
  547  00:F033  8D E7 26  	sta	mapwidth+1
  548                     	incw	mapwidth
       00:F036  EE E6 26  	inc	mapwidth		; value at stated memory
       00:F039  D0 03     	bne	.x_00236		; location
       00:F03B  EE E7 26  	inc	mapwidth+1
       00:F03E            .x_00236:
  549                     	; -- calculate height
  550  00:F03E  A0 06 B1  	lda	[__si].6
       00:F041  EE        
  551                     	sub	[__si].2
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:F042  38        	sec
       00:F043  A0 02 F1  	sbc	[__si].2
       00:F046  EE        
                          .endif
  552  00:F047  8D E8 26  	sta	mapheight
  553  00:F04A  A0 07 B1  	lda	[__si].7
       00:F04D  EE        
  554  00:F04E  A0 03 F1  	sbc	[__si].3
       00:F051  EE        
  555  00:F052  8D E9 26  	sta	mapheight+1
  556                     	incw	mapheight
       00:F055  EE E8 26  	inc	mapheight		; value at stated memory
       00:F058  D0 03     	bne	.x_00238		; location
       00:F05A  EE E9 26  	inc	mapheight+1
       00:F05D            .x_00238:
  557                     	; -- get map bank
  558  00:F05D  A0 08 B1  	lda	[__si].8
       00:F060  EE        
  559  00:F061  8D E3 26  	sta	mapbank
  560                     	; -- get map addr
  561  00:F064  A0 0A B1  	lda	[__si].10
       00:F067  EE        
  562  00:F068  8D E4 26  	sta	mapaddr
  563  00:F06B  C8        	iny
  564  00:F06C  B2 EE     	lda	[__si]
  565  00:F06E  8D E5 26  	sta	mapaddr+1
  566                     	; -- no wrap
  567  00:F071  9C F5 26  	stz	mapwrap
  568  00:F074  60        	rts
  569                     	; -- null pointer
  570                     .l1:	stwz	mapwidth
       00:F075  9C E6 26  	stz	LOW_BYTE mapwidth
       00:F078  9C E7 26  	stz	HIGH_BYTE mapwidth
  571                     	stwz	mapheight
       00:F07B  9C E8 26  	stz	LOW_BYTE mapheight
       00:F07E  9C E9 26  	stz	HIGH_BYTE mapheight
  572  00:F081  9C E3 26  	stz	mapbank
  573                     	stwz	mapaddr
       00:F084  9C E4 26  	stz	LOW_BYTE mapaddr
       00:F087  9C E5 26  	stz	HIGH_BYTE mapaddr
  574  00:F08A  9C F5 26  	stz	mapwrap
  575  00:F08D  60        	rts
  576  00:F08E            _set_map_data.4:
  577  00:F08E  8E F5 26  	stx	mapwrap
  578                     	__ldw	<__dx
                0000      .if (1 = 2)
                          .else
       00:F091  A6 FE     	ldx	<__dx
       00:F093  A5 FF     	lda	<__dx+1
                          .endif
  579  00:F095  80 06     	bra	_set_map_data.main
  580  00:F097            _set_map_data.3:
  581  00:F097  9C F5 26  	stz	mapwrap
  582  00:F09A  EE F5 26  	inc	mapwrap
  583  00:F09D            _set_map_data.main:
  584                     	__stw	mapheight
       00:F09D  8E E8 26  	stx	mapheight
       00:F0A0  8D E9 26  	sta	mapheight+1
  585                     	stw	<__ax,mapwidth
       00:F0A3  A5 F8     	lda	LOW_BYTE <__ax
       00:F0A5  8D E6 26  	sta	LOW_BYTE mapwidth
       00:F0A8  A5 F9     	lda	HIGH_BYTE <__ax
       00:F0AA  8D E7 26  	sta	HIGH_BYTE mapwidth
  586                     	stb	<__bl,mapbank
       00:F0AD  A5 FA     	lda	<__bl
       00:F0AF  8D E3 26  	sta	mapbank
  587                     	stw	<__si,mapaddr
       00:F0B2  A5 EE     	lda	LOW_BYTE <__si
       00:F0B4  8D E4 26  	sta	LOW_BYTE mapaddr
       00:F0B7  A5 EF     	lda	HIGH_BYTE <__si
       00:F0B9  8D E5 26  	sta	HIGH_BYTE mapaddr
  588  00:F0BC  60        	rts
  589                     
  590                     ; get_map_width()
  591                     ; ----
  592                     
  593  00:F0BD            _get_map_width:
  594                     	__ldw	mapwidth
                0000      .if (1 = 2)
                          .else
       00:F0BD  AE E6 26  	ldx	mapwidth
       00:F0C0  AD E7 26  	lda	mapwidth+1
                          .endif
  595  00:F0C3  60        	rts
  596                     
  597                     ; get_map_height()
  598                     ; ----
  599                     
  600  00:F0C4            _get_map_height:
  601                     	__ldw	mapheight
                0000      .if (1 = 2)
                          .else
       00:F0C4  AE E8 26  	ldx	mapheight
       00:F0C7  AD E9 26  	lda	mapheight+1
                          .endif
  602  00:F0CA  60        	rts
  603                     
  604                     ; set_tile_data(char *tile_ex [__di])
  605                     ; set_tile_data(char *tile [__bl:__si], int nb_tile [__cx], char *ptable [__al:__dx], char type [__ah])
  606                     ; ----
  607                     ; tile,	tile base index
  608                     ; nb_tile, number of tile
  609                     ; ptable,	tile palette table address
  610                     ; type, tile type (8 or 16)
  611                     ; ----
  612                     
  613  00:F0CB            _set_tile_data.1:
  614  00:F0CB  C2        	cly
  615  00:F0CC  B1 F0 C8  	lda	[__di],Y++
  616  00:F0CF  8D F0 26  	sta	mapnbtile
  617  00:F0D2  B1 F0 C8  	lda	[__di],Y++
  618  00:F0D5  8D F1 26  	sta	mapnbtile+1
  619  00:F0D8  B1 F0 C8  	lda	[__di],Y++
  620  00:F0DB  8D EA 26  	sta	maptiletype
  621  00:F0DE  C8        	iny
  622  00:F0DF  B1 F0 C8  	lda	[__di],Y++
  623  00:F0E2  8D EB 26  	sta	maptilebank
  624  00:F0E5  C8        	iny
  625  00:F0E6  B1 F0 C8  	lda	[__di],Y++
  626  00:F0E9  8D EC 26  	sta	maptileaddr
  627  00:F0EC  B1 F0 C8  	lda	[__di],Y++
  628  00:F0EF  8D ED 26  	sta	maptileaddr+1
  629  00:F0F2  A9 02     	lda	#(CONST_BANK+_bank_base)
  630  00:F0F4  8D F2 26  	sta	mapctablebank
  631  00:F0F7  B1 F0 C8  	lda	[__di],Y++
  632  00:F0FA  8D F3 26  	sta	mapctable
  633  00:F0FD  B1 F0     	lda	[__di],Y
  634  00:F0FF  8D F4 26  	sta	mapctable+1
  635  00:F102  60        	rts
  636  00:F103            _set_tile_data.4:
  637                     	stb	<__bl,maptilebank
       00:F103  A5 FA     	lda	<__bl
       00:F105  8D EB 26  	sta	maptilebank
  638                     	stw	<__si,maptileaddr
       00:F108  A5 EE     	lda	LOW_BYTE <__si
       00:F10A  8D EC 26  	sta	LOW_BYTE maptileaddr
       00:F10D  A5 EF     	lda	HIGH_BYTE <__si
       00:F10F  8D ED 26  	sta	HIGH_BYTE maptileaddr
  639                     	stw	<__cx,mapnbtile
       00:F112  A5 FC     	lda	LOW_BYTE <__cx
       00:F114  8D F0 26  	sta	LOW_BYTE mapnbtile
       00:F117  A5 FD     	lda	HIGH_BYTE <__cx
       00:F119  8D F1 26  	sta	HIGH_BYTE mapnbtile
  640                     	stb	<__al,mapctablebank
       00:F11C  A5 F8     	lda	<__al
       00:F11E  8D F2 26  	sta	mapctablebank
  641                     	stw	<__dx,mapctable
       00:F121  A5 FE     	lda	LOW_BYTE <__dx
       00:F123  8D F3 26  	sta	LOW_BYTE mapctable
       00:F126  A5 FF     	lda	HIGH_BYTE <__dx
       00:F128  8D F4 26  	sta	HIGH_BYTE mapctable
  642                     	stb	<__ah,maptiletype
       00:F12B  A5 F9     	lda	<__ah
       00:F12D  8D EA 26  	sta	maptiletype
  643  00:F130  60        	rts
  644                     
  645                     ; load_tile(int addr)
  646                     ; ----
  647                     
  648  00:F131            _load_tile:
  649                     	__stw	<__di
       00:F131  86 F0     	stx	<__di
       00:F133  85 F1     	sta	<__di+1
  650  00:F135  86 F8     	stx	<__al
  651  00:F137  4A        	lsr	A
  652  00:F138  66 F8     	ror	<__al
  653  00:F13A  4A        	lsr	A
  654  00:F13B  66 F8     	ror	<__al
  655  00:F13D  4A        	lsr	A
  656  00:F13E  66 F8     	ror	<__al
  657  00:F140  4A        	lsr	A
  658  00:F141  66 F8     	ror	<__al
  659  00:F143  8D EF 26  	sta		maptilebase+1
  660                     	stb	<__al,maptilebase
       00:F146  A5 F8     	lda	<__al
       00:F148  8D EE 26  	sta	maptilebase
  661                     	; --
  662                     	stw	mapnbtile,<__cx
       00:F14B  AD F0 26  	lda	LOW_BYTE mapnbtile
       00:F14E  85 FC     	sta	LOW_BYTE <__cx
       00:F150  AD F1 26  	lda	HIGH_BYTE mapnbtile
       00:F153  85 FD     	sta	HIGH_BYTE <__cx
  663  00:F155  A2 04     	ldx	#4
  664  00:F157  AD EA 26  	lda	maptiletype
  665  00:F15A  C9 08     	cmp	#8
  666  00:F15C  F0 02     	beq	.l1
  667  00:F15E  A2 06     	ldx	#6
  668  00:F160  06 FC     .l1:	asl	<__cl
  669  00:F162  26 FD     	rol	<__ch
  670  00:F164  CA        	dex
  671  00:F165  D0 F9     	bne	.l1
  672                     	; --
  673                     	stb	maptilebank,<__bl
       00:F167  AD EB 26  	lda	maptilebank
       00:F16A  85 FA     	sta	<__bl
  674                     	stw	maptileaddr,<__si
       00:F16C  AD EC 26  	lda	LOW_BYTE maptileaddr
       00:F16F  85 EE     	sta	LOW_BYTE <__si
       00:F171  AD ED 26  	lda	HIGH_BYTE maptileaddr
       00:F174  85 EF     	sta	HIGH_BYTE <__si
  675  00:F176  4C 87 E3  	jmp	load_vram
  676                     
  677                     ; load_map(char x [__al], char y [__ah], int mx, int my, char w [__dl], char h [__dh])
  678                     ; ----
  679                     
  680  00:F179            _load_map.6:
  681                     
  682                     	tstw	mapwidth
       00:F179  AD E6 26  	lda	mapwidth		; value at stated memory
       00:F17C  0D E7 26  	ora	mapwidth+1		; location is zero
  683  00:F17F  F0 7C     	beq	.l6
  684                     	tstw	mapheight
       00:F181  AD E8 26  	lda	mapheight		; value at stated memory
       00:F184  0D E9 26  	ora	mapheight+1		; location is zero
  685  00:F187  F0 74     	beq	.l6
  686                     
  687                     	; ----
  688                     	; adjust map y coordinate
  689                     	;
  690  00:F189  A5 FB     	lda	<__bh
  691  00:F18B  30 1F     	bmi	.l2
  692                     .l1:	cmpw	mapheight,<__bx
       00:F18D  A5 FB     	lda	HIGH_BYTE <__bx
       00:F18F  CD E9 26  	cmp	HIGH_BYTE mapheight
       00:F192  D0 05     	bne	.x_00262
       00:F194  A5 FA     	lda	LOW_BYTE <__bx
       00:F196  CD E8 26  	cmp	LOW_BYTE mapheight
       00:F199            .x_00262:
  693                     	blo	.l3
       00:F199  90 26     	bcc	.l3
  694                     	subw	mapheight,<__bx
       00:F19B  38        	sec
       00:F19C  A5 FA     	lda	LOW_BYTE <__bx
       00:F19E  ED E8 26  	sbc	LOW_BYTE mapheight
       00:F1A1  85 FA     	sta	LOW_BYTE <__bx
       00:F1A3  A5 FB     	lda	HIGH_BYTE <__bx
       00:F1A5  ED E9 26  	sbc	HIGH_BYTE mapheight
       00:F1A8  85 FB     	sta	HIGH_BYTE <__bx
  695  00:F1AA  80 E1     	bra	.l1
  696                     	; --
  697  00:F1AC  A5 FB     .l2:	lda	<__bh
  698  00:F1AE  10 11     	bpl	.l3
  699                     	addw	mapheight,<__bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:F1B0  18        	clc
       00:F1B1  A5 FA     	lda	LOW_BYTE <__bx
       00:F1B3  6D E8 26  	adc	LOW_BYTE mapheight
       00:F1B6  85 FA     	sta	LOW_BYTE <__bx
       00:F1B8  A5 FB     	lda	HIGH_BYTE <__bx
       00:F1BA  6D E9 26  	adc	HIGH_BYTE mapheight
       00:F1BD  85 FB     	sta	HIGH_BYTE <__bx
                          .endif
  700  00:F1BF  80 EB     	bra	.l2
  701                     
  702                     	; ----
  703                     	; adjust map x coordinate
  704                     	;
  705                     .l3:	stb	<__bl,<__ch
       00:F1C1  A5 FA     	lda	<__bl
       00:F1C3  85 FD     	sta	<__ch
  706  00:F1C5  A5 F1     	lda	<__di+1
  707  00:F1C7  30 1F     	bmi	.l5
  708                     .l4:	cmpw	mapwidth,<__di
       00:F1C9  A5 F1     	lda	HIGH_BYTE <__di
       00:F1CB  CD E7 26  	cmp	HIGH_BYTE mapwidth
       00:F1CE  D0 05     	bne	.x_00267
       00:F1D0  A5 F0     	lda	LOW_BYTE <__di
       00:F1D2  CD E6 26  	cmp	LOW_BYTE mapwidth
       00:F1D5            .x_00267:
  709                     	blo	.l7
       00:F1D5  90 27     	bcc	.l7
  710                     	subw	mapwidth,<__di
       00:F1D7  38        	sec
       00:F1D8  A5 F0     	lda	LOW_BYTE <__di
       00:F1DA  ED E6 26  	sbc	LOW_BYTE mapwidth
       00:F1DD  85 F0     	sta	LOW_BYTE <__di
       00:F1DF  A5 F1     	lda	HIGH_BYTE <__di
       00:F1E1  ED E7 26  	sbc	HIGH_BYTE mapwidth
       00:F1E4  85 F1     	sta	HIGH_BYTE <__di
  711  00:F1E6  80 E1     	bra	.l4
  712                     	; --
  713  00:F1E8  A5 F1     .l5:	lda	<__di+1
  714  00:F1EA  10 12     	bpl	.l7
  715                     	addw	mapwidth,<__di
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:F1EC  18        	clc
       00:F1ED  A5 F0     	lda	LOW_BYTE <__di
       00:F1EF  6D E6 26  	adc	LOW_BYTE mapwidth
       00:F1F2  85 F0     	sta	LOW_BYTE <__di
       00:F1F4  A5 F1     	lda	HIGH_BYTE <__di
       00:F1F6  6D E7 26  	adc	HIGH_BYTE mapwidth
       00:F1F9  85 F1     	sta	HIGH_BYTE <__di
                          .endif
  716  00:F1FB  80 EB     	bra	.l5
  717                     
  718                     	; ----
  719                     	; exit
  720                     	;
  721  00:F1FD  60        .l6:	rts
  722                     
  723                     	; ----
  724                     	; ok
  725                     	;
  726                     .l7:	stb	<__di,<__cl
       00:F1FE  A5 F0     	lda	<__di
       00:F200  85 FC     	sta	<__cl
  727  00:F202  4C 4A E3  	jmp	load_map
  728                     
  729                     ; spr_set(char num)
  730                     ; ----
  731                     ; load SI with the offset of the sprite to change
  732                     ; SI = satb + 8 * sprite_number
  733                     ; ----
  734                     
  735  00:F205            _spr_set:
  736  00:F205  E0 40     	cpx	#64
  737                     	bhs	.l2
       00:F207  B0 19     	bcs	.l2
  738  00:F209  8A        	txa
  739  00:F20A  E8        	inx
  740  00:F20B  E4 14     	cpx	<spr_max
  741                     	blo	.l1
       00:F20D  90 02     	bcc	.l1
  742  00:F20F  86 14     	stx	<spr_max
  743                     	; --
  744  00:F211  64 13     .l1:	stz	<spr_ptr+1
  745  00:F213  0A        	asl	A
  746  00:F214  0A        	asl	A
  747  00:F215  0A        	asl	A
  748  00:F216  26 13     	rol	<spr_ptr+1
  749  00:F218  69 7D     	adc	#low(satb)
  750  00:F21A  85 12     	sta	<spr_ptr
  751  00:F21C  A5 13     	lda	<spr_ptr+1
  752  00:F21E  69 27     	adc	#high(satb)
  753  00:F220  85 13     	sta	<spr_ptr+1
  754  00:F222  60        .l2:	rts
  755                     
  756                     ; spr_hide(char num)
  757                     ; ----
  758                     
  759                     	; -- hide current sprite
  760  00:F223            _spr_hide:
  761  00:F223  A0 01     	ldy	#1
  762  00:F225  B1 12     	lda	[spr_ptr],Y
  763  00:F227  09 02     	ora	#$02
  764  00:F229  91 12     	sta	[spr_ptr],Y
  765  00:F22B  60        	rts
  766                     
  767  00:F22C            _spr_hide.1:
  768                     	; -- hide sprite number #
  769  00:F22C  E0 40     	cpx	#64
  770                     	bhs	.l1
       00:F22E  B0 09     	bcs	.l1
  771  00:F230  20 3A F2  	jsr	_spr_hide.sub
  772  00:F233  B1 06     	lda	[__ptr],Y
  773  00:F235  09 02     	ora	#$02
  774  00:F237  91 06     	sta	[__ptr],Y
  775  00:F239  60        .l1:	rts
  776                     
  777                     	; -- calc satb ptr
  778  00:F23A            _spr_hide.sub:
  779  00:F23A  8A        	txa
  780  00:F23B  64 07     	stz	<__ptr+1
  781  00:F23D  0A        	asl	A
  782  00:F23E  0A        	asl	A
  783  00:F23F  0A        	asl	A
  784  00:F240  26 07     	rol	<__ptr+1
  785  00:F242  69 7D     	adc	#low(satb)
  786  00:F244  85 06     	sta	<__ptr
  787  00:F246  A5 07     	lda	<__ptr+1
  788  00:F248  69 27     	adc	#high(satb)
  789  00:F24A  85 07     	sta	<__ptr+1
  790  00:F24C  A0 01     	ldy	#1
  791  00:F24E  60        	rts
  792                     
  793                     ; spr_show(char num)
  794                     ; ----
  795                     
  796                     	; -- hide current sprite
  797  00:F24F            _spr_show:
  798  00:F24F  A0 01     	ldy	#1
  799  00:F251  B1 12     	lda	[spr_ptr],Y
  800  00:F253  29 01     	and	#$01
  801  00:F255  91 12     	sta	[spr_ptr],Y
  802  00:F257  60        	rts
  803                     
  804  00:F258            _spr_show.1:
  805                     	; -- hide sprite number #
  806  00:F258  E0 40     	cpx	#64
  807                     	bhs	.l1
       00:F25A  B0 09     	bcs	.l1
  808  00:F25C  20 3A F2  	jsr	_spr_hide.sub
  809  00:F25F  B1 06     	lda	[__ptr],Y
  810  00:F261  29 01     	and	#$01
  811  00:F263  91 06     	sta	[__ptr],Y
  812  00:F265  60        .l1:	rts
  813                     
  814                     ; spr_x(int value)
  815                     ; ----
  816                     
  817  00:F266            _spr_x:
  818  00:F266  A0 02     	ldy	#2
  819  00:F268  22        	sax
  820                     	add	#32
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:F269  18        	clc
       00:F26A  69 20     	adc	#32
                          .endif
  821  00:F26C  91 12     	sta	[spr_ptr],Y
  822  00:F26E  22        	sax
  823  00:F26F  69 00     	adc	#0
  824  00:F271  C8        	iny
  825  00:F272  91 12     	sta	[spr_ptr],Y
  826  00:F274  60        	rts
  827                     
  828  00:F275            _spr_get_x:
  829  00:F275  A0 02     	ldy	#2
  830  00:F277  B1 12     	lda	[spr_ptr],Y
  831                     	sub	#32
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:F279  38        	sec
       00:F27A  E9 20     	sbc	#32
                          .endif
  832  00:F27C  AA        	tax
  833  00:F27D  C8        	iny
  834  00:F27E  B1 12     	lda	[spr_ptr],Y
  835  00:F280  E9 00     	sbc	#0
  836  00:F282  60        	rts
  837                     
  838                     ; spr_y(int value)
  839                     ; ----
  840                     
  841  00:F283            _spr_y:
  842  00:F283  22        	sax
  843                     	add	#64
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:F284  18        	clc
       00:F285  69 40     	adc	#64
                          .endif
  844  00:F287  92 12     	sta	[spr_ptr]
  845  00:F289  22        	sax
  846  00:F28A  69 00     	adc	#0
  847  00:F28C  29 01     	and	#$01
  848  00:F28E  A0 01     	ldy	#1
  849  00:F290  91 12     	sta	[spr_ptr],Y
  850  00:F292  60        	rts
  851                     
  852  00:F293            _spr_get_y:
  853  00:F293  B2 12     	lda	[spr_ptr]
  854                     	sub	#64
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:F295  38        	sec
       00:F296  E9 40     	sbc	#64
                          .endif
  855  00:F298  AA        	tax
  856  00:F299  A0 01     	ldy	#1
  857  00:F29B  B1 12     	lda	[spr_ptr],Y
  858  00:F29D  E9 00     	sbc	#0
  859  00:F29F  60        	rts
  860                     
  861                     ; spr_pattern(int vaddr)
  862                     ; ----
  863                     
  864  00:F2A0            _spr_pattern:
  865  00:F2A0  85 02     	sta	<__temp
  866  00:F2A2  8A        	txa
  867  00:F2A3  0A        	asl	A
  868  00:F2A4  26 02     	rol	<__temp
  869  00:F2A6  2A        	rol	A
  870  00:F2A7  26 02     	rol	<__temp
  871  00:F2A9  2A        	rol	A
  872  00:F2AA  26 02     	rol	<__temp
  873  00:F2AC  2A        	rol	A
  874  00:F2AD  29 07     	and	#$7
  875  00:F2AF  A0 05     	ldy	#5
  876  00:F2B1  91 12     	sta	[spr_ptr],Y
  877  00:F2B3  A5 02     	lda	<__temp
  878  00:F2B5  88        	dey
  879  00:F2B6  91 12     	sta	[spr_ptr],Y
  880  00:F2B8  60        	rts
  881                     
  882  00:F2B9            _spr_get_pattern:
  883  00:F2B9  A0 04     	ldy	#4
  884  00:F2BB  B1 12     	lda	[spr_ptr],Y
  885  00:F2BD  85 02     	sta	<__temp
  886  00:F2BF  C8        	iny
  887  00:F2C0  B1 12     	lda	[spr_ptr],Y
  888  00:F2C2  4A        	lsr	A
  889  00:F2C3  66 02     	ror	<__temp
  890  00:F2C5  6A        	ror	A
  891  00:F2C6  66 02     	ror	<__temp
  892  00:F2C8  6A        	ror	A
  893  00:F2C9  66 02     	ror	<__temp
  894  00:F2CB  6A        	ror	A
  895  00:F2CC  29 E0     	and	#$E0
  896  00:F2CE  AA        	tax
  897  00:F2CF  A5 02     	lda	<__temp
  898  00:F2D1  60        	rts
  899                     
  900                     ; spr_ctrl(char mask [__al], char value)
  901                     ; ----
  902                     
  903  00:F2D2            _spr_ctrl.2:
  904  00:F2D2  8A        	txa
  905  00:F2D3  25 F8     	and	<__al
  906  00:F2D5  85 02     	sta	<__temp
  907  00:F2D7  A5 F8     	lda	<__al
  908  00:F2D9  49 FF     	eor	#$FF
  909  00:F2DB  A0 07     	ldy	#7
  910  00:F2DD  31 12     	and	[spr_ptr],Y
  911  00:F2DF  05 02     	ora	<__temp
  912  00:F2E1  91 12     	sta	[spr_ptr],Y
  913  00:F2E3  60        	rts
  914                     
  915                     ; spr_pal(char pal)
  916                     ; ----
  917                     
  918  00:F2E4            _spr_pal:
  919  00:F2E4  8A        	txa
  920  00:F2E5  29 0F     	and	#$0F
  921  00:F2E7  85 02     	sta	<__temp
  922  00:F2E9  A0 06     	ldy	#6
  923  00:F2EB  B1 12     	lda	[spr_ptr],Y
  924  00:F2ED  29 F0     	and	#$F0
  925  00:F2EF  05 02     	ora	<__temp
  926  00:F2F1  91 12     	sta	[spr_ptr],Y
  927  00:F2F3  60        	rts
  928                     
  929  00:F2F4            _spr_get_pal:
  930  00:F2F4  A0 06     	ldy	#6
  931  00:F2F6  B1 12     	lda	[spr_ptr],Y
  932  00:F2F8  29 0F     	and	#$0F
  933  00:F2FA  AA        	tax
  934  00:F2FB  62        	cla
  935  00:F2FC  60        	rts
  936                     
  937                     ; spr_pri(char pri)
  938                     ; ----
  939                     
  940  00:F2FD            _spr_pri:
  941  00:F2FD  A0 06     	ldy	#6
  942  00:F2FF  B1 12     	lda	[spr_ptr],Y
  943  00:F301  29 7F     	and	#$7F
  944  00:F303  E0 00     	cpx	#$00
  945  00:F305  F0 02     	beq	.l1
  946  00:F307  09 80     	ora	#$80
  947  00:F309            .l1:
  948  00:F309  91 12     	sta	[spr_ptr],Y
  949  00:F30B  60        	rts
  950                     
  951                     ; satb_update()
  952                     ; satb_update(char max)
  953                     ; ----
  954                     
  955  00:F30C            _satb_update:
  956  00:F30C  A6 14     	ldx	<spr_max
  957  00:F30E  80 08     	bra	satb_update
  958                     
  959  00:F310            _satb_update.1:
  960  00:F310  A5 15     	lda	<spr_flag
  961  00:F312  F0 04     	beq	satb_update
  962  00:F314  64 15     	stz	<spr_flag
  963  00:F316  A2 40     	ldx	#64
  964                     
  965  00:F318            satb_update:
  966  00:F318  E0 00     	cpx	#0
  967  00:F31A  F0 50     	beq	.l4
  968                     	; --
  969  00:F31C  86 F8     	stx	<__al	; number of sprites
  970  00:F31E  8A        	txa
  971  00:F31F  3A        	dec	A	; round up to the next group of 4 sprites
  972  00:F320  4A        	lsr	A
  973  00:F321  4A        	lsr	A
  974  00:F322  1A        	inc	A
  975  00:F323  85 FC     	sta	<__cl
  976                     
  977                     ; Use TIA, but BLiT 16 words at a time (32 bytes)
  978                     ; Because interrupt must not deferred too much
  979                     ;
  980                     	stw	#32, ram_hdwr_tia_size
       00:F325  A9 20     	lda	LOW_BYTE #32
       00:F327  8D 03 27  	sta	LOW_BYTE ram_hdwr_tia_size
       00:F32A  A9 00     	lda	HIGH_BYTE #32
       00:F32C  8D 04 27  	sta	HIGH_BYTE ram_hdwr_tia_size
  981                     	stw	#video_data, ram_hdwr_tia_dest
       00:F32F  A9 02     	lda	LOW_BYTE #video_data
       00:F331  8D 01 27  	sta	LOW_BYTE ram_hdwr_tia_dest
       00:F334  A9 00     	lda	HIGH_BYTE #video_data
       00:F336  8D 02 27  	sta	HIGH_BYTE ram_hdwr_tia_dest
  982                     	stw	#satb, <__si
       00:F339  A9 7D     	lda	LOW_BYTE #satb
       00:F33B  85 EE     	sta	LOW_BYTE <__si
       00:F33D  A9 27     	lda	HIGH_BYTE #satb
       00:F33F  85 EF     	sta	HIGH_BYTE <__si
  983                     
  984                     	stw	#$7F00, <__di
       00:F341  A9 00     	lda	LOW_BYTE #$7F00
       00:F343  85 F0     	sta	LOW_BYTE <__di
       00:F345  A9 7F     	lda	HIGH_BYTE #$7F00
       00:F347  85 F1     	sta	HIGH_BYTE <__di
  985  00:F349  20 02 E4  	jsr	set_write
  986                     
  987                     .l3a:	stw	<__si, ram_hdwr_tia_src
       00:F34C  A5 EE     	lda	LOW_BYTE <__si
       00:F34E  8D FF 26  	sta	LOW_BYTE ram_hdwr_tia_src
       00:F351  A5 EF     	lda	HIGH_BYTE <__si
       00:F353  8D 00 27  	sta	HIGH_BYTE ram_hdwr_tia_src
  988  00:F356  20 FE 26  	jsr	ram_hdwr_tia
  989                     	addw	#32,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:F359  18        	clc
       00:F35A  A5 EE     	lda	LOW_BYTE <__si
       00:F35C  69 20     	adc	LOW_BYTE #32
       00:F35E  85 EE     	sta	LOW_BYTE <__si
       00:F360  A5 EF     	lda	HIGH_BYTE <__si
       00:F362  69 00     	adc	HIGH_BYTE #32
       00:F364  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  990  00:F366  C6 FC     	dec	<__cl
  991  00:F368  D0 E2     	bne	.l3a
  992                     
  993                     ;.l3:	stx	<__al
  994                     ;	stw	#satb,<__si
  995                     ;	stb	#BANK(satb),<__bl
  996                     ;	stw	#$7F00,<__di
  997                     ;	txa
  998                     ;	stz	<__ch
  999                     ;	asl	A
 1000                     ;	asl	A
 1001                     ;	rol	<__ch
 1002                     ;	sta	<__cl
 1003                     ;	jsr	load_vram
 1004                     
 1005                     	; --
 1006  00:F36A  A6 F8     	ldx	<__al
 1007  00:F36C  62        .l4:	cla
 1008  00:F36D  60        	rts
 1009                     
 1010                     ; init_satb()
 1011                     ; reset_satb()
 1012                     ; ----
 1013                     
 1014  00:F36E            _reset_satb:
 1015  00:F36E            _init_satb:
 1016  00:F36E  82        	clx
 1017  00:F36F  62        	cla
 1018  00:F370  9E 7D 27  .l1:	stz	satb,X
 1019  00:F373  9E 7D 28  	stz	satb+256,X
 1020  00:F376  E8        	inx
 1021  00:F377  D0 F7     	bne	.l1
 1022                     	; --
 1023  00:F379  A0 01     	ldy	#1
 1024  00:F37B  84 15     	sty	<spr_flag
 1025  00:F37D  64 14     	stz	<spr_max
 1026  00:F37F  60        	rts
 1027                     
 1028                     ; get_color(int index [color_reg])
 1029                     ; ----
 1030                     ; index: index in the palette (0-511)
 1031                     ; ----
 1032                     
 1033  00:F380            _get_color.1:
 1034  00:F380  AE 04 04  	ldx	color_data_l
 1035  00:F383  AD 05 04  	lda	color_data_h
 1036  00:F386  29 01     	and	#$01
 1037  00:F388  60        	rts
 1038                     
 1039                     ; set_color(int index [color_reg], int color [color_data])
 1040                     ; ----
 1041                     ; set one palette entry to the specified color
 1042                     ; ----
 1043                     ; index: index in the palette (0-511)
 1044                     ; color: color value,	GREEN:	bit 6-8
 1045                     ;			RED:	bit 3-5
 1046                     ;			BLUE:	bit 0-2
 1047                     ; ----
 1048                     ; NOTE : inlined
 1049                     ; ----
 1050                     
 1051                     ; fade_color(int color [__ax], char level)
 1052                     ; fade_color(int index [color_reg], int color [__ax], char level)
 1053                     ; ----
 1054                     ; set one palette entry to the specified color
 1055                     ; ----
 1056                     ; index: index in the palette (0-511)
 1057                     ; color: color value,	GREEN:	bit 6-8
 1058                     ;			RED:	bit 3-5
 1059                     ;			BLUE:	bit 0-2
 1060                     ; level: level of fading (0 = black, 8 = full)
 1061                     ; ----
 1062                     
 1063  00:F389            _fade_color.2:
 1064  00:F389            _fade_color.3:
 1065  00:F389  E0 00     	cpx	#0
 1066  00:F38B  F0 38     	beq	.l4
 1067  00:F38D  E0 08     	cpx	#8
 1068                     	bhs	.l5
       00:F38F  B0 37     	bcs	.l5
 1069                     	; -- fading
 1070  00:F391  A0 03     	ldy	#3
 1071  00:F393  86 FA     	stx	<__bl
 1072                     	stwz	<__dx
       00:F395  64 FE     	stz	LOW_BYTE <__dx
       00:F397  64 FF     	stz	HIGH_BYTE <__dx
 1073  00:F399  46 FA     .l1:	lsr	<__bl
 1074  00:F39B  90 0D     	bcc	.l2
 1075                     	addw	<__ax,<__dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:F39D  18        	clc
       00:F39E  A5 FE     	lda	LOW_BYTE <__dx
       00:F3A0  65 F8     	adc	LOW_BYTE <__ax
       00:F3A2  85 FE     	sta	LOW_BYTE <__dx
       00:F3A4  A5 FF     	lda	HIGH_BYTE <__dx
       00:F3A6  65 F9     	adc	HIGH_BYTE <__ax
       00:F3A8  85 FF     	sta	HIGH_BYTE <__dx
                          .endif
 1076                     .l2:	aslw	<__ax
       00:F3AA  06 F8     	asl	<__ax		; word-sized value (at stated
       00:F3AC  26 F9     	rol	<__ax+1		; memory location)
 1077  00:F3AE  88        	dey
 1078  00:F3AF  D0 E8     	bne	.l1
 1079  00:F3B1  A5 FF     	lda	<__dh
 1080  00:F3B3  4A        	lsr	A
 1081  00:F3B4  66 FE     	ror	<__dl
 1082  00:F3B6  4A        	lsr	A
 1083  00:F3B7  66 FE     	ror	<__dl
 1084  00:F3B9  4A        	lsr	A
 1085  00:F3BA  66 FE     	ror	<__dl
 1086                     	; -- set color
 1087  00:F3BC  A6 FE     	ldx	<__dl
 1088  00:F3BE  8E 04 04  .l3:	stx	color_data_l
 1089  00:F3C1  8D 05 04  	sta	color_data_h
 1090  00:F3C4  60        	rts
 1091                     	; -- black
 1092  00:F3C5  62        .l4:	cla
 1093  00:F3C6  80 F6     	bra	.l3
 1094                     	; -- full
 1095  00:F3C8  A6 F8     .l5:	ldx	<__al
 1096  00:F3CA  A5 F9     	lda	<__ah
 1097  00:F3CC  80 F0     	bra	.l3
 1098                     
 1099                     ; set_color_rgb(int index [color_reg], char r [__al], char g [__ah], char b)
 1100                     ; ----
 1101                     ; set one palette entry to the specified color
 1102                     ; ----
 1103                     ; index: index in the palette (0-511)
 1104                     ; r:	red	RED:	bit 3-5
 1105                     ; g:	green	GREEN:	bit 6-8
 1106                     ; b:	blue	BLUE:	bit 0-2
 1107                     ; ----
 1108                     
 1109  00:F3CE            _set_color_rgb.4:
 1110  00:F3CE  8A        	txa
 1111  00:F3CF  29 07     	and	#$7
 1112  00:F3D1  85 02     	sta	<__temp
 1113  00:F3D3  A5 F8     	lda	<__al
 1114  00:F3D5  0A        	asl	A
 1115  00:F3D6  0A        	asl	A
 1116  00:F3D7  0A        	asl	A
 1117  00:F3D8  05 02     	ora	<__temp
 1118  00:F3DA  0A        	asl	A
 1119  00:F3DB  0A        	asl	A
 1120  00:F3DC  85 02     	sta	<__temp
 1121  00:F3DE  A5 F9     	lda	<__ah
 1122  00:F3E0  4A        	lsr	A
 1123  00:F3E1  66 02     	ror	<__temp
 1124  00:F3E3  4A        	lsr	A
 1125  00:F3E4  66 02     	ror	<__temp
 1126  00:F3E6  A6 02     	ldx	<__temp
 1127  00:F3E8  8E 04 04  	stx	color_data_l
 1128  00:F3EB  8D 05 04  	sta	color_data_h
 1129  00:F3EE  60        	rts
 1130                     
 1131                     ; put_tile(int tile_num [__dx], int position)
 1132                     ; put_tile(int tile_num [__dx], char x [__al], char y)
 1133                     ; ----
 1134                     ; draw a single 8x8 or 16x16 tile at a given position
 1135                     ; ----
 1136                     ; pattern:	vram address of the tile pattern
 1137                     ; position:	position on screen where to put the tile
 1138                     ; ----
 1139                     
 1140  00:F3EF            _put_tile.3:
 1141  00:F3EF  A5 F8     	lda	<__al
 1142  00:F3F1  AC EA 26  	ldy	maptiletype
 1143  00:F3F4  C0 08     	cpy	#8
 1144  00:F3F6  F0 08     	beq	.l1
 1145                     	; --
 1146  00:F3F8  0A        	asl	A
 1147  00:F3F9  22        	sax
 1148  00:F3FA  0A        	asl	A
 1149  00:F3FB  20 19 E4  	jsr	calc_vram_addr
 1150  00:F3FE  80 42     	bra	_put_tile_16
 1151                     	; --
 1152  00:F400  22        .l1:	sax
 1153  00:F401  20 19 E4  	jsr	calc_vram_addr
 1154  00:F404  80 0B     	bra	_put_tile_8
 1155  00:F406            _put_tile.2:
 1156                     	__stw	<__di
       00:F406  86 F0     	stx	<__di
       00:F408  85 F1     	sta	<__di+1
 1157  00:F40A  AC EA 26  	ldy	maptiletype
 1158  00:F40D  C0 08     	cpy	#8
 1159  00:F40F  D0 31     	bne	_put_tile_16
 1160  00:F411            _put_tile_8:
 1161  00:F411  20 02 E4  	jsr	set_write
 1162                     	; -- calculate tile vram address
 1163  00:F414  43 04     	tma	#2
 1164  00:F416  48        	pha
 1165  00:F417  AD F2 26  	lda	mapctablebank
 1166  00:F41A  53 04     	tam	#2
 1167                     	stb	mapctable,<__bx
       00:F41C  AD F3 26  	lda	mapctable
       00:F41F  85 FA     	sta	<__bx
 1168  00:F421  AD F4 26  	lda	mapctable+1
 1169  00:F424  29 1F     	and	#$1F
 1170  00:F426  09 40     	ora	#$40
 1171  00:F428  85 FB     	sta	<__bx+1
 1172  00:F42A  A5 FE     	lda	<__dl
 1173  00:F42C  A8        	tay
 1174                     	add	maptilebase
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:F42D  18        	clc
       00:F42E  6D EE 26  	adc	maptilebase
                          .endif
 1175  00:F431  AA        	tax
 1176  00:F432  62        	cla
 1177  00:F433  6D EF 26  	adc	maptilebase+1
 1178  00:F436  71 FA     	adc	[__bx],Y
 1179                     	; -- copy tile
 1180  00:F438  8E 02 00  	stx	video_data_l
 1181  00:F43B  8D 03 00  	sta	video_data_h
 1182  00:F43E  68        	pla
 1183  00:F43F  53 04     	tam	#2
 1184  00:F441  60        	rts
 1185  00:F442            _put_tile_16:
 1186  00:F442  20 02 E4  	jsr	set_write
 1187                     	; -- calculate tile vram address
 1188  00:F445  43 04     	tma	#2
 1189  00:F447  48        	pha
 1190  00:F448  AD F2 26  	lda	mapctablebank
 1191  00:F44B  53 04     	tam	#2
 1192                     	stb	mapctable,<__bx
       00:F44D  AD F3 26  	lda	mapctable
       00:F450  85 FA     	sta	<__bx
 1193  00:F452  AD F4 26  	lda	mapctable+1
 1194  00:F455  29 1F     	and	#$1F
 1195  00:F457  09 40     	ora	#$40
 1196  00:F459  85 FB     	sta	<__bx+1
 1197  00:F45B  64 FF     	stz	<__dh
 1198  00:F45D  A5 FE     	lda	<__dl
 1199  00:F45F  A8        	tay
 1200  00:F460  0A        	asl	A
 1201  00:F461  26 FF     	rol	<__dh
 1202  00:F463  0A        	asl	A
 1203  00:F464  26 FF     	rol	<__dh
 1204                     	add	maptilebase
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:F466  18        	clc
       00:F467  6D EE 26  	adc	maptilebase
                          .endif
 1205  00:F46A  85 FE     	sta	<__dl
 1206  00:F46C  A5 FF     	lda	<__dh
 1207  00:F46E  6D EF 26  	adc	maptilebase+1
 1208  00:F471  71 FA     	adc	[__bx],Y
 1209  00:F473  85 FF     	sta	<__dh
 1210                     	; -- copy tile
 1211                     	stw	<__dx,video_data
       00:F475  A5 FE     	lda	LOW_BYTE <__dx
       00:F477  8D 02 00  	sta	LOW_BYTE video_data
       00:F47A  A5 FF     	lda	HIGH_BYTE <__dx
       00:F47C  8D 03 00  	sta	HIGH_BYTE video_data
 1212                     	incw	<__dx
       00:F47F  E6 FE     	inc	<__dx		; value at stated memory
       00:F481  D0 02     	bne	.x_00296		; location
       00:F483  E6 FF     	inc	<__dx+1
       00:F485            .x_00296:
 1213                     	stw	<__dx,video_data
       00:F485  A5 FE     	lda	LOW_BYTE <__dx
       00:F487  8D 02 00  	sta	LOW_BYTE video_data
       00:F48A  A5 FF     	lda	HIGH_BYTE <__dx
       00:F48C  8D 03 00  	sta	HIGH_BYTE video_data
 1214                     	incw	<__dx
       00:F48F  E6 FE     	inc	<__dx		; value at stated memory
       00:F491  D0 02     	bne	.x_00298		; location
       00:F493  E6 FF     	inc	<__dx+1
       00:F495            .x_00298:
 1215                     	vreg	#0
       00:F495  A9 00     	lda	#0
       00:F497  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:F499  03 00     	st0	#0
                          .else
                          .endif
 1216                     	addw	bat_width,<__di,video_data
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       00:F49B  18        	clc
       00:F49C  A5 F0     	lda	LOW_BYTE <__di
       00:F49E  6D 06 27  	adc	LOW_BYTE bat_width
       00:F4A1  8D 02 00  	sta	LOW_BYTE video_data
       00:F4A4  A5 F1     	lda	HIGH_BYTE <__di
       00:F4A6  6D 07 27  	adc	HIGH_BYTE bat_width
       00:F4A9  8D 03 00  	sta	HIGH_BYTE video_data
                          .else
                          .endif
 1217                     	vreg	#2
       00:F4AC  A9 02     	lda	#2
       00:F4AE  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:F4B0  03 02     	st0	#2
                          .else
                          .endif
 1218                     	stw	<__dx,video_data
       00:F4B2  A5 FE     	lda	LOW_BYTE <__dx
       00:F4B4  8D 02 00  	sta	LOW_BYTE video_data
       00:F4B7  A5 FF     	lda	HIGH_BYTE <__dx
       00:F4B9  8D 03 00  	sta	HIGH_BYTE video_data
 1219                     	incw	<__dx
       00:F4BC  E6 FE     	inc	<__dx		; value at stated memory
       00:F4BE  D0 02     	bne	.x_00303		; location
       00:F4C0  E6 FF     	inc	<__dx+1
       00:F4C2            .x_00303:
 1220                     	stw	<__dx,video_data
       00:F4C2  A5 FE     	lda	LOW_BYTE <__dx
       00:F4C4  8D 02 00  	sta	LOW_BYTE video_data
       00:F4C7  A5 FF     	lda	HIGH_BYTE <__dx
       00:F4C9  8D 03 00  	sta	HIGH_BYTE video_data
 1221  00:F4CC  68        	pla
 1222  00:F4CD  53 04     	tam	#2
 1223  00:F4CF  60        	rts
 1224                     
 1225                     ; map_get_tile(char x [__dl], char y)
 1226                     ; map_put_tile(char x [__dl], char y [__dh], char tile)
 1227                     ; ----
 1228                     
 1229  00:F4D0            _map_get_tile.2:
 1230  00:F4D0  86 FF     	stx	<__dh
 1231  00:F4D2  20 E2 F4  	jsr	_map_calc_tile_addr
 1232                     	; --
 1233  00:F4D5  B2 FC     	lda	[__cx]
 1234  00:F4D7  AA        	tax
 1235  00:F4D8  62        	cla
 1236  00:F4D9  60        	rts
 1237                     
 1238  00:F4DA            _map_put_tile.3:
 1239  00:F4DA  DA        	phx
 1240  00:F4DB  20 E2 F4  	jsr	_map_calc_tile_addr
 1241  00:F4DE  68        	pla
 1242  00:F4DF  92 FC     	sta	[__cx]
 1243  00:F4E1  60        	rts
 1244                     
 1245                     ; map_calc_tile_addr(char x [__dl], char y [__dh])
 1246                     ; ----
 1247  00:F4E2            _map_calc_tile_addr:
 1248  00:F4E2  A6 FF     	ldx	<__dh
 1249  00:F4E4  AD E7 26  	lda	mapwidth+1
 1250  00:F4E7  F0 08     	beq	.l1
 1251  00:F4E9  86 FD     	stx	<__ch
 1252  00:F4EB  A5 FE     	lda	<__dl
 1253  00:F4ED  85 FC     	sta	<__cl
 1254  00:F4EF  80 13     	bra	.l2
 1255                     	; --
 1256  00:F4F1  86 F8     .l1:	stx	<__al
 1257  00:F4F3  AD E6 26  	lda	mapwidth
 1258  00:F4F6  85 FA     	sta	<__bl
 1259  00:F4F8  20 1E E6  	jsr	mulu8
 1260                     	; --
 1261  00:F4FB  A5 FC     	lda	<__cl
 1262                     	add	<__dl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:F4FD  18        	clc
       00:F4FE  65 FE     	adc	<__dl
                          .endif
 1263  00:F500  90 02     	bcc	.l2
 1264  00:F502  E6 FD     	inc	<__ch
 1265                     	; --
 1266                     .l2:	add	mapaddr
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:F504  18        	clc
       00:F505  6D E4 26  	adc	mapaddr
                          .endif
 1267  00:F508  85 FC     	sta	<__cl
 1268  00:F50A  AD E5 26  	lda	mapaddr+1
 1269  00:F50D  29 1F     	and	#$1F
 1270  00:F50F  65 FD     	adc	<__ch
 1271  00:F511  AA        	tax
 1272                     	; --
 1273                     ;	rol	A
 1274                     ;	rol	A
 1275                     ;	rol	A
 1276                     ;	rol	A
 1277  00:F512  4A        	lsr	A
 1278  00:F513  4A        	lsr	A
 1279  00:F514  4A        	lsr	A
 1280  00:F515  4A        	lsr	A
 1281  00:F516  4A        	lsr	A
 1282  00:F517  29 0F     	and	#$0F
 1283                     	add	mapbank
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:F519  18        	clc
       00:F51A  6D E3 26  	adc	mapbank
                          .endif
 1284  00:F51D  53 08     	tam	#3
 1285                     	; --
 1286  00:F51F  8A        	txa
 1287  00:F520  29 1F     	and	#$1F
 1288  00:F522  09 60     	ora	#$60
 1289  00:F524  85 FD     	sta	<__ch
 1290  00:F526  A6 FC     	ldx	<__cl
 1291  00:F528  60        	rts
 1292                     
 1293                     ; scroll(char num, int x, int y, char top, char bottom, char disp)
 1294                     ; ----
 1295                     ; set screen scrolling
 1296                     ; ----
 1297                     
 1298  00:F529            _scroll:
 1299  00:F529  A0 08     	ldy	#8
 1300  00:F52B  B1 00     	lda	[__sp],Y
 1301  00:F52D  29 03     	and	#$03
 1302                     	; --
 1303  00:F52F  22        	sax
 1304  00:F530  29 C0     	and	#$C0
 1305  00:F532  09 01     	ora	#$01
 1306  00:F534  9D 2A 27  	sta	scroll_cr,X
 1307  00:F537  B2 00     	lda	[__sp]
 1308  00:F539  1A        	inc	A
 1309  00:F53A  9D 26 27  	sta	scroll_bottom,X
 1310  00:F53D  A0 02     	ldy	#2
 1311  00:F53F  B1 00     	lda	[__sp],Y
 1312  00:F541  9D 22 27  	sta	scroll_top,X
 1313  00:F544  A0 04     	ldy	#4
 1314  00:F546  B1 00     	lda	[__sp],Y
 1315  00:F548  9D 1A 27  	sta	scroll_yl,X
 1316  00:F54B  C8        	iny
 1317  00:F54C  B1 00     	lda	[__sp],Y
 1318  00:F54E  9D 1E 27  	sta	scroll_yh,X
 1319  00:F551  C8        	iny
 1320  00:F552  B1 00     	lda	[__sp],Y
 1321  00:F554  9D 12 27  	sta	scroll_xl,X
 1322  00:F557  C8        	iny
 1323  00:F558  B1 00     	lda	[__sp],Y
 1324  00:F55A  9D 16 27  	sta	scroll_xh,X
 1325                     	__addmi	#10,__sp
                0000      .if (#10 = 1)
                          .else
                0000      .if (#10 = -1)
                          .else
       00:F55D  A8        	tay			; 2
       00:F55E  18        	clc			; 2
       00:F55F  A5 00     	lda	<__sp		; 4
       00:F561  69 0A     	adc	#low(#10)	; 2
       00:F563  85 00     	sta	<__sp		; 4
                0001      .if (#10 < 256) & (#10 >= 0)
       00:F565  90 02     	bcc	.x00308		; 4(2)
       00:F567  E6 01     	inc	<__sp+1		; 0(6)
       00:F569            .x00308:
                          .else
                          .endif
       00:F569  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
 1326  00:F56A  60        	rts
 1327                     
 1328                     ; scroll_disable(char num)
 1329                     ; ----
 1330                     ; disable screen scrolling for a scroll region
 1331                     ; ----
 1332                     
 1333  00:F56B            _scroll_disable:
 1334  00:F56B  BD 2A 27  	lda	scroll_cr,X
 1335  00:F56E  29 FE     	and	#$fe
 1336  00:F570  9D 2A 27  	sta	scroll_cr,X
 1337  00:F573  60        	rts
 1338                     
 1339                     ; set_screen_size(char size)
 1340                     ; ----
 1341                     ; set screen virtual size
 1342                     ; ----
 1343                     
 1344  00:F574            _set_screen_size:
 1345  00:F574  8A        	txa
 1346  00:F575  4C 62 E4  	jmp	set_bat_size
 1347                     
 1348                     ; set_xres(int xres)
 1349                     ; ----
 1350                     ; set horizontal display resolution
 1351                     ; ----
 1352                     
 1353  00:F578            _set_xres.1:
 1354  00:F578  A9 04     	lda	#XRES_SOFT
 1355  00:F57A  85 FC     	sta	<__cl
 1356  00:F57C            _set_xres.2:
 1357  00:F57C  20 50 E4  	jsr	set_xres
 1358  00:F57F  A6 F8     	ldx	<__al
 1359  00:F581  A5 F9     	lda	<__ah
 1360  00:F583  60        	rts
 1361                     
 1362                     
 1363                     ; ------------------------
 1364                     ; Graphics functions
 1365                     ; ------------------------
 1366                     
 1367                     ; readvram
 1368                     ; ----
 1369                     ; leftover from asm library
 1370                     ; needed for 'a = vram[n]'
 1371                     ; semantic
 1372                     ; ----
 1373  00:F584            readvram:
 1374  00:F584  A0 01     	ldy	#1
 1375  00:F586  84 F7     	sty	<vdc_reg
 1376  00:F588  8C 00 00  	sty	video_reg
 1377  00:F58B  8E 02 00  	stx	video_data_l
 1378  00:F58E  8D 03 00  	sta	video_data_h
 1379                     	vreg	#$02
       00:F591  A9 02     	lda	#$02
       00:F593  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:F595  03 02     	st0	#$02
                          .else
                          .endif
 1380  00:F597  AE 02 00  	ldx	video_data_l
 1381  00:F59A  AD 03 00  	lda	video_data_h
 1382  00:F59D  60        	rts
 1383                     
 1384                     
 1385                     ; writevram
 1386                     ; ----
 1387                     ; leftover from asm library
 1388                     ; needed for 'vram[n] = a'
 1389                     ; semantic
 1390                     ; ----
 1391  00:F59E            writevram:
 1392  00:F59E  A8        	tay
 1393  00:F59F  64 F7     	stz	<vdc_reg
 1394  00:F5A1  9C 00 00  	stz	video_reg
 1395  00:F5A4  B2 00     	lda	[__sp]
 1396  00:F5A6  8D 02 00  	sta	video_data_l
 1397                     	incw	<__sp
       00:F5A9  E6 00     	inc	<__sp		; value at stated memory
       00:F5AB  D0 02     	bne	.x_00310		; location
       00:F5AD  E6 01     	inc	<__sp+1
       00:F5AF            .x_00310:
 1398  00:F5AF  B2 00     	lda	[__sp]
 1399  00:F5B1  8D 03 00  	sta	video_data_h
 1400                     	incw	<__sp
       00:F5B4  E6 00     	inc	<__sp		; value at stated memory
       00:F5B6  D0 02     	bne	.x_00311		; location
       00:F5B8  E6 01     	inc	<__sp+1
       00:F5BA            .x_00311:
 1401                     	vreg	#2
       00:F5BA  A9 02     	lda	#2
       00:F5BC  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:F5BE  03 02     	st0	#2
                          .else
                          .endif
 1402  00:F5C0  8E 02 00  	stx	video_data_l
 1403  00:F5C3  8C 03 00  	sty	video_data_h
 1404  00:F5C6  60        	rts
 1405                     
 1406                     
 1407                     ; gfx_setbgpal(char pal)
 1408                     ; ----
 1409                     ; set default major palette for gfx_* func's
 1410                     ; ----
 1411                     
 1412  00:F5C7            _gfx_setbgpal:
 1413  00:F5C7  8A        	txa
 1414  00:F5C8  0A        	asl	A
 1415  00:F5C9  0A        	asl	A
 1416  00:F5CA  0A        	asl	A
 1417  00:F5CB  0A        	asl	A
 1418  00:F5CC  8D 7D 29  	sta	gfx_pal
 1419  00:F5CF  60        	rts
 1420                     
 1421                     
 1422                     ; gfx_init(int start_vram_addr)
 1423                     ; ----
 1424                     ; initialize graphics mode
 1425                     ; - points graphics map to tiles at start_vram_addr
 1426                     ; ----
 1427                     
 1428  00:F5D0            _gfx_init:
 1429                     	maplibfunc lib2_gfx_init
       00:F5D0  A8        	tay
       00:F5D1  43 20     	tma	#page(lib2_gfx_init)
       00:F5D3  48        	pha
       00:F5D4  A9 01     	lda	#bank(lib2_gfx_init)
       00:F5D6  53 20     	tam	#page(lib2_gfx_init)
       00:F5D8  98        	tya
       00:F5D9  20 3E AC  	jsr	lib2_gfx_init
       00:F5DC  A8        	tay
       00:F5DD  68        	pla
       00:F5DE  53 20     	tam	#page(lib2_gfx_init)
       00:F5E0  98        	tya
 1430  00:F5E1  60        	rts
 1431                     
 1432           0001      	.bank LIB2_BANK
 1433  01:AC3E            lib2_gfx_init:
 1434                     	__stw	<__dx	; vram addr
       01:AC3E  86 FE     	stx	<__dx	
       01:AC40  85 FF     	sta	<__dx	+1
 1435                     
 1436                     	lsrw	<__dx	; shift address to make char pattern
       01:AC42  46 FF     	lsr	<__dx	+1		; value (at stated memory
       01:AC44  66 FE     	ror	<__dx			; location)
 1437                     	lsrw	<__dx
       01:AC46  46 FF     	lsr	<__dx+1		; value (at stated memory
       01:AC48  66 FE     	ror	<__dx		; location)
 1438                     	lsrw	<__dx
       01:AC4A  46 FF     	lsr	<__dx+1		; value (at stated memory
       01:AC4C  66 FE     	ror	<__dx		; location)
 1439                     	lsrw	<__dx
       01:AC4E  46 FF     	lsr	<__dx+1		; value (at stated memory
       01:AC50  66 FE     	ror	<__dx		; location)
 1440  01:AC52  A5 FF     	lda	<__dx+1
 1441  01:AC54  29 0F     	and	#$0f
 1442  01:AC56  0D 7D 29  	ora	gfx_pal	; and add major palette info
 1443  01:AC59  85 FF     	sta	<__dx+1
 1444                     
 1445                     	setvwaddr $0
                          	stw	#$0,<__di
       01:AC5B  A9 00     	lda	LOW_BYTE #$0
       01:AC5D  85 F0     	sta	LOW_BYTE <__di
       01:AC5F  A9 00     	lda	HIGH_BYTE #$0
       01:AC61  85 F1     	sta	HIGH_BYTE <__di
       01:AC63  20 02 E4  	jsr	set_write
 1446                     	; --
 1447  01:AC66  AC 08 27  	ldy	bat_height
 1448  01:AC69  AE 06 27  .l2:	ldx	bat_width
 1449                     	; --
 1450                     .l3:	stw	<__dx,video_data
       01:AC6C  A5 FE     	lda	LOW_BYTE <__dx
       01:AC6E  8D 02 00  	sta	LOW_BYTE video_data
       01:AC71  A5 FF     	lda	HIGH_BYTE <__dx
       01:AC73  8D 03 00  	sta	HIGH_BYTE video_data
 1451                     	incw	<__dx
       01:AC76  E6 FE     	inc	<__dx		; value at stated memory
       01:AC78  D0 02     	bne	.x_00322		; location
       01:AC7A  E6 FF     	inc	<__dx+1
       01:AC7C            .x_00322:
 1452  01:AC7C  CA        	dex
 1453  01:AC7D  D0 ED     	bne	.l3
 1454  01:AC7F  88        	dey
 1455  01:AC80  D0 E7     	bne	.l2
 1456  01:AC82  60        	rts
 1457           0000      	.bank LIB1_BANK
 1458                     
 1459                     ; gfx_clear(int start_vram_addr)
 1460                     ; ----
 1461                     ; Clear the values in the graphics tiles
 1462                     ; - places zeroes in graphics tiles at start_vram_addr
 1463                     ; ----
 1464                     
 1465  00:F5E2            _gfx_clear:
 1466                     	__stw	<__di		; start_vram_addr
       00:F5E2  86 F0     	stx	<__di		
       00:F5E4  85 F1     	sta	<__di		+1
 1467  00:F5E6  20 02 E4  	jsr	set_write	; setup VRAM addr for writing
 1468                     
 1469  00:F5E9  AD 08 27  	lda	bat_height
 1470  00:F5EC  85 FA     	sta	<__bl		; loop for all lines
 1471  00:F5EE  AE 06 27  .l2:	ldx	bat_width	; loop for all characters
 1472  00:F5F1  A0 08     .l3:	ldy	#8		; loop for 16 words
 1473                     .l4:	stw	#0,video_data	; unrolled a bit (8 iterations
       00:F5F3  A9 00     	lda	LOW_BYTE #0
       00:F5F5  8D 02 00  	sta	LOW_BYTE video_data	
       00:F5F8  A9 00     	lda	HIGH_BYTE #0
       00:F5FA  8D 03 00  	sta	HIGH_BYTE video_data	
 1474                     	stw	#0,video_data	; @ 2 words each iteration)
       00:F5FD  A9 00     	lda	LOW_BYTE #0
       00:F5FF  8D 02 00  	sta	LOW_BYTE video_data	
       00:F602  A9 00     	lda	HIGH_BYTE #0
       00:F604  8D 03 00  	sta	HIGH_BYTE video_data	
 1475  00:F607  88        	dey
 1476  00:F608  D0 E9     	bne	.l4
 1477  00:F60A  CA        	dex
 1478  00:F60B  D0 E4     	bne	.l3
 1479  00:F60D  C6 FA     	dec	<__bl
 1480  00:F60F  D0 DD     	bne	.l2
 1481  00:F611  60        	rts
 1482                     
 1483                     
 1484                     ; gfx_plot(int x [__bx] int y [__cx] char color [reg acc])
 1485                     ; ----
 1486                     ; Plot a point at location (x,y) in color
 1487                     ; ----
 1488                     
 1489  00:F612            _gfx_plot.3:
 1490                     	maplibfunc	lib2_gfx_plot.3
       00:F612  A8        	tay
       00:F613  43 20     	tma	#page(lib2_gfx_plot.3)
       00:F615  48        	pha
       00:F616  A9 01     	lda	#bank(lib2_gfx_plot.3)
       00:F618  53 20     	tam	#page(lib2_gfx_plot.3)
       00:F61A  98        	tya
       00:F61B  20 66 AF  	jsr	lib2_gfx_plot.3
       00:F61E  A8        	tay
       00:F61F  68        	pla
       00:F620  53 20     	tam	#page(lib2_gfx_plot.3)
       00:F622  98        	tya
 1491  00:F623  60        	rts
 1492                     
 1493                     
 1494                     ; gfx_point(int x [__bx], int y [__cx])
 1495                     ; ----
 1496                     ; Returns color of point at location (x,y)
 1497                     ; ----
 1498                     
 1499  00:F624            _gfx_point.2:
 1500                     	maplibfunc	lib2_gfx_point.2
       00:F624  A8        	tay
       00:F625  43 20     	tma	#page(lib2_gfx_point.2)
       00:F627  48        	pha
       00:F628  A9 01     	lda	#bank(lib2_gfx_point.2)
       00:F62A  53 20     	tam	#page(lib2_gfx_point.2)
       00:F62C  98        	tya
       00:F62D  20 21 B0  	jsr	lib2_gfx_point.2
       00:F630  A8        	tay
       00:F631  68        	pla
       00:F632  53 20     	tam	#page(lib2_gfx_point.2)
       00:F634  98        	tya
 1501  00:F635  60        	rts
 1502                     
 1503                     
 1504                     ; gfx_line(int x1 [__bx], int y1 [__cx], int x2 [__si], int y2 [__bp], char color [reg acc])
 1505                     ; ----
 1506                     ; Plot a line from location (x1,y1) to location (x2,y2) in color
 1507                     ; ----
 1508                     
 1509  00:F636            _gfx_line.5:
 1510                     	maplibfunc	lib2_gfx_line.5
       00:F636  A8        	tay
       00:F637  43 20     	tma	#page(lib2_gfx_line.5)
       00:F639  48        	pha
       00:F63A  A9 01     	lda	#bank(lib2_gfx_line.5)
       00:F63C  53 20     	tam	#page(lib2_gfx_line.5)
       00:F63E  98        	tya
       00:F63F  20 DC AC  	jsr	lib2_gfx_line.5
       00:F642  A8        	tay
       00:F643  68        	pla
       00:F644  53 20     	tam	#page(lib2_gfx_line.5)
       00:F646  98        	tya
 1511  00:F647  60        	rts
 1512                     
 1513                     ;---------------------------------
 1514                     
 1515                     ;
 1516                     ; Change to context LIB2_BANK for these functions
 1517                     ; because they are larger than LIB1_BANK functions
 1518                     ; should be
 1519                     ;
 1520                     
 1521           0001      	.bank	LIB2_BANK
 1522                     
 1523                     ; put_number(int number, char n, int offset)
 1524                     ; put_number(int number, char n, char x, char y)
 1525                     ; ----
 1526                     
 1527  01:AC83            lib2_put_number.4:
 1528  01:AC83  A5 FA     	lda	<__bl
 1529  01:AC85  20 64 EE  	jsr	_put.xy
 1530  01:AC88  80 03     	bra	putnum.main
 1531  01:AC8A            lib2_put_number.3:
 1532  01:AC8A  20 6B EE  	jsr	_put.vram
 1533  01:AC8D            putnum.main:
 1534  01:AC8D  A6 FC     	ldx	<__cl
 1535                     	; --
 1536  01:AC8F  64 F8     	stz	<__al ; sign flag
 1537  01:AC91  CA        	dex
 1538  01:AC92  E0 10     	cpx	#16
 1539                     	bhs	.l5
       01:AC94  B0 45     	bcs	.l5
 1540                     	; --
 1541  01:AC96  A5 FF     	lda	<__dh ; check sign
 1542  01:AC98  10 0F     	bpl	.l1
 1543                     	negw	<__dx ; negate
       01:AC9A  62        	cla			; (at stated memory location)
                          	sub	<__dx		; 2's complement
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AC9B  38        	sec
       01:AC9C  E5 FE     	sbc	<__dx		
                          .endif
       01:AC9E  85 FE     	sta	<__dx
       01:ACA0  62        	cla
       01:ACA1  E5 FF     	sbc	<__dx+1
       01:ACA3  85 FF     	sta	<__dx+1
 1544  01:ACA5  A9 01     	lda	#1
 1545  01:ACA7  85 F8     	sta	<__al
 1546                     	; --
 1547  01:ACA9  20 08 E6  .l1:	jsr	divu10
 1548  01:ACAC  09 10     	ora	#$10
 1549  01:ACAE  48        	pha
 1550  01:ACAF  CA        	dex
 1551  01:ACB0  30 15     	bmi	.l3
 1552                     	tstw	<__dx
       01:ACB2  A5 FE     	lda	<__dx		; value at stated memory
       01:ACB4  05 FF     	ora	<__dx+1		; location is zero
 1553  01:ACB6  D0 F1     	bne	.l1
 1554                     	; --
 1555  01:ACB8  A5 F8     	lda	<__al
 1556  01:ACBA  F0 07     	beq	.l2
 1557  01:ACBC  A9 0D     	lda	#$0D
 1558  01:ACBE  48        	pha
 1559  01:ACBF  CA        	dex
 1560  01:ACC0  30 05     	bmi	.l3
 1561                     	; --
 1562  01:ACC2  62        	cla
 1563  01:ACC3  48        .l2:	pha
 1564  01:ACC4  CA        	dex
 1565  01:ACC5  10 FC     	bpl	.l2
 1566                     	; --
 1567  01:ACC7  A6 FC     .l3:	ldx	<__cl
 1568  01:ACC9  68        .l4:	pla
 1569                     	add	_font_base
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:ACCA  18        	clc
       01:ACCB  6D 79 27  	adc	_font_base
                          .endif
 1570  01:ACCE  8D 02 00  	sta	video_data_l
 1571  01:ACD1  62        	cla
 1572  01:ACD2  6D 7A 27  	adc	_font_base+1
 1573  01:ACD5  8D 03 00  	sta	video_data_h
 1574  01:ACD8  CA        	dex
 1575  01:ACD9  D0 EE     	bne	.l4
 1576  01:ACDB  60        .l5:	rts
 1577                     
 1578                     
 1579                     ; gfx_line(int x1 [__bx], int y1 [__cx], int x2 [__si], int y2 [__bp], char color [reg acc])
 1580                     ; ----
 1581                     ; Plot a line from location (x1,y1) to locations (x2,y2) in color
 1582                     ; ----
 1583  01:ACDC            lib2_gfx_line.5:		; Bresenham line drawing algorithm
 1584  01:ACDC  8E 8B 29  	stx	line_color
 1585                     
 1586                     	cmpw	<__cx,<__bp	; make y always ascending by swapping
       01:ACDF  A5 ED     	lda	HIGH_BYTE <__bp	
       01:ACE1  C5 FD     	cmp	HIGH_BYTE <__cx
       01:ACE3  D0 04     	bne	.x_00334
       01:ACE5  A5 EC     	lda	LOW_BYTE <__bp	
       01:ACE7  C5 FC     	cmp	LOW_BYTE <__cx
       01:ACE9            .x_00334:
 1587                     	bhs	.l1		; co-ordinates
       01:ACE9  B0 26     	bcs	.l1		
 1588                     				; jump over swap if bp > cx
 1589                     
 1590                     	stw	<__bp,line_curry	; swap coordinates
       01:ACEB  A5 EC     	lda	LOW_BYTE <__bp
       01:ACED  8D 80 29  	sta	LOW_BYTE line_curry	
       01:ACF0  A5 ED     	lda	HIGH_BYTE <__bp
       01:ACF2  8D 81 29  	sta	HIGH_BYTE line_curry	
 1591                     	stw	<__cx,<__bp
       01:ACF5  A5 FC     	lda	LOW_BYTE <__cx
       01:ACF7  85 EC     	sta	LOW_BYTE <__bp
       01:ACF9  A5 FD     	lda	HIGH_BYTE <__cx
       01:ACFB  85 ED     	sta	HIGH_BYTE <__bp
 1592                     	stw	<__si,line_currx
       01:ACFD  A5 EE     	lda	LOW_BYTE <__si
       01:ACFF  8D 7E 29  	sta	LOW_BYTE line_currx
       01:AD02  A5 EF     	lda	HIGH_BYTE <__si
       01:AD04  8D 7F 29  	sta	HIGH_BYTE line_currx
 1593                     	stw	<__bx,<__si
       01:AD07  A5 FA     	lda	LOW_BYTE <__bx
       01:AD09  85 EE     	sta	LOW_BYTE <__si
       01:AD0B  A5 FB     	lda	HIGH_BYTE <__bx
       01:AD0D  85 EF     	sta	HIGH_BYTE <__si
 1594                     
 1595  01:AD0F  80 14     	bra	.l2
 1596                     
 1597                     .l1:	stw	<__bx,line_currx
       01:AD11  A5 FA     	lda	LOW_BYTE <__bx
       01:AD13  8D 7E 29  	sta	LOW_BYTE line_currx
       01:AD16  A5 FB     	lda	HIGH_BYTE <__bx
       01:AD18  8D 7F 29  	sta	HIGH_BYTE line_currx
 1598                     	stw	<__cx,line_curry
       01:AD1B  A5 FC     	lda	LOW_BYTE <__cx
       01:AD1D  8D 80 29  	sta	LOW_BYTE line_curry
       01:AD20  A5 FD     	lda	HIGH_BYTE <__cx
       01:AD22  8D 81 29  	sta	HIGH_BYTE line_curry
 1599                     
 1600                     ; now:
 1601                     ;	line_currx and line_curry are start point
 1602                     ;	<__si and <__bp are end point
 1603                     ;	<__bx and <__cx are 'dont care'
 1604                     
 1605  01:AD25            .l2:
 1606  01:AD25  A5 EC     	lda	LOW_BYTE  <__bp
 1607                     	sub	LOW_BYTE  line_curry
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AD27  38        	sec
       01:AD28  ED 80 29  	sbc	LOW_BYTE  line_curry
                          .endif
 1608  01:AD2B  8D 84 29  	sta	LOW_BYTE  line_deltay
 1609  01:AD2E  A5 ED     	lda	HIGH_BYTE <__bp
 1610  01:AD30  ED 81 29  	sbc	HIGH_BYTE line_curry
 1611  01:AD33  8D 85 29  	sta	HIGH_BYTE line_deltay
 1612                     
 1613  01:AD36  A5 EE     	lda	LOW_BYTE  <__si
 1614                     	sub	LOW_BYTE  line_currx
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AD38  38        	sec
       01:AD39  ED 7E 29  	sbc	LOW_BYTE  line_currx
                          .endif
 1615  01:AD3C  8D 82 29  	sta	LOW_BYTE  line_deltax
 1616  01:AD3F  A5 EF     	lda	HIGH_BYTE <__si
 1617  01:AD41  ED 7F 29  	sbc	HIGH_BYTE line_currx
 1618  01:AD44  8D 83 29  	sta	HIGH_BYTE line_deltax
 1619                     
 1620  01:AD47  9C 8A 29  	stz	line_xdir	; 0 = positive
 1621                     
 1622  01:AD4A  AD 83 29  	lda	HIGH_BYTE line_deltax
 1623  01:AD4D  10 14     	bpl	.l3
 1624                     
 1625  01:AD4F  A9 01     	lda	#1
 1626  01:AD51  8D 8A 29  	sta	line_xdir	; 1 = negative
 1627                     	negw	line_deltax
       01:AD54  62        	cla			; (at stated memory location)
                          	sub	line_deltax		; 2's complement
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AD55  38        	sec
       01:AD56  ED 82 29  	sbc	line_deltax		
                          .endif
       01:AD59  8D 82 29  	sta	line_deltax
       01:AD5C  62        	cla
       01:AD5D  ED 83 29  	sbc	line_deltax+1
       01:AD60  8D 83 29  	sta	line_deltax+1
 1628                     
 1629                     ; now:
 1630                     ;	line_deltay is difference from end to start (positive)
 1631                     ;	line_deltax is difference from end to start (positive)
 1632                     ;	line_xdir shows whether to apply deltax positive or negative
 1633                     
 1634                     
 1635  01:AD63            .l3:
 1636                     	cmpw	line_deltax,line_deltay
       01:AD63  AD 85 29  	lda	HIGH_BYTE line_deltay
       01:AD66  CD 83 29  	cmp	HIGH_BYTE line_deltax
       01:AD69  D0 06     	bne	.x_00346
       01:AD6B  AD 84 29  	lda	LOW_BYTE line_deltay
       01:AD6E  CD 82 29  	cmp	LOW_BYTE line_deltax
       01:AD71            .x_00346:
 1637                     	lbhs	.ybiglp		; jump if deltay > |deltax|
       01:AD71  90 03     	bcc	.x_00347
       01:AD73  4C 6F AE  	jmp	.ybiglp		
       01:AD76            .x_00347
 1638                     
 1639  01:AD76            .xbiglp:
 1640                     	__ldw	line_deltay
                0000      .if (1 = 2)
                          .else
       01:AD76  AE 84 29  	ldx	line_deltay
       01:AD79  AD 85 29  	lda	line_deltay+1
                          .endif
 1641                     	__aslw
       01:AD7C  22        	sax
       01:AD7D  0A        	asl	A
       01:AD7E  22        	sax
       01:AD7F  2A        	rol	A
 1642                     	__stw	line_adjust
       01:AD80  8E 88 29  	stx	line_adjust
       01:AD83  8D 89 29  	sta	line_adjust+1
 1643                     	__stw	line_error
       01:AD86  8E 86 29  	stx	line_error
       01:AD89  8D 87 29  	sta	line_error+1
 1644                     
 1645                     	subw	line_deltax,line_adjust
       01:AD8C  38        	sec
       01:AD8D  AD 88 29  	lda	LOW_BYTE line_adjust
       01:AD90  ED 82 29  	sbc	LOW_BYTE line_deltax
       01:AD93  8D 88 29  	sta	LOW_BYTE line_adjust
       01:AD96  AD 89 29  	lda	HIGH_BYTE line_adjust
       01:AD99  ED 83 29  	sbc	HIGH_BYTE line_deltax
       01:AD9C  8D 89 29  	sta	HIGH_BYTE line_adjust
 1646                     	subw	line_deltax,line_adjust
       01:AD9F  38        	sec
       01:ADA0  AD 88 29  	lda	LOW_BYTE line_adjust
       01:ADA3  ED 82 29  	sbc	LOW_BYTE line_deltax
       01:ADA6  8D 88 29  	sta	LOW_BYTE line_adjust
       01:ADA9  AD 89 29  	lda	HIGH_BYTE line_adjust
       01:ADAC  ED 83 29  	sbc	HIGH_BYTE line_deltax
       01:ADAF  8D 89 29  	sta	HIGH_BYTE line_adjust
 1647                     
 1648                     	subw	line_deltax,line_error
       01:ADB2  38        	sec
       01:ADB3  AD 86 29  	lda	LOW_BYTE line_error
       01:ADB6  ED 82 29  	sbc	LOW_BYTE line_deltax
       01:ADB9  8D 86 29  	sta	LOW_BYTE line_error
       01:ADBC  AD 87 29  	lda	HIGH_BYTE line_error
       01:ADBF  ED 83 29  	sbc	HIGH_BYTE line_deltax
       01:ADC2  8D 87 29  	sta	HIGH_BYTE line_error
 1649                     
 1650                     	incw	line_deltax		; used as counter - get both endpoints
       01:ADC5  EE 82 29  	inc	line_deltax				; value at stated memory
       01:ADC8  D0 03     	bne	.x_00355		; location
       01:ADCA  EE 83 29  	inc	line_deltax		+1
       01:ADCD            .x_00355:
 1651                     
 1652  01:ADCD            .xlp1:
 1653                     	stw	line_currx,<__bx	; draw pixel
       01:ADCD  AD 7E 29  	lda	LOW_BYTE line_currx
       01:ADD0  85 FA     	sta	LOW_BYTE <__bx	
       01:ADD2  AD 7F 29  	lda	HIGH_BYTE line_currx
       01:ADD5  85 FB     	sta	HIGH_BYTE <__bx	
 1654                     	stw	line_curry,<__cx
       01:ADD7  AD 80 29  	lda	LOW_BYTE line_curry
       01:ADDA  85 FC     	sta	LOW_BYTE <__cx
       01:ADDC  AD 81 29  	lda	HIGH_BYTE line_curry
       01:ADDF  85 FD     	sta	HIGH_BYTE <__cx
 1655  01:ADE1  AE 8B 29  	ldx	line_color
 1656  01:ADE4  62        	cla
 1657  01:ADE5  20 66 AF  	jsr	lib2_gfx_plot.3
 1658                     
 1659                     	decw	line_deltax		; dec counter
       01:ADE8  38        	sec			; value at stated memory
       01:ADE9  AD 82 29  	lda	line_deltax				; location
       01:ADEC  E9 01     	sbc	#1
       01:ADEE  8D 82 29  	sta	line_deltax		
       01:ADF1  AD 83 29  	lda	line_deltax		+1
       01:ADF4  E9 00     	sbc	#0
       01:ADF6  8D 83 29  	sta	line_deltax		+1
 1660                     	tstw	line_deltax
       01:ADF9  AD 82 29  	lda	line_deltax		; value at stated memory
       01:ADFC  0D 83 29  	ora	line_deltax+1		; location is zero
 1661                     	lbeq	.out
       01:ADFF  D0 03     	bne	.x_00360
       01:AE01  4C 65 AF  	jmp	.out
       01:AE04            .x_00360
 1662                     
 1663  01:AE04  AD 8A 29  	lda	line_xdir		; adjust currx
 1664  01:AE07  F0 13     	beq	.xlppos
 1665                     
 1666                     	decw	line_currx
       01:AE09  38        	sec			; value at stated memory
       01:AE0A  AD 7E 29  	lda	line_currx		; location
       01:AE0D  E9 01     	sbc	#1
       01:AE0F  8D 7E 29  	sta	line_currx
       01:AE12  AD 7F 29  	lda	line_currx+1
       01:AE15  E9 00     	sbc	#0
       01:AE17  8D 7F 29  	sta	line_currx+1
 1667  01:AE1A  80 08     	bra	.xlp2
 1668                     
 1669                     .xlppos:	incw	line_currx
       01:AE1C  EE 7E 29  	inc	line_currx		; value at stated memory
       01:AE1F  D0 03     	bne	.x_00362		; location
       01:AE21  EE 7F 29  	inc	line_currx+1
       01:AE24            .x_00362:
 1670                     
 1671  01:AE24            .xlp2:
 1672  01:AE24  AD 87 29  	lda	HIGH_BYTE line_error
 1673  01:AE27  30 1D     	bmi	.xlp3
 1674                     
 1675                     	addw	line_adjust,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AE29  18        	clc
       01:AE2A  AD 86 29  	lda	LOW_BYTE line_error
       01:AE2D  6D 88 29  	adc	LOW_BYTE line_adjust
       01:AE30  8D 86 29  	sta	LOW_BYTE line_error
       01:AE33  AD 87 29  	lda	HIGH_BYTE line_error
       01:AE36  6D 89 29  	adc	HIGH_BYTE line_adjust
       01:AE39  8D 87 29  	sta	HIGH_BYTE line_error
                          .endif
 1676                     	incw	line_curry
       01:AE3C  EE 80 29  	inc	line_curry		; value at stated memory
       01:AE3F  D0 03     	bne	.x_00364		; location
       01:AE41  EE 81 29  	inc	line_curry+1
       01:AE44            .x_00364:
 1677  01:AE44  80 87     	bra	.xlp1
 1678  01:AE46            .xlp3:
 1679                     	addw	line_deltay,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AE46  18        	clc
       01:AE47  AD 86 29  	lda	LOW_BYTE line_error
       01:AE4A  6D 84 29  	adc	LOW_BYTE line_deltay
       01:AE4D  8D 86 29  	sta	LOW_BYTE line_error
       01:AE50  AD 87 29  	lda	HIGH_BYTE line_error
       01:AE53  6D 85 29  	adc	HIGH_BYTE line_deltay
       01:AE56  8D 87 29  	sta	HIGH_BYTE line_error
                          .endif
 1680                     	addw	line_deltay,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AE59  18        	clc
       01:AE5A  AD 86 29  	lda	LOW_BYTE line_error
       01:AE5D  6D 84 29  	adc	LOW_BYTE line_deltay
       01:AE60  8D 86 29  	sta	LOW_BYTE line_error
       01:AE63  AD 87 29  	lda	HIGH_BYTE line_error
       01:AE66  6D 85 29  	adc	HIGH_BYTE line_deltay
       01:AE69  8D 87 29  	sta	HIGH_BYTE line_error
                          .endif
 1681  01:AE6C  4C CD AD  	jmp	.xlp1
 1682                     
 1683  01:AE6F            .ybiglp:
 1684                     	__ldw	line_deltax
                0000      .if (1 = 2)
                          .else
       01:AE6F  AE 82 29  	ldx	line_deltax
       01:AE72  AD 83 29  	lda	line_deltax+1
                          .endif
 1685                     	__aslw
       01:AE75  22        	sax
       01:AE76  0A        	asl	A
       01:AE77  22        	sax
       01:AE78  2A        	rol	A
 1686                     	__stw	line_adjust
       01:AE79  8E 88 29  	stx	line_adjust
       01:AE7C  8D 89 29  	sta	line_adjust+1
 1687                     	__stw	line_error
       01:AE7F  8E 86 29  	stx	line_error
       01:AE82  8D 87 29  	sta	line_error+1
 1688                     
 1689                     	subw	line_deltay,line_adjust
       01:AE85  38        	sec
       01:AE86  AD 88 29  	lda	LOW_BYTE line_adjust
       01:AE89  ED 84 29  	sbc	LOW_BYTE line_deltay
       01:AE8C  8D 88 29  	sta	LOW_BYTE line_adjust
       01:AE8F  AD 89 29  	lda	HIGH_BYTE line_adjust
       01:AE92  ED 85 29  	sbc	HIGH_BYTE line_deltay
       01:AE95  8D 89 29  	sta	HIGH_BYTE line_adjust
 1690                     	subw	line_deltay,line_adjust
       01:AE98  38        	sec
       01:AE99  AD 88 29  	lda	LOW_BYTE line_adjust
       01:AE9C  ED 84 29  	sbc	LOW_BYTE line_deltay
       01:AE9F  8D 88 29  	sta	LOW_BYTE line_adjust
       01:AEA2  AD 89 29  	lda	HIGH_BYTE line_adjust
       01:AEA5  ED 85 29  	sbc	HIGH_BYTE line_deltay
       01:AEA8  8D 89 29  	sta	HIGH_BYTE line_adjust
 1691                     
 1692                     	subw	line_deltay,line_error
       01:AEAB  38        	sec
       01:AEAC  AD 86 29  	lda	LOW_BYTE line_error
       01:AEAF  ED 84 29  	sbc	LOW_BYTE line_deltay
       01:AEB2  8D 86 29  	sta	LOW_BYTE line_error
       01:AEB5  AD 87 29  	lda	HIGH_BYTE line_error
       01:AEB8  ED 85 29  	sbc	HIGH_BYTE line_deltay
       01:AEBB  8D 87 29  	sta	HIGH_BYTE line_error
 1693                     
 1694                     	incw	line_deltay		; used as counter - get both endpoints
       01:AEBE  EE 84 29  	inc	line_deltay				; value at stated memory
       01:AEC1  D0 03     	bne	.x_00374		; location
       01:AEC3  EE 85 29  	inc	line_deltay		+1
       01:AEC6            .x_00374:
 1695                     
 1696  01:AEC6            .ylp1:
 1697                     	stw	line_currx,<__bx	; draw pixel
       01:AEC6  AD 7E 29  	lda	LOW_BYTE line_currx
       01:AEC9  85 FA     	sta	LOW_BYTE <__bx	
       01:AECB  AD 7F 29  	lda	HIGH_BYTE line_currx
       01:AECE  85 FB     	sta	HIGH_BYTE <__bx	
 1698                     	stw	line_curry,<__cx
       01:AED0  AD 80 29  	lda	LOW_BYTE line_curry
       01:AED3  85 FC     	sta	LOW_BYTE <__cx
       01:AED5  AD 81 29  	lda	HIGH_BYTE line_curry
       01:AED8  85 FD     	sta	HIGH_BYTE <__cx
 1699  01:AEDA  AE 8B 29  	ldx	line_color
 1700  01:AEDD  62        	cla
 1701  01:AEDE  20 66 AF  	jsr	lib2_gfx_plot.3
 1702                     
 1703                     	decw	line_deltay		; dec counter
       01:AEE1  38        	sec			; value at stated memory
       01:AEE2  AD 84 29  	lda	line_deltay				; location
       01:AEE5  E9 01     	sbc	#1
       01:AEE7  8D 84 29  	sta	line_deltay		
       01:AEEA  AD 85 29  	lda	line_deltay		+1
       01:AEED  E9 00     	sbc	#0
       01:AEEF  8D 85 29  	sta	line_deltay		+1
 1704                     	tstw	line_deltay
       01:AEF2  AD 84 29  	lda	line_deltay		; value at stated memory
       01:AEF5  0D 85 29  	ora	line_deltay+1		; location is zero
 1705  01:AEF8  F0 6B     	beq	.out
 1706                     
 1707                     	incw	line_curry
       01:AEFA  EE 80 29  	inc	line_curry		; value at stated memory
       01:AEFD  D0 03     	bne	.x_00379		; location
       01:AEFF  EE 81 29  	inc	line_curry+1
       01:AF02            .x_00379:
 1708                     
 1709  01:AF02  AD 87 29  	lda	HIGH_BYTE line_error
 1710  01:AF05  30 35     	bmi	.ylp2
 1711                     
 1712                     	addw	line_adjust,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AF07  18        	clc
       01:AF08  AD 86 29  	lda	LOW_BYTE line_error
       01:AF0B  6D 88 29  	adc	LOW_BYTE line_adjust
       01:AF0E  8D 86 29  	sta	LOW_BYTE line_error
       01:AF11  AD 87 29  	lda	HIGH_BYTE line_error
       01:AF14  6D 89 29  	adc	HIGH_BYTE line_adjust
       01:AF17  8D 87 29  	sta	HIGH_BYTE line_error
                          .endif
 1713  01:AF1A  AD 8A 29  	lda	line_xdir
 1714  01:AF1D  F0 13     	beq	.ylppos
 1715                     
 1716                     	decw	line_currx
       01:AF1F  38        	sec			; value at stated memory
       01:AF20  AD 7E 29  	lda	line_currx		; location
       01:AF23  E9 01     	sbc	#1
       01:AF25  8D 7E 29  	sta	line_currx
       01:AF28  AD 7F 29  	lda	line_currx+1
       01:AF2B  E9 00     	sbc	#0
       01:AF2D  8D 7F 29  	sta	line_currx+1
 1717  01:AF30  80 94     	bra	.ylp1
 1718                     
 1719  01:AF32            .ylppos:
 1720                     	incw	line_currx
       01:AF32  EE 7E 29  	inc	line_currx		; value at stated memory
       01:AF35  D0 03     	bne	.x_00382		; location
       01:AF37  EE 7F 29  	inc	line_currx+1
       01:AF3A            .x_00382:
 1721  01:AF3A  80 8A     	bra	.ylp1
 1722                     
 1723  01:AF3C            .ylp2:
 1724                     	addw	line_deltax,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AF3C  18        	clc
       01:AF3D  AD 86 29  	lda	LOW_BYTE line_error
       01:AF40  6D 82 29  	adc	LOW_BYTE line_deltax
       01:AF43  8D 86 29  	sta	LOW_BYTE line_error
       01:AF46  AD 87 29  	lda	HIGH_BYTE line_error
       01:AF49  6D 83 29  	adc	HIGH_BYTE line_deltax
       01:AF4C  8D 87 29  	sta	HIGH_BYTE line_error
                          .endif
 1725                     	addw	line_deltax,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AF4F  18        	clc
       01:AF50  AD 86 29  	lda	LOW_BYTE line_error
       01:AF53  6D 82 29  	adc	LOW_BYTE line_deltax
       01:AF56  8D 86 29  	sta	LOW_BYTE line_error
       01:AF59  AD 87 29  	lda	HIGH_BYTE line_error
       01:AF5C  6D 83 29  	adc	HIGH_BYTE line_deltax
       01:AF5F  8D 87 29  	sta	HIGH_BYTE line_error
                          .endif
 1726  01:AF62  4C C6 AE  	jmp	.ylp1
 1727                     
 1728  01:AF65            .out:
 1729  01:AF65  60        	rts
 1730                     
 1731                     
 1732                     ; gfx_plot(int x [__bx], int y [__cx], char color [reg acc])
 1733                     ; ----
 1734                     ; Plot a point at location (x,y) in color
 1735                     ; ----
 1736                     
 1737  01:AF66            lib2_gfx_plot.3:
 1738  01:AF66  86 FE     	stx	<__dl		; color
 1739  01:AF68  20 77 B0  	jsr	gfx_getaddr
 1740                     
 1741                     	; same as vm_rawread - save 21 cycles by inlining
 1742                     	;
 1743                     	vreg	#1		; video read register
       01:AF6B  A9 01     	lda	#1		
       01:AF6D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AF6F  03 01     	st0	#1		
                          .else
                          .endif
 1744                     	stw	<__cx,video_data	; VRAM address
       01:AF71  A5 FC     	lda	LOW_BYTE <__cx
       01:AF73  8D 02 00  	sta	LOW_BYTE video_data	
       01:AF76  A5 FD     	lda	HIGH_BYTE <__cx
       01:AF78  8D 03 00  	sta	HIGH_BYTE video_data	
 1745                     	vreg	#2		; set R/W memory mode
       01:AF7B  A9 02     	lda	#2		
       01:AF7D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AF7F  03 02     	st0	#2		
                          .else
                          .endif
 1746                     	__ldw	video_data
                0000      .if (1 = 2)
                          .else
       01:AF81  AE 02 00  	ldx	video_data
       01:AF84  AD 03 00  	lda	video_data+1
                          .endif
 1747                     	;
 1748                     	; end inline
 1749                     
 1750  01:AF87  A4 F8     	ldy	<__al		; bit offset
 1751  01:AF89  1F FE 05  	bbr1	<__dl,.l1
 1752  01:AF8C  19 67 B0  	ora	gfx_bittbl,Y	; set bit
 1753  01:AF8F  80 03     	bra	.l1a
 1754  01:AF91  39 6F B0  .l1:	and	gfx_bittbl2,Y	; else mask bit
 1755  01:AF94            .l1a:
 1756  01:AF94  22        	sax
 1757  01:AF95  0F FE 05  	bbr0	<__dl,.l2
 1758  01:AF98  19 67 B0  	ora	gfx_bittbl,Y	; set bit
 1759  01:AF9B  80 03     	bra	.l2a
 1760  01:AF9D  39 6F B0  .l2:	and	gfx_bittbl2,Y	; else mask bit
 1761  01:AFA0            .l2a:
 1762                     	; same as vm_rawwrite - save >14 cycles by inlining
 1763                     	;
 1764  01:AFA0  DA        	phx
 1765  01:AFA1  AA        	tax
 1766                     	vreg	#0		; video write register
       01:AFA2  A9 00     	lda	#0		
       01:AFA4  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AFA6  03 00     	st0	#0		
                          .else
                          .endif
 1767                     	stw	<__cx,video_data	; VRAM address
       01:AFA8  A5 FC     	lda	LOW_BYTE <__cx
       01:AFAA  8D 02 00  	sta	LOW_BYTE video_data	
       01:AFAD  A5 FD     	lda	HIGH_BYTE <__cx
       01:AFAF  8D 03 00  	sta	HIGH_BYTE video_data	
 1768                     	vreg	#2		; set R/W memory mode
       01:AFB2  A9 02     	lda	#2		
       01:AFB4  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AFB6  03 02     	st0	#2		
                          .else
                          .endif
 1769  01:AFB8  68        	pla
 1770                     	__stw	video_data	; write
       01:AFB9  8E 02 00  	stx	video_data	
       01:AFBC  8D 03 00  	sta	video_data	+1
 1771                     	;
 1772                     	; end inline
 1773                     
 1774                     	addw	#8,<__cx		; other half of pixel
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AFBF  18        	clc
       01:AFC0  A5 FC     	lda	LOW_BYTE <__cx		
       01:AFC2  69 08     	adc	LOW_BYTE #8
       01:AFC4  85 FC     	sta	LOW_BYTE <__cx		
       01:AFC6  A5 FD     	lda	HIGH_BYTE <__cx		
       01:AFC8  69 00     	adc	HIGH_BYTE #8
       01:AFCA  85 FD     	sta	HIGH_BYTE <__cx		
                          .endif
 1775                     
 1776                     	; same as vm_rawread - save 21 cycles by inlining
 1777                     	;
 1778                     	vreg	#1		; video read register
       01:AFCC  A9 01     	lda	#1		
       01:AFCE  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AFD0  03 01     	st0	#1		
                          .else
                          .endif
 1779                     	stw	<__cx,video_data	; VRAM address
       01:AFD2  A5 FC     	lda	LOW_BYTE <__cx
       01:AFD4  8D 02 00  	sta	LOW_BYTE video_data	
       01:AFD7  A5 FD     	lda	HIGH_BYTE <__cx
       01:AFD9  8D 03 00  	sta	HIGH_BYTE video_data	
 1780                     	vreg	#2		; set R/W memory mode
       01:AFDC  A9 02     	lda	#2		
       01:AFDE  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AFE0  03 02     	st0	#2		
                          .else
                          .endif
 1781                     	__ldw	video_data
                0000      .if (1 = 2)
                          .else
       01:AFE2  AE 02 00  	ldx	video_data
       01:AFE5  AD 03 00  	lda	video_data+1
                          .endif
 1782                     	;
 1783                     	; end inline
 1784                     
 1785  01:AFE8  A4 F8     	ldy	<__al		; bit offset
 1786  01:AFEA  3F FE 05  	bbr3	<__dl,.l3
 1787  01:AFED  19 67 B0  	ora	gfx_bittbl,Y	; set bit
 1788  01:AFF0  80 03     	bra	.l3a
 1789  01:AFF2  39 6F B0  .l3:	and	gfx_bittbl2,Y	; else mask bit
 1790  01:AFF5            .l3a:
 1791  01:AFF5  22        	sax
 1792  01:AFF6  2F FE 05  	bbr2	<__dl,.l4
 1793  01:AFF9  19 67 B0  	ora	gfx_bittbl,Y	; set bit
 1794  01:AFFC  80 03     	bra	.l4a
 1795  01:AFFE  39 6F B0  .l4:	and	gfx_bittbl2,Y	; mask bit
 1796  01:B001            .l4a:
 1797                     	; same as vm_rawwrite - save >14 cycles by inlining
 1798                     	;
 1799  01:B001  DA        	phx
 1800  01:B002  AA        	tax
 1801                     	vreg	#0		; video write register
       01:B003  A9 00     	lda	#0		
       01:B005  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:B007  03 00     	st0	#0		
                          .else
                          .endif
 1802                     	stw	<__cx,video_data	; VRAM address
       01:B009  A5 FC     	lda	LOW_BYTE <__cx
       01:B00B  8D 02 00  	sta	LOW_BYTE video_data	
       01:B00E  A5 FD     	lda	HIGH_BYTE <__cx
       01:B010  8D 03 00  	sta	HIGH_BYTE video_data	
 1803                     	vreg	#2		; set R/W memory mode
       01:B013  A9 02     	lda	#2		
       01:B015  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:B017  03 02     	st0	#2		
                          .else
                          .endif
 1804  01:B019  68        	pla
 1805                     	__stw	video_data	; write
       01:B01A  8E 02 00  	stx	video_data	
       01:B01D  8D 03 00  	sta	video_data	+1
 1806                     	;
 1807                     	; end inline
 1808                     
 1809  01:B020  60        	rts
 1810                     
 1811                     
 1812                     ; gfx_point(int x [__bx], int y [__cx])
 1813                     ; ----
 1814                     ; Returns color of point at location (x,y)
 1815                     ; ----
 1816                     
 1817  01:B021            lib2_gfx_point.2:
 1818  01:B021  20 77 B0  	jsr	gfx_getaddr
 1819  01:B024  64 F9     	stz	<__ah		; will be color
 1820                     	__ldw	<__cx		; VRAM address
                0000      .if (1 = 2)
                          .else
       01:B026  A6 FC     	ldx	<__cx		
       01:B028  A5 FD     	lda	<__cx		+1
                          .endif
 1821  01:B02A  20 84 F5  	jsr	readvram
 1822                     
 1823  01:B02D  A4 F8     	ldy	<__al		; bit offset
 1824  01:B02F  39 67 B0  	and	gfx_bittbl,Y
 1825  01:B032  F0 02     	beq	.l1
 1826  01:B034  97 F9     	smb1	<__ah
 1827  01:B036  8A        .l1:	txa
 1828  01:B037  39 67 B0  	and	gfx_bittbl,Y
 1829  01:B03A  F0 02     	beq	.l2
 1830  01:B03C  87 F9     	smb0	<__ah
 1831  01:B03E            .l2:
 1832                     	addw	#8,<__cx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B03E  18        	clc
       01:B03F  A5 FC     	lda	LOW_BYTE <__cx
       01:B041  69 08     	adc	LOW_BYTE #8
       01:B043  85 FC     	sta	LOW_BYTE <__cx
       01:B045  A5 FD     	lda	HIGH_BYTE <__cx
       01:B047  69 00     	adc	HIGH_BYTE #8
       01:B049  85 FD     	sta	HIGH_BYTE <__cx
                          .endif
 1833                     	__ldw	<__cx		; VRAM address part 2
                0000      .if (1 = 2)
                          .else
       01:B04B  A6 FC     	ldx	<__cx		
       01:B04D  A5 FD     	lda	<__cx		+1
                          .endif
 1834  01:B04F  20 84 F5  	jsr	readvram
 1835                     
 1836  01:B052  A4 F8     	ldy	<__al
 1837  01:B054  39 67 B0  	and	gfx_bittbl,Y
 1838  01:B057  F0 02     	beq	.l3
 1839  01:B059  B7 F9     	smb3	<__ah
 1840  01:B05B  8A        .l3:	txa
 1841  01:B05C  39 67 B0  	and	gfx_bittbl,Y
 1842  01:B05F  F0 02     	beq	.l4
 1843  01:B061  A7 F9     	smb2	<__ah
 1844  01:B063            .l4:
 1845  01:B063  A6 F9     	ldx	<__ah
 1846  01:B065  62        	cla
 1847  01:B066  60        	rts
 1848                     
 1849                     
 1850  01:B067            gfx_bittbl:
 1851  01:B067  80 40 20  	.db	$80,$40,$20,$10,$08,$04,$02,$01
       01:B06A  10 08 04  
       01:B06D  02 01     
 1852  01:B06F            gfx_bittbl2:
 1853  01:B06F  7F BF DF  	.db	$7f,$bf,$df,$ef,$f7,$fb,$fd,$fe
       01:B072  EF F7 FB  
       01:B075  FD FE     
 1854                     
 1855                     
 1856                     ; gfx_getaddr
 1857                     ; ----
 1858                     ; Utility routine to switch x/y pixel
 1859                     ; co-ordinates into VRAM addr and bit #
 1860                     ; ----
 1861                     
 1862  01:B077            gfx_getaddr:
 1863  01:B077  A5 FC     	lda	<__cl
 1864  01:B079  29 07     	and	#7
 1865  01:B07B  85 F8     	sta	<__al	; al = lines from tile base
 1866                     
 1867  01:B07D  A5 FA     	lda	<__bl
 1868  01:B07F  29 07     	and	#7
 1869  01:B081  48        	pha		; = bit offset
 1870                     
 1871                     	__ldw	<__bx
                0000      .if (1 = 2)
                          .else
       01:B082  A6 FA     	ldx	<__bx
       01:B084  A5 FB     	lda	<__bx+1
                          .endif
 1872                     	__lsrw		; should be only 2 bits in MSB are possible
       01:B086  4A        	lsr	A
       01:B087  22        	sax
       01:B088  6A        	ror	A
       01:B089  22        	sax
 1873                     	__lsrw		; but we'll shift 3 times anyway
       01:B08A  4A        	lsr	A
       01:B08B  22        	sax
       01:B08C  6A        	ror	A
       01:B08D  22        	sax
 1874                     	__lsrw
       01:B08E  4A        	lsr	A
       01:B08F  22        	sax
       01:B090  6A        	ror	A
       01:B091  22        	sax
 1875  01:B092  DA        	phx		; X = character column
 1876                     
 1877                     	__ldw	<__cx
                0000      .if (1 = 2)
                          .else
       01:B093  A6 FC     	ldx	<__cx
       01:B095  A5 FD     	lda	<__cx+1
                          .endif
 1878                     	__lsrw		; should be only 2 bits in MSB are possible
       01:B097  4A        	lsr	A
       01:B098  22        	sax
       01:B099  6A        	ror	A
       01:B09A  22        	sax
 1879                     	__lsrw		; but we'll shift 3 times anyway
       01:B09B  4A        	lsr	A
       01:B09C  22        	sax
       01:B09D  6A        	ror	A
       01:B09E  22        	sax
 1880                     	__lsrw
       01:B09F  4A        	lsr	A
       01:B0A0  22        	sax
       01:B0A1  6A        	ror	A
       01:B0A2  22        	sax
 1881  01:B0A3  8A        	txa		; A = character row
 1882                     
 1883  01:B0A4  FA        	plx
 1884  01:B0A5  20 19 E4  	jsr	calc_vram_addr
 1885                     
 1886                     	__ldw	<__di		; to get BAT addr
                0000      .if (1 = 2)
                          .else
       01:B0A8  A6 F0     	ldx	<__di		
       01:B0AA  A5 F1     	lda	<__di		+1
                          .endif
 1887  01:B0AC  20 84 F5  	jsr	readvram	; read BAT value
 1888                     	__aslw			; change into VRAM tile addr
       01:B0AF  22        	sax
       01:B0B0  0A        	asl	A
       01:B0B1  22        	sax
       01:B0B2  2A        	rol	A
 1889                     	__aslw
       01:B0B3  22        	sax
       01:B0B4  0A        	asl	A
       01:B0B5  22        	sax
       01:B0B6  2A        	rol	A
 1890                     	__aslw
       01:B0B7  22        	sax
       01:B0B8  0A        	asl	A
       01:B0B9  22        	sax
       01:B0BA  2A        	rol	A
 1891                     	__aslw			; cx = VRAM addr start of tile
       01:B0BB  22        	sax
       01:B0BC  0A        	asl	A
       01:B0BD  22        	sax
       01:B0BE  2A        	rol	A
 1892                     
 1893  01:B0BF  22        	sax
 1894  01:B0C0  18        	clc			; add row within tile
 1895  01:B0C1  65 F8     	adc	<__al
 1896  01:B0C3  22        	sax
 1897  01:B0C4  69 00     	adc	#0
 1898                     	__stw	<__cx
       01:B0C6  86 FC     	stx	<__cx
       01:B0C8  85 FD     	sta	<__cx+1
 1899                     
 1900  01:B0CA  68        	pla
 1901  01:B0CB  85 F8     	sta	<__al		; al = bit offset
 1902                     
 1903  01:B0CD  60        	rts
 1904                     
 1905                     ; Change back to original LIB1_BANK context
 1906                     
 1907           0000      	.bank	LIB1_BANK
 1908                     
 1909  00:F648            _set_map_tile_type:
 1910  00:F648  8E EA 26  	stx	maptiletype
 1911  00:F64B  60        	rts
 1912                     
 1913  00:F64C            _set_map_tile_base:
 1914                     	__lsrwi 4
                0000      .if (4 = 1)
                          .else
                0000      .if (4 = 2)
                          .else
                0000      .if (4 = 8)
                          .else
       00:F64C  A0 04     	ldy	#4
       00:F64E  20 AF EA  	jsr	lsrzp
                          .endif
                          .endif
                          .endif
 1915  00:F651  8E EE 26  	stx	maptilebase
 1916  00:F654  8D EF 26  	sta	maptilebase+1
 1917  00:F657  60        	rts
 1918                     
 1919  00:F658            _set_map_pals.1:
 1920                     	stb	<__bl, mapctablebank
       00:F658  A5 FA     	lda	<__bl
       00:F65A  8D F2 26  	sta	mapctablebank
 1921                     	stw	<__si, mapctable
       00:F65D  A5 EE     	lda	LOW_BYTE <__si
       00:F65F  8D F3 26  	sta	LOW_BYTE mapctable
       00:F662  A5 EF     	lda	HIGH_BYTE <__si
       00:F664  8D F4 26  	sta	HIGH_BYTE mapctable
 1922  00:F667  60        	rts
#[2]   startup.asm
 1271                     
 1272           0000      .ifdef _AC
 1274                     .endif
 1275                     
 1276           0000      .ifdef _SGX
 1278                     .endif
 1279                     
#[3]   huc_math.asm
 1280                     .include "huc_math.asm"
    1                     ;
    2                     ; HUC_MATH.ASM  -  HuC Math Library
    3                     ;
    4                     
    5                     ; abs(int val)
    6                     ; ---
    7                     
    8  00:F668            _abs:
    9  00:F668  A8        	tay
   10  00:F669  10 0B     	bpl	.l1
   11  00:F66B  22        	sax
   12  00:F66C  49 FF     	eor	#$FF
   13                     	add	#1
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:F66E  18        	clc
       00:F66F  69 01     	adc	#1
                          .endif
   14  00:F671  22        	sax
   15  00:F672  49 FF     	eor	#$FF
   16  00:F674  69 00     	adc	#0
   17  00:F676            .l1:
   18  00:F676  60        	rts
   19                     
   20                     ; mov32(void *dst [__di], void *src)
   21                     ; ----
   22                     
   23  00:F677            _mov32.2:
   24                     	__stw	<__si
       00:F677  86 EE     	stx	<__si
       00:F679  85 EF     	sta	<__si+1
   25  00:F67B            _mov32.sub:
   26  00:F67B  A0 03     	ldy	#3
   27  00:F67D  B1 EE     .l1:	lda	[__si],Y
   28  00:F67F  91 F0     	sta	[__di],Y
   29  00:F681  88        	dey
   30  00:F682  10 F9     	bpl	.l1
   31  00:F684  60        	rts
   32                     
   33                     ; add32(void *dst [__di], void *src) /* ax|bx */
   34                     ; ----
   35                     
   36  00:F685            _add32.2:
   37                     	__stw	<__si
       00:F685  86 EE     	stx	<__si
       00:F687  85 EF     	sta	<__si+1
   38  00:F689  18        	clc
   39  00:F68A  C2        	cly
   40  00:F68B  A2 04     	ldx	#4
   41  00:F68D  B1 F0     .l1:	lda	[__di],Y
   42  00:F68F  71 EE     	adc	[__si],Y
   43  00:F691  91 F0     	sta	[__di],Y
   44  00:F693  C8        	iny
   45  00:F694  CA        	dex
   46  00:F695  D0 F6     	bne	.l1
   47  00:F697  60        	rts
   48                     
   49                     ; sub32(void *dst [__di], void *src)
   50                     ; ----
   51                     
   52  00:F698            _sub32.2:
   53                     	__stw	<__si
       00:F698  86 EE     	stx	<__si
       00:F69A  85 EF     	sta	<__si+1
   54  00:F69C  38        	sec
   55  00:F69D  C2        	cly
   56  00:F69E  A2 04     	ldx	#4
   57  00:F6A0  B1 F0     .l1:	lda	[__di],Y
   58  00:F6A2  F1 EE     	sbc	[__si],Y
   59  00:F6A4  91 F0     	sta	[__di],Y
   60  00:F6A6  C8        	iny
   61  00:F6A7  CA        	dex
   62  00:F6A8  D0 F6     	bne	.l1
   63  00:F6AA  60        	rts
   64                     
   65                     ; mul32(void *dst [__bp], void *src)
   66                     ; ----
   67                     
   68  00:F6AB            _mul32.2:
   69                     	__stw	<__si
       00:F6AB  86 EE     	stx	<__si
       00:F6AD  85 EF     	sta	<__si+1
   70                     	stw	#__ax,<__di
       00:F6AF  A9 F8     	lda	LOW_BYTE #__ax
       00:F6B1  85 F0     	sta	LOW_BYTE <__di
       00:F6B3  A9 20     	lda	HIGH_BYTE #__ax
       00:F6B5  85 F1     	sta	HIGH_BYTE <__di
   71  00:F6B7  20 7B F6  	jsr	_mov32.sub
   72                     	stw	<__bp,<__si
       00:F6BA  A5 EC     	lda	LOW_BYTE <__bp
       00:F6BC  85 EE     	sta	LOW_BYTE <__si
       00:F6BE  A5 ED     	lda	HIGH_BYTE <__bp
       00:F6C0  85 EF     	sta	HIGH_BYTE <__si
   73                     	stw	#__cx,<__di
       00:F6C2  A9 FC     	lda	LOW_BYTE #__cx
       00:F6C4  85 F0     	sta	LOW_BYTE <__di
       00:F6C6  A9 20     	lda	HIGH_BYTE #__cx
       00:F6C8  85 F1     	sta	HIGH_BYTE <__di
   74  00:F6CA  20 7B F6  	jsr	_mov32.sub
   75  00:F6CD  20 75 E6  	jsr	mulu32
   76                     	stw	<__bp,<__di
       00:F6D0  A5 EC     	lda	LOW_BYTE <__bp
       00:F6D2  85 F0     	sta	LOW_BYTE <__di
       00:F6D4  A5 ED     	lda	HIGH_BYTE <__bp
       00:F6D6  85 F1     	sta	HIGH_BYTE <__di
   77                     	stw	#__cx,<__si
       00:F6D8  A9 FC     	lda	LOW_BYTE #__cx
       00:F6DA  85 EE     	sta	LOW_BYTE <__si
       00:F6DC  A9 20     	lda	HIGH_BYTE #__cx
       00:F6DE  85 EF     	sta	HIGH_BYTE <__si
   78  00:F6E0  4C 7B F6  	jmp	_mov32.sub
   79                     
   80                     ; div32(void *dst [__di], void *src)
   81                     ; ----
   82                     
   83  00:F6E3            _div32.2:
   84  00:F6E3  60        	rts
   85                     
   86                     ; com32(void *dst)
   87                     ; ----
   88                     
   89  00:F6E4            _com32.1:
   90                     	__stw	<__di
       00:F6E4  86 F0     	stx	<__di
       00:F6E6  85 F1     	sta	<__di+1
   91  00:F6E8  A0 03     	ldy	#3
   92  00:F6EA  B1 F0     .l1:	lda	[__di],Y
   93  00:F6EC  49 FF     	eor	#$FF
   94  00:F6EE  91 F0     	sta	[__di],Y
   95  00:F6F0  88        	dey
   96  00:F6F1  10 F7     	bpl	.l1
   97  00:F6F3  60        	rts
   98                     	
   99                     ; cmp32(void *dst [__di], void *src)
  100                     ; ----
  101                     
  102  00:F6F4            _cmp32.2:
  103                     	__stw	<__si
       00:F6F4  86 EE     	stx	<__si
       00:F6F6  85 EF     	sta	<__si+1
  104  00:F6F8  A0 03     	ldy	#3
  105  00:F6FA  B1 F0     .l1:	lda	[__di],Y
  106  00:F6FC  D1 EE     	cmp	[__si],Y
  107  00:F6FE  D0 06     	bne	.l2
  108  00:F700  88        	dey
  109  00:F701  10 F7     	bpl	.l1
  110                     	; --
  111  00:F703  82        	clx
  112  00:F704  62        	cla
  113  00:F705  60        	rts
  114                     	; --
  115                     .l2:	blo	.l3
       00:F706  90 04     	bcc	.l3
  116  00:F708  A2 01     	ldx	#$01
  117  00:F70A  62        	cla
  118  00:F70B  60        	rts
  119                     	; --
  120  00:F70C  A2 FF     .l3:	ldx	#$FF
  121  00:F70E  8A        	txa
  122  00:F70F  60        	rts
  123                     
  124                     
  125           0000      .ifdef BCD
  290                     .endif ; BCD
#[2]   startup.asm
#[3]   huc_bram.asm
 1281                     .include "huc_bram.asm"
    1                     ;
    2                     ; HUC_BRAM.ASM  -  HuC Backup RAM Library
    3                     ;
    4                     
    5           298C      	.bss
    6  --:298C            bm_mpr4:	.ds 1
    7  --:298D            bm_error:	.ds 1
    8           F710      	.code
    9                     
   10                     ; NOTE: the BRAM format is as follows:
   11                     ;
   12                     ; BRAM bank header (0x10 bytes):
   13                     ; ------------------------------
   14                     ; - Header tag (4 bytes) = 'HUBM'
   15                     ;
   16                     ; - Pointer to 1st byte after BRAM (2 byte int)
   17                     ;   Note: relative to 0x8000 segment, hex example: 00 88 ($8800)
   18                     ;
   19                     ; - Pointer to next available BRAM slot (2 byte int)
   20                     ;   Note: relative to 0x8000 segment, hex example: 22 80 ($8022)
   21                     ;
   22                     ; - Zeroes (8 bytes)
   23                     ;
   24                     ; BRAM Entry Header (0x10 bytes):
   25                     ; -------------------------------
   26                     ; - Size of entry (2 bytes), hex example: 12 00 ($0012)
   27                     ;   This size includes the 0x10 bytes used by this header information
   28                     ;
   29                     ; - Checksum (2 bytes)
   30                     ;   This number added to the data should total to 0
   31                     ;
   32                     ; - Name (12 bytes)
   33                     ;   This subdivides into:
   34                     ;   - Unique ID (2 bytes); I have only ever seen 00 00 in this entry
   35                     ;     However, it appears to be an integral part of the name
   36                     ;   - ASCII Name (10 bytes)
   37                     ;     This should be padded with spaces
   38                     ;
   39                     ; BRAM Entry:
   40                     ; -----------
   41                     ; - Miscellaneous data, size described by header parameters
   42                     ;
   43                     ; BRAM Entry Trailer (0x02 bytes):
   44                     ; --------------------------------
   45                     ; - Zeores (2 bytes)
   46                     ;   Technically, this trailer is "not used", but rather a terminator
   47                     ;   to the linked list.  The BRAM bank header points at it by the
   48                     ;   'next available slot' pointer
   49                     ;
   50                     
   51                     
   52                     ; bm_check()
   53                     ; ---
   54                     ; Determine whether BRAM exists on this system
   55                     ; without damaging contents on BRAM
   56                     ;
   57                     
   58  00:F710            _bm_check:
   59  00:F710  20 41 F9  	jsr	_bm_unlock
   60                     
   61                     	stw	#$8000,<__di	; test area at $8000
       00:F713  A9 00     	lda	LOW_BYTE #$8000
       00:F715  85 F0     	sta	LOW_BYTE <__di	
       00:F717  A9 80     	lda	HIGH_BYTE #$8000
       00:F719  85 F1     	sta	HIGH_BYTE <__di	
   62  00:F71B  20 31 F7  	jsr	_bm_testram
   63                     
   64                     	; -- result
   65  00:F71E  20 2F F9  	jsr	_bm_disable
   66  00:F721  E0 00     	cpx	#0
   67  00:F723  D0 08     	bne	.err
   68                     	; -- ok
   69  00:F725  9C 8D 29  	stz	bm_error
   70  00:F728  A2 01     	ldx	#1
   71  00:F72A  62        	cla
   72  00:F72B  18        	clc
   73  00:F72C  60        	rts
   74                     	; -- no bram
   75  00:F72D  82        .err:	clx
   76  00:F72E  62        	cla
   77  00:F72F  38        	sec
   78  00:F730  60        	rts
   79                     
   80                     
   81                     ; bm_testram
   82                     ; ---
   83                     ; internal function to test whether BRAM exists at a location
   84                     ; input  = di (pointer to memory area to test)
   85                     ; output = register x (# errors)
   86                     ;
   87                     
   88  00:F731            _bm_testram:
   89                     	; -- swap bits
   90  00:F731  A0 07     	ldy	#7
   91  00:F733  B1 F0     .l1:	lda	[__di],Y
   92  00:F735  49 FF     	eor	#$FF
   93  00:F737  99 F8 20  	sta	__ax,Y
   94  00:F73A  91 F0     	sta	[__di],Y
   95  00:F73C  88        	dey
   96  00:F73D  10 F4     	bpl	.l1
   97                     	; -- cmp
   98  00:F73F  82        	clx
   99  00:F740  A0 07     	ldy	#7
  100  00:F742  B9 F8 20  .l2:	lda	__ax,Y
  101  00:F745  D1 F0     	cmp	[__di],Y
  102  00:F747  F0 01     	beq	.l3
  103  00:F749  E8        	inx
  104  00:F74A  49 FF     .l3:	eor	#$FF
  105  00:F74C  91 F0     	sta	[__di],Y
  106  00:F74E  88        	dey
  107  00:F74F  10 F1     	bpl	.l2
  108                     
  109  00:F751  60        	rts
  110                     
  111                     
  112                     ; bm_format()
  113                     ; ---
  114                     ; If BRAM is already formatted (*_PROPERLY_*), return OK
  115                     ; Otherwise, set header info, and set limit of BRAM to
  116                     ; maximum amount of memory available on this hardware
  117                     ;
  118                     
  119  00:F752            _bm_format:
  120  00:F752  20 1D F9  	jsr	_bm_enable
  121  00:F755  90 30     	bcc	.ok
  122                     	; -- format
  123  00:F757  A2 07     	ldx	#7
  124  00:F759  BD A9 F8  .l1:	lda	_bm_id,X
  125  00:F75C  9D 00 80  	sta	$8000,X
  126  00:F75F  CA        	dex
  127  00:F760  10 F7     	bpl	.l1
  128  00:F762  9C 10 80  	stz	$8010
  129  00:F765  9C 11 80  	stz	$8011
  130                     
  131                     	stw	#$8000,<__di	; test area at $8000
       00:F768  A9 00     	lda	LOW_BYTE #$8000
       00:F76A  85 F0     	sta	LOW_BYTE <__di	
       00:F76C  A9 80     	lda	HIGH_BYTE #$8000
       00:F76E  85 F1     	sta	HIGH_BYTE <__di	
  132  00:F770  20 31 F7  .l2:	jsr	_bm_testram
  133  00:F773  E0 00     	cpx	#0
  134  00:F775  D0 0B     	bne	.setsz
  135  00:F777  A5 F1     	lda	<__di+1
  136  00:F779  C9 A0     	cmp	#$A0		; and keep going until either
  137  00:F77B  F0 05     	beq	.setsz		; (a) bad memory, or
  138  00:F77D  1A        	inc	A		; (b) next bank
  139  00:F77E  85 F1     	sta	<__di+1
  140  00:F780  80 EE     	bra	.l2
  141                     
  142  00:F782  A5 F1     .setsz:	lda	<__di+1
  143  00:F784  8D 05 80  	sta	$8005
  144                     
  145                     	; -- ok
  146  00:F787  20 2F F9  .ok:	jsr	_bm_disable
  147  00:F78A  9C 8D 29  	stz	bm_error
  148  00:F78D  82        	clx
  149  00:F78E  62        	cla
  150  00:F78F  18        	clc
  151  00:F790  60        	rts
  152                     
  153                     
  154                     ; bm_free()
  155                     ; ---
  156                     ; Returns (int) number of user bytes available in BRAM
  157                     ; BRAM header entry and trailer overhead is already deducted
  158                     ;
  159                     
  160  00:F791            _bm_free:
  161  00:F791  20 1D F9  	jsr	_bm_enable
  162  00:F794  B0 3A     	bcs	.err
  163                     	; -- calculate free space
  164                     	stw	$8004,<__cx
       00:F796  AD 04 80  	lda	LOW_BYTE $8004
       00:F799  85 FC     	sta	LOW_BYTE <__cx
       00:F79B  AD 05 80  	lda	HIGH_BYTE $8004
       00:F79E  85 FD     	sta	HIGH_BYTE <__cx
  165                     	subw	$8006,<__cx
       00:F7A0  38        	sec
       00:F7A1  A5 FC     	lda	LOW_BYTE <__cx
       00:F7A3  ED 06 80  	sbc	LOW_BYTE $8006
       00:F7A6  85 FC     	sta	LOW_BYTE <__cx
       00:F7A8  A5 FD     	lda	HIGH_BYTE <__cx
       00:F7AA  ED 07 80  	sbc	HIGH_BYTE $8006
       00:F7AD  85 FD     	sta	HIGH_BYTE <__cx
  166                     	subw	#$12,<__cx
       00:F7AF  38        	sec
       00:F7B0  A5 FC     	lda	LOW_BYTE <__cx
       00:F7B2  E9 12     	sbc	LOW_BYTE #$12
       00:F7B4  85 FC     	sta	LOW_BYTE <__cx
       00:F7B6  A5 FD     	lda	HIGH_BYTE <__cx
       00:F7B8  E9 00     	sbc	HIGH_BYTE #$12
       00:F7BA  85 FD     	sta	HIGH_BYTE <__cx
  167  00:F7BC  A5 FD     	lda	<__ch
  168  00:F7BE  10 04     	bpl	.ok
  169                     	stwz	<__cx
       00:F7C0  64 FC     	stz	LOW_BYTE <__cx
       00:F7C2  64 FD     	stz	HIGH_BYTE <__cx
  170                     	; -- ok
  171  00:F7C4  20 2F F9  .ok:	jsr	_bm_disable
  172  00:F7C7  9C 8D 29  	stz	bm_error
  173                     	__ldw	<__cx
                0000      .if (1 = 2)
                          .else
       00:F7CA  A6 FC     	ldx	<__cx
       00:F7CC  A5 FD     	lda	<__cx+1
                          .endif
  174  00:F7CE  18        	clc
  175  00:F7CF  60        	rts
  176                     	; -- error, bram not formatted
  177  00:F7D0  8D 8D 29  .err:	sta	bm_error
  178  00:F7D3  20 2F F9  	jsr	_bm_disable
  179  00:F7D6  A9 FF     	lda	#$FF
  180  00:F7D8  AA        	tax
  181  00:F7D9  38        	sec
  182  00:F7DA  60        	rts
  183                     
  184                     
  185                     ; bm_size()
  186                     ; ---
  187                     ; Returns (int) number of bytes in BRAM - should normally
  188                     ; be 2K, but can be as large as 8KB
  189                     
  190  00:F7DB            _bm_size:
  191  00:F7DB  20 1D F9  	jsr	_bm_enable
  192  00:F7DE  B0 33     	bcs	.err
  193                     	; -- calculate free space
  194                     	stw	$8004,<__cx
       00:F7E0  AD 04 80  	lda	LOW_BYTE $8004
       00:F7E3  85 FC     	sta	LOW_BYTE <__cx
       00:F7E5  AD 05 80  	lda	HIGH_BYTE $8004
       00:F7E8  85 FD     	sta	HIGH_BYTE <__cx
  195                     	subw	#$8000,<__cx
       00:F7EA  38        	sec
       00:F7EB  A5 FC     	lda	LOW_BYTE <__cx
       00:F7ED  E9 00     	sbc	LOW_BYTE #$8000
       00:F7EF  85 FC     	sta	LOW_BYTE <__cx
       00:F7F1  A5 FD     	lda	HIGH_BYTE <__cx
       00:F7F3  E9 80     	sbc	HIGH_BYTE #$8000
       00:F7F5  85 FD     	sta	HIGH_BYTE <__cx
  196  00:F7F7  A5 FD     	lda	<__ch
  197  00:F7F9  C9 21     	cmp	#$21
  198  00:F7FB  B0 14     	bcs	.err1
  199  00:F7FD  A5 FD     	lda	<__ch
  200  00:F7FF  10 04     	bpl	.ok
  201                     	stwz	<__cx
       00:F801  64 FC     	stz	LOW_BYTE <__cx
       00:F803  64 FD     	stz	HIGH_BYTE <__cx
  202                     	; -- ok
  203  00:F805  20 2F F9  .ok:	jsr	_bm_disable
  204  00:F808  9C 8D 29  	stz	bm_error
  205                     	__ldw	<__cx
                0000      .if (1 = 2)
                          .else
       00:F80B  A6 FC     	ldx	<__cx
       00:F80D  A5 FD     	lda	<__cx+1
                          .endif
  206  00:F80F  18        	clc
  207  00:F810  60        	rts
  208                     	; -- error, bram not formatted
  209  00:F811  A9 FF     .err1:	lda	#$ff
  210  00:F813  8D 8D 29  .err:	sta	bm_error
  211  00:F816  20 2F F9  	jsr	_bm_disable
  212  00:F819  A9 FF     	lda	#$FF
  213  00:F81B  AA        	tax
  214  00:F81C  38        	sec
  215  00:F81D  60        	rts
  216                     
  217                     
  218                     ; bm_rawread(int location)
  219                     ; ---
  220                     ; Similar to peek(), but for BRAM
  221                     ; Automatically handles mapping of memory ; and address range
  222                     ;
  223  00:F81E            _bm_rawread:
  224                     	__stw	<__bx
       00:F81E  86 FA     	stx	<__bx
       00:F820  85 FB     	sta	<__bx+1
  225  00:F822  A5 FB     	lda	<__bh
  226  00:F824  29 1F     	and	#$1F
  227  00:F826  09 80     	ora	#$80
  228  00:F828  85 FB     	sta	<__bh
  229  00:F82A  20 1D F9  	jsr	_bm_enable
  230  00:F82D  B0 0C     	bcs	.err
  231  00:F82F  B2 FA     	lda	[__bx]
  232  00:F831  22        	sax
  233  00:F832  9C 8D 29  	stz	bm_error
  234  00:F835  20 2F F9  	jsr	_bm_disable
  235  00:F838  62        	cla
  236  00:F839  18        	clc
  237  00:F83A  60        	rts
  238  00:F83B  8D 8D 29  .err:	sta	bm_error
  239  00:F83E  20 2F F9  	jsr	_bm_disable
  240  00:F841  38        	sec
  241  00:F842  60        	rts
  242                     
  243                     
  244                     ; bm_rawwrite(int location [__bx], char val [reg acc])
  245                     ; ---
  246                     ; Similar to peek(), but for BRAM
  247                     ; Automatically handles mapping of memory ; and address range
  248                     ;
  249  00:F843            _bm_rawwrite.2:
  250                     	__stw	<__ax
       00:F843  86 F8     	stx	<__ax
       00:F845  85 F9     	sta	<__ax+1
  251  00:F847  A5 FB     	lda	<__bh
  252  00:F849  29 1F     	and	#$1F
  253  00:F84B  09 80     	ora	#$80
  254  00:F84D  85 FB     	sta	<__bh
  255  00:F84F  20 1D F9  	jsr	_bm_enable
  256  00:F852  B0 0E     	bcs	.err
  257  00:F854  A5 F8     	lda	<__al
  258  00:F856  92 FA     	sta	[__bx]
  259  00:F858  9C 8D 29  	stz	bm_error
  260  00:F85B  20 2F F9  	jsr	_bm_disable
  261  00:F85E  62        	cla
  262  00:F85F  82        	clx
  263  00:F860  18        	clc
  264  00:F861  60        	rts
  265  00:F862  8D 8D 29  .err:	sta	bm_error
  266  00:F865  20 2F F9  	jsr	_bm_disable
  267  00:F868  38        	sec
  268  00:F869  60        	rts
  269                     
  270                     
  271                     ; bm_exist(char *name)
  272                     ; ---
  273                     ; Check for existence of BRAM file with a matching name
  274                     ; Note: name is 12 bytes; first 2 bytes are a uniqueness value
  275                     ;       (should be zeroes), and the next10 bytes are ASCII name
  276                     ;       with trailing spaces as padding
  277                     ;
  278                     
  279  00:F86A            _bm_exist:
  280                     	__stw	<__bx
       00:F86A  86 FA     	stx	<__bx
       00:F86C  85 FB     	sta	<__bx+1
  281  00:F86E  20 0B F9  	jsr	_bm_open
  282  00:F871  B0 0A     	bcs	.l1
  283  00:F873  20 2F F9  	jsr	_bm_disable
  284  00:F876  A2 01     	ldx	#1
  285  00:F878  AD 8D 29  	lda	bm_error
  286  00:F87B  F0 02     	beq	.noerr
  287  00:F87D  82        .l1:	clx
  288  00:F87E  62        	cla
  289  00:F87F  60        .noerr:	rts
  290                     
  291                     
  292                     ; bm_sizeof(char *name)
  293                     ; ---
  294                     ; Return the size of the user data in a RAM file with the given name
  295                     ; Note: name is 12 bytes; first 2 bytes are a uniqueness value
  296                     ;       (should be zeroes), and the next10 bytes are ASCII name
  297                     ;       with trailing spaces as padding
  298                     ;
  299                     
  300  00:F880            _bm_sizeof:
  301                     	__stw	<__bx
       00:F880  86 FA     	stx	<__bx
       00:F882  85 FB     	sta	<__bx+1
  302  00:F884  20 0B F9  	jsr	_bm_open
  303  00:F887  B0 18     	bcs	.l1
  304                     	subw	#$10,<__cx
       00:F889  38        	sec
       00:F88A  A5 FC     	lda	LOW_BYTE <__cx
       00:F88C  E9 10     	sbc	LOW_BYTE #$10
       00:F88E  85 FC     	sta	LOW_BYTE <__cx
       00:F890  A5 FD     	lda	HIGH_BYTE <__cx
       00:F892  E9 00     	sbc	HIGH_BYTE #$10
       00:F894  85 FD     	sta	HIGH_BYTE <__cx
  305  00:F896  20 2F F9  	jsr	_bm_disable
  306  00:F899  9C 8D 29  	stz	bm_error
  307  00:F89C  A6 FC     	ldx	<__cl
  308  00:F89E  A5 FD     	lda	<__ch
  309  00:F8A0  60        	rts
  310  00:F8A1  82        .l1:	clx
  311  00:F8A2  62        	cla
  312  00:F8A3  60        	rts
  313                     
  314                     
  315                     ; bm_errno()
  316                     ; ---
  317                     ; Return error type
  318                     ;
  319                     
  320  00:F8A4            _bm_errno:
  321  00:F8A4  AE 8D 29  	ldx	bm_error
  322  00:F8A7  62        	cla
  323  00:F8A8  60        	rts
  324                     
  325                     
  326  00:F8A9            _bm_id:
  327  00:F8A9  48 55 42  	.db	$48,$55,$42,$4D
       00:F8AC  4D        
  328  00:F8AD  00 88 10  	.db	$00,$88,$10,$80
       00:F8B0  80        
  329                     
  330                     
  331                     ; ------------------------
  332                     
  333                     ; bm_getptr(int ptr [__bp], char *namebuf [reg acc])
  334                     ; ---
  335                     ; Given a pointer with the BRAM, obtain the name of the entry
  336                     ; and the pointer to the next entry
  337                     ; Use BRAM_START for first entry
  338                     ;
  339                     
  340  00:F8B1            _bm_getptr.2:
  341                     	maplibfunc	lib2_bm_getptr.2
       00:F8B1  A8        	tay
       00:F8B2  43 20     	tma	#page(lib2_bm_getptr.2)
       00:F8B4  48        	pha
       00:F8B5  A9 01     	lda	#bank(lib2_bm_getptr.2)
       00:F8B7  53 20     	tam	#page(lib2_bm_getptr.2)
       00:F8B9  98        	tya
       00:F8BA  20 CE B0  	jsr	lib2_bm_getptr.2
       00:F8BD  A8        	tay
       00:F8BE  68        	pla
       00:F8BF  53 20     	tam	#page(lib2_bm_getptr.2)
       00:F8C1  98        	tya
  342  00:F8C2  60        	rts
  343                     
  344                     
  345                     ; bm_delete(char *namebuf)
  346                     ; ---
  347                     ; Delete the entry specified by the name provided
  348                     ;
  349                     
  350  00:F8C3            _bm_delete:
  351                     	maplibfunc	lib2_bm_delete
       00:F8C3  A8        	tay
       00:F8C4  43 20     	tma	#page(lib2_bm_delete)
       00:F8C6  48        	pha
       00:F8C7  A9 01     	lda	#bank(lib2_bm_delete)
       00:F8C9  53 20     	tam	#page(lib2_bm_delete)
       00:F8CB  98        	tya
       00:F8CC  20 24 B1  	jsr	lib2_bm_delete
       00:F8CF  A8        	tay
       00:F8D0  68        	pla
       00:F8D1  53 20     	tam	#page(lib2_bm_delete)
       00:F8D3  98        	tya
  352  00:F8D4  60        	rts
  353                     
  354                     
  355                     ; bm_read(char *buf [__di], char *name [__bx], int offset [__bp], int nb)
  356                     ; ---
  357                     ; Given a name of a file, grab some info from the file
  358                     ;
  359                     
  360  00:F8D5            _bm_read.4:
  361                     	maplibfunc	lib2_bm_read.4
       00:F8D5  A8        	tay
       00:F8D6  43 20     	tma	#page(lib2_bm_read.4)
       00:F8D8  48        	pha
       00:F8D9  A9 01     	lda	#bank(lib2_bm_read.4)
       00:F8DB  53 20     	tam	#page(lib2_bm_read.4)
       00:F8DD  98        	tya
       00:F8DE  20 83 B1  	jsr	lib2_bm_read.4
       00:F8E1  A8        	tay
       00:F8E2  68        	pla
       00:F8E3  53 20     	tam	#page(lib2_bm_read.4)
       00:F8E5  98        	tya
  362  00:F8E6  60        	rts
  363                     
  364                     
  365                     ; bm_write(char *buf [__di], char *name [__bx], int offset [__bp], int nb)
  366                     ; ---
  367                     ; Given the name of a BRAM file, update some info inside of it
  368                     ;
  369                     
  370  00:F8E7            _bm_write.4:
  371                     	maplibfunc	lib2_bm_write.4
       00:F8E7  A8        	tay
       00:F8E8  43 20     	tma	#page(lib2_bm_write.4)
       00:F8EA  48        	pha
       00:F8EB  A9 01     	lda	#bank(lib2_bm_write.4)
       00:F8ED  53 20     	tam	#page(lib2_bm_write.4)
       00:F8EF  98        	tya
       00:F8F0  20 D2 B1  	jsr	lib2_bm_write.4
       00:F8F3  A8        	tay
       00:F8F4  68        	pla
       00:F8F5  53 20     	tam	#page(lib2_bm_write.4)
       00:F8F7  98        	tya
  372  00:F8F8  60        	rts
  373                     
  374                     
  375                     ; bm_create(char *name [__bx], int size)
  376                     ; ---
  377                     ; Create a new BRAM file, given the name and size
  378                     
  379  00:F8F9            _bm_create.2:
  380                     	maplibfunc	lib2_bm_create.2
       00:F8F9  A8        	tay
       00:F8FA  43 20     	tma	#page(lib2_bm_create.2)
       00:F8FC  48        	pha
       00:F8FD  A9 01     	lda	#bank(lib2_bm_create.2)
       00:F8FF  53 20     	tam	#page(lib2_bm_create.2)
       00:F901  98        	tya
       00:F902  20 11 B2  	jsr	lib2_bm_create.2
       00:F905  A8        	tay
       00:F906  68        	pla
       00:F907  53 20     	tam	#page(lib2_bm_create.2)
       00:F909  98        	tya
  381  00:F90A  60        	rts
  382                     
  383                     
  384                     ; bm_open(char *name [__bx])
  385                     ; ---
  386                     ; Internal function to obtain access to a named file
  387                     
  388  00:F90B            _bm_open:
  389                     	maplibfunc	lib2_bm_open
       00:F90B  A8        	tay
       00:F90C  43 20     	tma	#page(lib2_bm_open)
       00:F90E  48        	pha
       00:F90F  A9 01     	lda	#bank(lib2_bm_open)
       00:F911  53 20     	tam	#page(lib2_bm_open)
       00:F913  98        	tya
       00:F914  20 D1 B2  	jsr	lib2_bm_open
       00:F917  A8        	tay
       00:F918  68        	pla
       00:F919  53 20     	tam	#page(lib2_bm_open)
       00:F91B  98        	tya
  390  00:F91C  60        	rts
  391                     
  392                     
  393                     ; bm_enable()
  394                     ; ---
  395                     ; Internal function to enable the BRAM area and do a quick check
  396                     
  397  00:F91D            _bm_enable:
  398                     	maplibfunc	lib2_bm_enable
       00:F91D  A8        	tay
       00:F91E  43 20     	tma	#page(lib2_bm_enable)
       00:F920  48        	pha
       00:F921  A9 01     	lda	#bank(lib2_bm_enable)
       00:F923  53 20     	tam	#page(lib2_bm_enable)
       00:F925  98        	tya
       00:F926  20 54 B3  	jsr	lib2_bm_enable
       00:F929  A8        	tay
       00:F92A  68        	pla
       00:F92B  53 20     	tam	#page(lib2_bm_enable)
       00:F92D  98        	tya
  399  00:F92E  60        	rts
  400                     
  401                     
  402                     ; bm_disable()
  403                     ; ---
  404                     ; This internal function handles the fixup of BRAM segment/locking
  405                     
  406  00:F92F            _bm_disable:
  407                     	maplibfunc	lib2_bm_disable
       00:F92F  A8        	tay
       00:F930  43 20     	tma	#page(lib2_bm_disable)
       00:F932  48        	pha
       00:F933  A9 01     	lda	#bank(lib2_bm_disable)
       00:F935  53 20     	tam	#page(lib2_bm_disable)
       00:F937  98        	tya
       00:F938  20 86 B3  	jsr	lib2_bm_disable
       00:F93B  A8        	tay
       00:F93C  68        	pla
       00:F93D  53 20     	tam	#page(lib2_bm_disable)
       00:F93F  98        	tya
  408  00:F940  60        	rts
  409                     
  410                     
  411                     ; bm_unlock()
  412                     ; ---
  413                     ; This internal function handles only the map/unlock of the BRAM area
  414                     
  415  00:F941            _bm_unlock:
  416                     	maplibfunc	lib2_bm_unlock
       00:F941  A8        	tay
       00:F942  43 20     	tma	#page(lib2_bm_unlock)
       00:F944  48        	pha
       00:F945  A9 01     	lda	#bank(lib2_bm_unlock)
       00:F947  53 20     	tam	#page(lib2_bm_unlock)
       00:F949  98        	tya
       00:F94A  20 6B B3  	jsr	lib2_bm_unlock
       00:F94D  A8        	tay
       00:F94E  68        	pla
       00:F94F  53 20     	tam	#page(lib2_bm_unlock)
       00:F951  98        	tya
  417  00:F952  60        	rts
  418                     
  419                     
  420                     ; ---------------
  421                     
  422                     ;
  423                     ; From here, we have the implementation of various
  424                     ; BRAM routines in LIB2_BANK rather than LIB1_BANK
  425                     ; for reasons of speed and size
  426                     ;
  427                     ; Their external linkages will have specified above
  428                     ; and be begin with an underscore.  The private
  429                     ; definitions will not have an underscore
  430                     ;
  431                     
  432           0001      	.bank	LIB2_BANK
  433                     
  434                     ; bm_getptr(int ptr [__bp], char *namebuf [reg acc])
  435                     ; ---
  436                     ; Given a pointer with the BRAM, obtain the name of the entry
  437                     ; and the pointer to the next entry
  438                     ; Use BRAM_START for first entry
  439                     ;
  440                     
  441  01:B0CE            lib2_bm_getptr.2:
  442                     	__stw	<__di		; namebuf is destination of a copy
       01:B0CE  86 F0     	stx	<__di		
       01:B0D0  85 F1     	sta	<__di		+1
  443  01:B0D2  20 54 B3  	jsr	lib2_bm_enable
  444  01:B0D5  B0 43     	bcs	.x2
  445                     
  446                     	tstw	<__bp		; error - 0 input
       01:B0D7  A5 EC     	lda	<__bp				; value at stated memory
       01:B0D9  05 ED     	ora	<__bp		+1		; location is zero
  447  01:B0DB  F0 3D     	beq	.x2
  448  01:B0DD  B2 EC     	lda	[__bp]
  449  01:B0DF  85 FC     	sta	<__cl
  450  01:B0E1  A0 01     	ldy	#1
  451  01:B0E3  B1 EC     	lda	[__bp],Y
  452  01:B0E5  85 FD     	sta	<__ch		; <__cx is length of entry
  453                     	tstw	<__cx
       01:B0E7  A5 FC     	lda	<__cx		; value at stated memory
       01:B0E9  05 FD     	ora	<__cx+1		; location is zero
  454  01:B0EB  F0 2C     	beq	.empty
  455                     
  456                     	addw	#4,<__bp,<__si	; <__si is now ptr to name of current entry
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B0ED  18        	clc
       01:B0EE  A5 EC     	lda	LOW_BYTE <__bp
       01:B0F0  69 04     	adc	LOW_BYTE #4
       01:B0F2  85 EE     	sta	LOW_BYTE <__si	
       01:B0F4  A5 ED     	lda	HIGH_BYTE <__bp
       01:B0F6  69 00     	adc	HIGH_BYTE #4
       01:B0F8  85 EF     	sta	HIGH_BYTE <__si	
                          .else
                          .endif
  457  01:B0FA  62        	cla
  458  01:B0FB  A2 0C     	ldx	#12
  459  01:B0FD  20 F0 E4  	jsr	_memcpy.3	; copy 12 bytes of name to namebuf
  460                     	addw	<__cx,<__bp,<__ax	; next pointer
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B100  18        	clc
       01:B101  A5 EC     	lda	LOW_BYTE <__bp
       01:B103  65 FC     	adc	LOW_BYTE <__cx
       01:B105  85 F8     	sta	LOW_BYTE <__ax	
       01:B107  A5 ED     	lda	HIGH_BYTE <__bp
       01:B109  65 FD     	adc	HIGH_BYTE <__cx
       01:B10B  85 F9     	sta	HIGH_BYTE <__ax	
                          .else
                          .endif
  461  01:B10D  20 86 B3  	jsr	lib2_bm_disable
  462  01:B110  9C 8D 29  	stz	bm_error
  463  01:B113  A5 F9     	lda	<__ah
  464  01:B115  A6 F8     	ldx	<__al
  465  01:B117  18        	clc
  466  01:B118  60        	rts
  467                     
  468  01:B119  62        .empty:	cla
  469                     
  470                     	; -- error, bram not formatted
  471  01:B11A  8D 8D 29  .x2:	sta	bm_error
  472  01:B11D  20 86 B3  	jsr	lib2_bm_disable
  473  01:B120  62        	cla
  474  01:B121  82        	clx
  475  01:B122  38        	sec
  476  01:B123  60        	rts
  477                     
  478                     
  479                     ; bm_delete(char *namebuf)
  480                     ; ---
  481                     ; Delete the entry specified by the name provided
  482                     ;
  483                     
  484  01:B124            lib2_bm_delete:
  485                     	__stw	<__ax
       01:B124  86 F8     	stx	<__ax
       01:B126  85 F9     	sta	<__ax+1
  486  01:B128  20 D1 B2  	jsr	lib2_bm_open
  487  01:B12B  B0 55     	bcs	.out
  488                     	stw	$8006,<__bx	; ptr to end
       01:B12D  AD 06 80  	lda	LOW_BYTE $8006
       01:B130  85 FA     	sta	LOW_BYTE <__bx	
       01:B132  AD 07 80  	lda	HIGH_BYTE $8006
       01:B135  85 FB     	sta	HIGH_BYTE <__bx	
  489                     	stw	<__si,<__di	; setup currptr as dest
       01:B137  A5 EE     	lda	LOW_BYTE <__si
       01:B139  85 F0     	sta	LOW_BYTE <__di	
       01:B13B  A5 EF     	lda	HIGH_BYTE <__si
       01:B13D  85 F1     	sta	HIGH_BYTE <__di	
  490                     	stw	<__dx,<__si	; setup nextptr as src
       01:B13F  A5 FE     	lda	LOW_BYTE <__dx
       01:B141  85 EE     	sta	LOW_BYTE <__si	
       01:B143  A5 FF     	lda	HIGH_BYTE <__dx
       01:B145  85 EF     	sta	HIGH_BYTE <__si	
  491                     	subw	<__dx,<__bx	; #bytes = end-next + 2
       01:B147  38        	sec
       01:B148  A5 FA     	lda	LOW_BYTE <__bx	
       01:B14A  E5 FE     	sbc	LOW_BYTE <__dx
       01:B14C  85 FA     	sta	LOW_BYTE <__bx	
       01:B14E  A5 FB     	lda	HIGH_BYTE <__bx	
       01:B150  E5 FF     	sbc	HIGH_BYTE <__dx
       01:B152  85 FB     	sta	HIGH_BYTE <__bx	
  492                     	addw	#2,<__bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B154  18        	clc
       01:B155  A5 FA     	lda	LOW_BYTE <__bx
       01:B157  69 02     	adc	LOW_BYTE #2
       01:B159  85 FA     	sta	LOW_BYTE <__bx
       01:B15B  A5 FB     	lda	HIGH_BYTE <__bx
       01:B15D  69 00     	adc	HIGH_BYTE #2
       01:B15F  85 FB     	sta	HIGH_BYTE <__bx
                          .endif
  493                     	subw	<__cx,$8006	; adjust ptr to end
       01:B161  38        	sec
       01:B162  AD 06 80  	lda	LOW_BYTE $8006	
       01:B165  E5 FC     	sbc	LOW_BYTE <__cx
       01:B167  8D 06 80  	sta	LOW_BYTE $8006	
       01:B16A  AD 07 80  	lda	HIGH_BYTE $8006	
       01:B16D  E5 FD     	sbc	HIGH_BYTE <__cx
       01:B16F  8D 07 80  	sta	HIGH_BYTE $8006	
  494  01:B172  A5 FB     	lda	<__bh
  495  01:B174  A6 FA     	ldx	<__bl
  496  01:B176  20 F0 E4  	jsr	_memcpy.3
  497  01:B179  20 86 B3  	jsr	lib2_bm_disable
  498  01:B17C  9C 8D 29  	stz	bm_error
  499  01:B17F  82        	clx
  500  01:B180  62        	cla
  501  01:B181  18        	clc
  502  01:B182  60        .out:	rts
  503                     
  504                     
  505                     ; bm_read(char *buf [__di], char *name [__bx], int offset [__bp], int nb)
  506                     ; ---
  507                     ; Given a name of a file, grab some info from the file
  508                     ;
  509                     
  510  01:B183            lib2_bm_read.4:
  511                     	__stw	<__ax
       01:B183  86 F8     	stx	<__ax
       01:B185  85 F9     	sta	<__ax+1
  512                     	; -- open file
  513  01:B187  20 D1 B2  	jsr	lib2_bm_open
  514  01:B18A  B0 45     	bcs	.x2
  515                     	; -- checksum test
  516  01:B18C  20 91 B3  	jsr	lib2_bm_checksum
  517  01:B18F  A0 02     	ldy	#2
  518  01:B191  B1 EE     	lda	[__si],Y
  519                     	add	<__dl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B193  18        	clc
       01:B194  65 FE     	adc	<__dl
                          .endif
  520  01:B196  85 FE     	sta	<__dl
  521  01:B198  C8        	iny
  522  01:B199  B1 EE     	lda	[__si],Y
  523  01:B19B  65 FF     	adc	<__dh
  524  01:B19D  05 FE     	ora	<__dl
  525  01:B19F  D0 25     	bne	.x1
  526                     	; -- setup ptr
  527  01:B1A1  20 C7 B3  	jsr	lib2_bm_setup_ptr
  528  01:B1A4  B0 14     	bcs	.ok
  529                     	; -- read
  530  01:B1A6  C2        	cly
  531  01:B1A7  B1 FE     .l1:	lda	[__dx],Y
  532  01:B1A9  91 F0     	sta	[__di],Y
  533  01:B1AB  C8        	iny
  534  01:B1AC  D0 04     	bne	.l2
  535  01:B1AE  E6 FF     	inc	<__dx+1
  536  01:B1B0  E6 F1     	inc	<__di+1
  537  01:B1B2  C6 FC     .l2:	dec	<__cl
  538  01:B1B4  D0 F1     	bne	.l1
  539  01:B1B6  C6 FD     	dec	<__ch
  540  01:B1B8  10 ED     	bpl	.l1
  541                     	; -- ok
  542  01:B1BA  20 86 B3  .ok:	jsr	lib2_bm_disable
  543  01:B1BD  9C 8D 29  	stz	bm_error
  544                     	__ldw	<__ax
                0000      .if (1 = 2)
                          .else
       01:B1C0  A6 F8     	ldx	<__ax
       01:B1C2  A5 F9     	lda	<__ax+1
                          .endif
  545  01:B1C4  18        	clc
  546  01:B1C5  60        	rts
  547                     	; -- error, bad file checksum
  548  01:B1C6  A9 02     .x1:	lda	#2
  549  01:B1C8  8D 8D 29  	sta	bm_error
  550  01:B1CB  20 86 B3  	jsr	lib2_bm_disable
  551  01:B1CE  82        	clx
  552  01:B1CF  62        	cla
  553  01:B1D0  38        	sec
  554  01:B1D1  60        .x2:	rts
  555                     
  556                     
  557                     ; bm_write(char *buf [__di], char *name [__bx], int offset [__bp], int nb)
  558                     ; ---
  559                     ; Given the name of a BRAM file, update some info inside of it
  560                     ;
  561                     
  562  01:B1D2            lib2_bm_write.4:
  563                     	__stw	<__ax
       01:B1D2  86 F8     	stx	<__ax
       01:B1D4  85 F9     	sta	<__ax+1
  564                     	; -- open file
  565  01:B1D6  20 D1 B2  	jsr	lib2_bm_open
  566  01:B1D9  B0 35     	bcs	.x1
  567                     	; -- setup ptr
  568  01:B1DB  20 C7 B3  	jsr	lib2_bm_setup_ptr
  569  01:B1DE  B0 25     	bcs	.ok
  570                     	; -- write data
  571  01:B1E0  C2        	cly
  572  01:B1E1  B1 F0     .l1:	lda	[__di],Y
  573  01:B1E3  91 FE     	sta	[__dx],Y
  574  01:B1E5  C8        	iny
  575  01:B1E6  D0 04     	bne	.l2
  576  01:B1E8  E6 FF     	inc	<__dx+1
  577  01:B1EA  E6 F1     	inc	<__di+1
  578  01:B1EC  C6 FC     .l2:	dec	<__cl
  579  01:B1EE  D0 F1     	bne	.l1
  580  01:B1F0  C6 FD     	dec	<__ch
  581  01:B1F2  10 ED     	bpl	.l1
  582                     	; -- update checksum
  583  01:B1F4  20 91 B3  	jsr	lib2_bm_checksum
  584  01:B1F7  A0 02     	ldy	#2
  585  01:B1F9  62        	cla
  586                     	sub	<__dl
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:B1FA  38        	sec
       01:B1FB  E5 FE     	sbc	<__dl
                          .endif
  587  01:B1FD  91 EE     	sta	[__si],Y
  588  01:B1FF  C8        	iny
  589  01:B200  62        	cla
  590  01:B201  E5 FF     	sbc	<__dh
  591  01:B203  91 EE     	sta	[__si],Y
  592                     	; -- ok
  593  01:B205  20 86 B3  .ok:	jsr	lib2_bm_disable
  594  01:B208  9C 8D 29  	stz	bm_error
  595                     	__ldw	<__ax
                0000      .if (1 = 2)
                          .else
       01:B20B  A6 F8     	ldx	<__ax
       01:B20D  A5 F9     	lda	<__ax+1
                          .endif
  596  01:B20F  18        	clc
  597  01:B210  60        .x1:	rts
  598                     
  599                     
  600                     ; bm_create(char *name [__bx], int size)
  601                     ; ---
  602                     ; Create a new BRAM file, given the name and size
  603                     
  604  01:B211            lib2_bm_create.2:
  605                     	__stw	<__ax
       01:B211  86 F8     	stx	<__ax
       01:B213  85 F9     	sta	<__ax+1
  606  01:B215  20 54 B3  	jsr	lib2_bm_enable
  607  01:B218  90 10     	bcc	.go
  608  01:B21A  80 02     	bra	.x2
  609                     	; -- error, not enough ram
  610  01:B21C  A9 05     .x1:	lda	#5
  611                     	; -- error, bram not formatted
  612  01:B21E  8D 8D 29  .x2:	sta	bm_error
  613  01:B221  20 86 B3  	jsr	lib2_bm_disable
  614  01:B224  AE 8D 29  	ldx	bm_error
  615  01:B227  62        	cla
  616  01:B228  38        	sec
  617  01:B229  60        	rts
  618                     	; -- check free space
  619                     .go:	addw	#$12,$8006,<__dx
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B22A  18        	clc
       01:B22B  AD 06 80  	lda	LOW_BYTE $8006
       01:B22E  69 12     	adc	LOW_BYTE #$12
       01:B230  85 FE     	sta	LOW_BYTE <__dx
       01:B232  AD 07 80  	lda	HIGH_BYTE $8006
       01:B235  69 00     	adc	HIGH_BYTE #$12
       01:B237  85 FF     	sta	HIGH_BYTE <__dx
                          .else
                          .endif
  620                     	addw	<__ax,<__dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B239  18        	clc
       01:B23A  A5 FE     	lda	LOW_BYTE <__dx
       01:B23C  65 F8     	adc	LOW_BYTE <__ax
       01:B23E  85 FE     	sta	LOW_BYTE <__dx
       01:B240  A5 FF     	lda	HIGH_BYTE <__dx
       01:B242  65 F9     	adc	HIGH_BYTE <__ax
       01:B244  85 FF     	sta	HIGH_BYTE <__dx
                          .endif
  621                     	cmpw	<__dx,$8004
       01:B246  AD 05 80  	lda	HIGH_BYTE $8004
       01:B249  C5 FF     	cmp	HIGH_BYTE <__dx
       01:B24B  D0 05     	bne	.x_00481
       01:B24D  AD 04 80  	lda	LOW_BYTE $8004
       01:B250  C5 FE     	cmp	LOW_BYTE <__dx
       01:B252            .x_00481:
  622                     	blo	.x1
       01:B252  90 C8     	bcc	.x1
  623                     	; -- create file
  624                     	stw	$8006,<__si
       01:B254  AD 06 80  	lda	LOW_BYTE $8006
       01:B257  85 EE     	sta	LOW_BYTE <__si
       01:B259  AD 07 80  	lda	HIGH_BYTE $8006
       01:B25C  85 EF     	sta	HIGH_BYTE <__si
  625  01:B25E  A0 01     	ldy	#1
  626  01:B260  A5 F8     	lda	<__al
  627                     	add	#$10
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B262  18        	clc
       01:B263  69 10     	adc	#$10
                          .endif
  628  01:B265  92 EE     	sta	[__si]
  629  01:B267  A5 F9     	lda	<__ah
  630  01:B269  69 00     	adc	#$00
  631  01:B26B  91 EE     	sta	[__si],Y
  632                     	; --
  633  01:B26D  AD 06 80  	lda	$8006
  634                     	add	[__si]
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B270  18        	clc
       01:B271  72 EE     	adc	[__si]
                          .endif
  635  01:B273  85 FE     	sta	<__dl
  636  01:B275  8D 06 80  	sta	$8006
  637  01:B278  AD 07 80  	lda	$8007
  638  01:B27B  71 EE     	adc	[__si],Y
  639  01:B27D  85 FF     	sta	<__dh
  640  01:B27F  8D 07 80  	sta	$8007
  641  01:B282  62        	cla
  642  01:B283  92 FE     	sta	[__dx]
  643  01:B285  91 FE     	sta	[__dx],Y
  644                     	; -- copy name
  645  01:B287  82        	clx
  646  01:B288  A0 04     	ldy	#4
  647  01:B28A  02        .l1:	sxy
  648  01:B28B  B1 FA     	lda	[__bx],Y
  649  01:B28D  02        	sxy
  650  01:B28E  91 EE     	sta	[__si],Y
  651  01:B290  C8        	iny
  652  01:B291  E8        	inx
  653  01:B292  E0 0C     	cpx	#12
  654  01:B294  D0 F4     	bne	.l1
  655                     	; -- clear file
  656  01:B296  A5 F8     	lda	<__al
  657  01:B298  05 F9     	ora	<__ah
  658  01:B29A  F0 1A     	beq	.sum
  659                     	stw	<__si,<__bx
       01:B29C  A5 EE     	lda	LOW_BYTE <__si
       01:B29E  85 FA     	sta	LOW_BYTE <__bx
       01:B2A0  A5 EF     	lda	HIGH_BYTE <__si
       01:B2A2  85 FB     	sta	HIGH_BYTE <__bx
  660  01:B2A4  A0 10     	ldy	#16
  661  01:B2A6  62        	cla
  662  01:B2A7  91 FA     .l2:	sta	[__bx],Y
  663  01:B2A9  C8        	iny
  664  01:B2AA  D0 02     	bne	.l3
  665  01:B2AC  E6 FB     	inc	<__bh
  666  01:B2AE  C6 F8     .l3:	dec	<__al
  667  01:B2B0  D0 F5     	bne	.l2
  668  01:B2B2  C6 F9     	dec	<__ah
  669  01:B2B4  10 F1     	bpl	.l2
  670                     	; -- update checksum
  671  01:B2B6  20 91 B3  .sum:	jsr	lib2_bm_checksum
  672  01:B2B9  A0 02     	ldy	#2
  673  01:B2BB  62        	cla
  674                     	sub	<__dl
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:B2BC  38        	sec
       01:B2BD  E5 FE     	sbc	<__dl
                          .endif
  675  01:B2BF  91 EE     	sta	[__si],Y
  676  01:B2C1  C8        	iny
  677  01:B2C2  62        	cla
  678  01:B2C3  E5 FF     	sbc	<__dh
  679  01:B2C5  91 EE     	sta	[__si],Y
  680                     	; -- ok
  681  01:B2C7  20 86 B3  .ok:	jsr	lib2_bm_disable
  682  01:B2CA  9C 8D 29  	stz	bm_error
  683  01:B2CD  82        	clx
  684  01:B2CE  62        	cla
  685  01:B2CF  18        	clc
  686  01:B2D0  60        	rts
  687                     
  688                     
  689                     ; bm_open(char *name [__bx])
  690                     ; ---
  691                     ; Internal function to obtain access to a named file
  692                     
  693  01:B2D1            lib2_bm_open:
  694  01:B2D1  20 54 B3  	jsr	lib2_bm_enable
  695  01:B2D4  B0 6E     	bcs	.x2
  696                     	; -- get dir entry
  697                     	stw	#$8010,<__si
       01:B2D6  A9 10     	lda	LOW_BYTE #$8010
       01:B2D8  85 EE     	sta	LOW_BYTE <__si
       01:B2DA  A9 80     	lda	HIGH_BYTE #$8010
       01:B2DC  85 EF     	sta	HIGH_BYTE <__si
  698  01:B2DE  B2 EE     .l1:	lda	[__si]
  699  01:B2E0  85 FC     	sta	<__cl
  700  01:B2E2  A0 01     	ldy	#1
  701  01:B2E4  B1 EE     	lda	[__si],Y
  702  01:B2E6  85 FD     	sta	<__ch
  703  01:B2E8  05 FC     	ora	<__cl
  704  01:B2EA  F0 56     	beq	.x1
  705                     	addw	<__cx,<__si,<__dx
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B2EC  18        	clc
       01:B2ED  A5 EE     	lda	LOW_BYTE <__si
       01:B2EF  65 FC     	adc	LOW_BYTE <__cx
       01:B2F1  85 FE     	sta	LOW_BYTE <__dx
       01:B2F3  A5 EF     	lda	HIGH_BYTE <__si
       01:B2F5  65 FD     	adc	HIGH_BYTE <__cx
       01:B2F7  85 FF     	sta	HIGH_BYTE <__dx
                          .else
                          .endif
  706                     	cmpw	<__dx,$8004
       01:B2F9  AD 05 80  	lda	HIGH_BYTE $8004
       01:B2FC  C5 FF     	cmp	HIGH_BYTE <__dx
       01:B2FE  D0 05     	bne	.x_00490
       01:B300  AD 04 80  	lda	LOW_BYTE $8004
       01:B303  C5 FE     	cmp	LOW_BYTE <__dx
       01:B305            .x_00490:
  707                     	blo	.x3
       01:B305  90 45     	bcc	.x3
  708                     	cmpw	#16,<__cx
       01:B307  A5 FD     	lda	HIGH_BYTE <__cx
       01:B309  C9 00     	cmp	HIGH_BYTE #16
       01:B30B  D0 04     	bne	.x_00492
       01:B30D  A5 FC     	lda	LOW_BYTE <__cx
       01:B30F  C9 10     	cmp	LOW_BYTE #16
       01:B311            .x_00492:
  709                     	blo	.x3
       01:B311  90 39     	bcc	.x3
  710                     	; -- compare names
  711  01:B313  C2        	cly
  712  01:B314  A2 04     	ldx	#4
  713  01:B316  B1 FA     .l2:	lda	[__bx],Y
  714  01:B318  02        	sxy
  715  01:B319  D1 EE     	cmp	[__si],Y
  716  01:B31B  D0 16     	bne	.next
  717  01:B31D  02        	sxy
  718  01:B31E  E8        	inx
  719  01:B31F  C8        	iny
  720  01:B320  C0 0C     	cpy	#12
  721                     	blo	.l2
       01:B322  90 F2     	bcc	.l2
  722                     	; -- check file size
  723  01:B324  A5 FD     	lda	<__ch
  724  01:B326  D0 06     	bne	.ok
  725  01:B328  A5 FC     	lda	<__cl
  726  01:B32A  C9 10     	cmp	#16
  727  01:B32C  F0 22     	beq	.x4
  728                     	; -- ok
  729  01:B32E  9C 8D 29  .ok:	stz	bm_error
  730  01:B331  18        	clc
  731  01:B332  60        	rts
  732                     	; -- next entry
  733                     .next:	addw	<__cx,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B333  18        	clc
       01:B334  A5 EE     	lda	LOW_BYTE <__si
       01:B336  65 FC     	adc	LOW_BYTE <__cx
       01:B338  85 EE     	sta	LOW_BYTE <__si
       01:B33A  A5 EF     	lda	HIGH_BYTE <__si
       01:B33C  65 FD     	adc	HIGH_BYTE <__cx
       01:B33E  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  734  01:B340  80 9C     	bra	.l1
  735                     	; -- error, file not found
  736  01:B342  A9 01     .x1:	lda	#1
  737                     	; -- error, bram not formatted
  738  01:B344  8D 8D 29  .x2:	sta	bm_error
  739  01:B347  20 86 B3  	jsr	lib2_bm_disable
  740  01:B34A  38        	sec
  741  01:B34B  60        	rts
  742                     	; -- error, directory corrupted
  743  01:B34C  A9 03     .x3:	lda	#3
  744  01:B34E  80 F4     	bra	.x2
  745                     	; -- error, empty file
  746  01:B350  A9 04     .x4:	lda	#4
  747  01:B352  80 F0     	bra	.x2
  748                     
  749                     
  750                     ; bm_enable()
  751                     ; ---
  752                     ; Internal function to enable the BRAM area and do a quick check
  753                     
  754  01:B354            lib2_bm_enable:
  755  01:B354  20 6B B3  	jsr	lib2_bm_unlock
  756                     	; -- check if formatted
  757  01:B357  A2 03     	ldx	#3
  758  01:B359  BD 00 80  .l1:	lda	$8000,X
  759  01:B35C  DD A9 F8  	cmp	_bm_id,X
  760  01:B35F  D0 06     	bne	.x1
  761  01:B361  CA        	dex
  762  01:B362  10 F5     	bpl	.l1
  763                     	; -- ok
  764  01:B364  62        	cla
  765  01:B365  18        	clc
  766  01:B366  60        	rts
  767                     	; -- error, not formatted!
  768  01:B367  A9 FF     .x1:	lda	#$FF
  769  01:B369  38        	sec
  770  01:B36A  60        	rts
  771                     
  772                     
  773                     ; bm_unlock()
  774                     ; ---
  775                     ; This internal function handles only the map/unlock of the BRAM area
  776                     
  777  01:B36B            lib2_bm_unlock:
  778  01:B36B  78        	sei
  779  01:B36C  43 10     	tma	#4
  780  01:B36E  8D 8C 29  	sta	bm_mpr4
  781  01:B371  A9 F7     	lda	#$F7
  782  01:B373  53 10     	tam	#4
  783  01:B375  54        	csl
  784  01:B376  A9 48     	lda	#$48
  785  01:B378  8D 07 18  	sta	bram_unlock
  786  01:B37B  A9 75     	lda	#$75
  787  01:B37D  8D 07 18  	sta	bram_unlock
  788  01:B380  A9 80     	lda	#$80
  789  01:B382  8D 07 18  	sta	bram_unlock
  790  01:B385  60        	rts
  791                     
  792                     
  793                     ; bm_disable()
  794                     ; ---
  795                     ; This internal function handles the fixup of BRAM segment/locking
  796                     
  797  01:B386            lib2_bm_disable:
  798  01:B386  AD 8C 29  	lda	bm_mpr4
  799  01:B389  53 10     	tam	#4
  800  01:B38B  AD 03 18  	lda	bram_lock
  801  01:B38E  D4        	csh
  802  01:B38F  58        	cli
  803  01:B390  60        	rts
  804                     
  805                     
  806                     ; bm_checksum(char *fcb [__si])
  807                     ; ---
  808                     ; Internal function to generate checksum
  809                     ;
  810                     
  811  01:B391            lib2_bm_checksum:
  812                     	stwz	<__dx
       01:B391  64 FE     	stz	LOW_BYTE <__dx
       01:B393  64 FF     	stz	HIGH_BYTE <__dx
  813                     	; -- get file size
  814  01:B395  B2 EE     	lda	[__si]
  815                     	sub	#4
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:B397  38        	sec
       01:B398  E9 04     	sbc	#4
                          .endif
  816  01:B39A  85 FC     	sta	<__cl
  817  01:B39C  A0 01     	ldy	#1
  818  01:B39E  B1 EE     	lda	[__si],Y
  819  01:B3A0  E9 00     	sbc	#0
  820  01:B3A2  85 FD     	sta	<__ch
  821                     	stw	<__si,<__bx
       01:B3A4  A5 EE     	lda	LOW_BYTE <__si
       01:B3A6  85 FA     	sta	LOW_BYTE <__bx
       01:B3A8  A5 EF     	lda	HIGH_BYTE <__si
       01:B3AA  85 FB     	sta	HIGH_BYTE <__bx
  822                     	; -- calc checksum
  823  01:B3AC  A0 04     	ldy	#4
  824  01:B3AE  B1 FA     .l1:	lda	[__bx],Y
  825                     	add	<__dl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B3B0  18        	clc
       01:B3B1  65 FE     	adc	<__dl
                          .endif
  826  01:B3B3  85 FE     	sta	<__dl
  827  01:B3B5  90 02     	bcc	.l2
  828  01:B3B7  E6 FF     	inc	<__dh
  829  01:B3B9  C8        .l2:	iny
  830  01:B3BA  D0 02     	bne	.l3
  831  01:B3BC  E6 FB     	inc	<__bh
  832  01:B3BE  C6 FC     .l3:	dec	<__cl
  833  01:B3C0  D0 EC     	bne	.l1
  834  01:B3C2  C6 FD     	dec	<__ch
  835  01:B3C4  10 E8     	bpl	.l1
  836  01:B3C6  60        	rts
  837                     
  838                     
  839                     ; bm_setup_ptr(char *fcb [__si], char *buf [__di], int offset [__bp], int nb [__ax])
  840                     ; ---
  841                     
  842  01:B3C7            lib2_bm_setup_ptr:
  843                     	; -- check length
  844                     	tstw	<__ax
       01:B3C7  A5 F8     	lda	<__ax		; value at stated memory
       01:B3C9  05 F9     	ora	<__ax+1		; location is zero
  845  01:B3CB  F0 21     	beq	.x1
  846                     	; -- check ptr
  847                     	tstw	<__di
       01:B3CD  A5 F0     	lda	<__di		; value at stated memory
       01:B3CF  05 F1     	ora	<__di+1		; location is zero
  848  01:B3D1  F0 1B     	beq	.x1
  849                     	; -- check offset
  850                     	addw	#16,<__bp,<__bx
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B3D3  18        	clc
       01:B3D4  A5 EC     	lda	LOW_BYTE <__bp
       01:B3D6  69 10     	adc	LOW_BYTE #16
       01:B3D8  85 FA     	sta	LOW_BYTE <__bx
       01:B3DA  A5 ED     	lda	HIGH_BYTE <__bp
       01:B3DC  69 00     	adc	HIGH_BYTE #16
       01:B3DE  85 FB     	sta	HIGH_BYTE <__bx
                          .else
                          .endif
  851  01:B3E0  A0 01     	ldy	#1
  852  01:B3E2  A5 FB     	lda	<__bh
  853  01:B3E4  D1 EE     	cmp	[__si],Y
  854  01:B3E6  D0 04     	bne	.l1
  855  01:B3E8  A5 FA     	lda	<__bl
  856  01:B3EA  D2 EE     	cmp	[__si]
  857                     .l1:	blo	.l2
       01:B3EC  90 06     	bcc	.l2
  858                     	; -- eof
  859                     .x1:	stwz	<__ax
       01:B3EE  64 F8     	stz	LOW_BYTE <__ax
       01:B3F0  64 F9     	stz	HIGH_BYTE <__ax
  860  01:B3F2  38        	sec
  861  01:B3F3  60        	rts
  862                     	; -- set base ptr
  863                     .l2:	addw	<__bx,<__si,<__dx
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B3F4  18        	clc
       01:B3F5  A5 EE     	lda	LOW_BYTE <__si
       01:B3F7  65 FA     	adc	LOW_BYTE <__bx
       01:B3F9  85 FE     	sta	LOW_BYTE <__dx
       01:B3FB  A5 EF     	lda	HIGH_BYTE <__si
       01:B3FD  65 FB     	adc	HIGH_BYTE <__bx
       01:B3FF  85 FF     	sta	HIGH_BYTE <__dx
                          .else
                          .endif
  864                     	; -- check length
  865                     	addw	<__ax,<__bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B401  18        	clc
       01:B402  A5 FA     	lda	LOW_BYTE <__bx
       01:B404  65 F8     	adc	LOW_BYTE <__ax
       01:B406  85 FA     	sta	LOW_BYTE <__bx
       01:B408  A5 FB     	lda	HIGH_BYTE <__bx
       01:B40A  65 F9     	adc	HIGH_BYTE <__ax
       01:B40C  85 FB     	sta	HIGH_BYTE <__bx
                          .endif
  866  01:B40E  B2 EE     	lda	[__si]
  867                     	sub	<__bl
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:B410  38        	sec
       01:B411  E5 FA     	sbc	<__bl
                          .endif
  868  01:B413  85 FA     	sta	<__bl
  869  01:B415  B1 EE     	lda	[__si],Y
  870  01:B417  E5 FB     	sbc	<__bh
  871  01:B419  85 FB     	sta	<__bh
  872  01:B41B  10 0D     	bpl	.ok
  873                     	; -- adjust size
  874                     	addw	<__bx,<__ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B41D  18        	clc
       01:B41E  A5 F8     	lda	LOW_BYTE <__ax
       01:B420  65 FA     	adc	LOW_BYTE <__bx
       01:B422  85 F8     	sta	LOW_BYTE <__ax
       01:B424  A5 F9     	lda	HIGH_BYTE <__ax
       01:B426  65 FB     	adc	HIGH_BYTE <__bx
       01:B428  85 F9     	sta	HIGH_BYTE <__ax
                          .endif
  875                     .ok:	stw	<__ax,<__cx
       01:B42A  A5 F8     	lda	LOW_BYTE <__ax
       01:B42C  85 FC     	sta	LOW_BYTE <__cx
       01:B42E  A5 F9     	lda	HIGH_BYTE <__ax
       01:B430  85 FD     	sta	HIGH_BYTE <__cx
  876  01:B432  18        	clc
  877  01:B433  60        	rts
  878                     
  879                     ;
  880                     ; restore the context of the library routines
  881                     ; in LIB1_BANK
  882                     ;
  883           0000      	.bank	LIB1_BANK
#[2]   startup.asm
#[3]   huc_misc.asm
 1282                     .include "huc_misc.asm"
    1                     ;
    2                     ; HUC_MISC.ASM  -  HuC Misc Library
    3                     ;
    4                     
    5                     
    6                     ; joy(char number)
    7                     ; ----
    8                     
    9  00:F953            _joy:
   10  00:F953  02        	sxy
   11  00:F954  BE 28 22  	ldx	joy,Y
   12  00:F957  B9 93 26  	lda	joy6,Y
   13  00:F95A  60        	rts
   14                     
   15                     ; joytrg(char number)
   16                     ; ----
   17                     
   18  00:F95B            _joytrg:
   19  00:F95B  02        	sxy
   20  00:F95C  BE 2D 22  	ldx	joytrg,Y
   21  00:F95F  B9 98 26  	lda	joytrg6,Y
   22  00:F962  60        	rts
   23                     
   24                     ; joyold(char number)
   25                     ; ----
   26                     
   27  00:F963            _joyold:
   28  00:F963  02        	sxy
   29  00:F964  BE 32 22  	ldx	joyold,Y
   30  00:F967  B9 9D 26  	lda	joyold6,Y
   31  00:F96A  60        	rts
   32                     
   33                     ; joybuf(char number)
   34                     ; ----
   35                     
   36  00:F96B            _joybuf:
   37  00:F96B  02        	sxy
   38  00:F96C  BE 81 26  	ldx	joybuf,Y
   39  00:F96F  B9 A2 26  	lda	joybuf6,Y
   40  00:F972  60        	rts
   41                     
   42                     
   43                     ; mouse functions
   44                     ; available if SUPPORT_MOUSE is defined (default)
   45                     ; ----
   46                     
   47           0001      .ifdef SUPPORT_MOUSE
   48                     
   49                     ; mouse_exists() - returns true/false (true = 1)
   50                     ; ----
   51                     
   52  00:F973            _mouse_exists:
   53  00:F973  AE 8E 29  	ldx	msflag
   54  00:F976  62        	cla
   55  00:F977  60        	rts
   56                     
   57                     ; mouse_disable() - turns off mouse support
   58                     ; ----
   59                     
   60  00:F978            _mouse_disable:
   61                     	; XXX: This doesn't really need a return value, does it?
   62  00:F978  62        	cla
   63  00:F979  82        	clx
   64  00:F97A  8D 8E 29  	sta	msflag
   65  00:F97D  60        	rts
   66                     
   67                     ; mouse_enable() - turns on mouse support, if mouse detected
   68                     ;	- return true/false (true=1) if mouse exists
   69                     ; ----
   70                     
   71  00:F97E            _mouse_enable:
   72  00:F97E  20 9D FA  	jsr	mousinit
   73  00:F981  22        	sax
   74  00:F982  62        	cla
   75  00:F983  60        	rts
   76                     
   77                     ; mouse_x() - returns x/y delta (int)
   78                     ; ----
   79                     
   80  00:F984            _mouse_x:
   81  00:F984  AE 90 29  	ldx	mshorz
   82  00:F987  10 08     	bpl	mouspos
   83  00:F989            mousneg:
   84  00:F989  A9 FF     	lda	#$ff
   85  00:F98B  60        	rts
   86                     
   87                     ; mouse_y() - returns y delta (int)
   88                     ; ----
   89                     
   90  00:F98C            _mouse_y:
   91  00:F98C  AE 8F 29  	ldx	msvert
   92  00:F98F  30 F8     	bmi	mousneg
   93  00:F991            mouspos:
   94  00:F991  62        	cla
   95  00:F992  60        	rts
   96                     
   97                     .endif ; SUPPORT_MOUSE
   98                     
   99                     
  100                     ; set_joy_callback(char num [__dl], char mask [__al], char keys [__ah], int proc [__bl:__si])
  101                     ; ----
  102                     
  103  00:F993            _set_joy_callback.4:
  104  00:F993  9C 88 26  	stz	joycallback
  105  00:F996  A5 FA     	lda	<__bl
  106  00:F998  8D 8B 26  	sta	joycallback+3
  107                     	__ldw	<__si
                0000      .if (1 = 2)
                          .else
       00:F99B  A6 EE     	ldx	<__si
       00:F99D  A5 EF     	lda	<__si+1
                          .endif
  108                     	__stw	joycallback+4
       00:F99F  8E 8C 26  	stx	joycallback+4
       00:F9A2  8D 8D 26  	sta	joycallback+4+1
  109  00:F9A5  05 EE     	ora	<__si
  110  00:F9A7  F0 0F     	beq	.l1
  111  00:F9A9  A5 F9     	lda	<__ah
  112  00:F9AB  8D 8A 26  	sta	joycallback+2
  113  00:F9AE  A5 F8     	lda	<__al
  114  00:F9B0  8D 89 26  	sta	joycallback+1
  115  00:F9B3  A9 80     	lda	#$80
  116  00:F9B5  8D 88 26  	sta	joycallback
  117  00:F9B8  60        .l1:	rts
  118                     
  119                     ; get_joy_events(char num, int rst)
  120                     ; ----
  121                     ; return all the collected joypad events
  122                     ; ----
  123                     
  124  00:F9B9            _get_joy_events.2:
  125  00:F9B9  A4 F8     	ldy	<__al
  126  00:F9BB  E0 00     	cpx	#0
  127  00:F9BD  D0 06     	bne	_get_joy_events.sub
  128  00:F9BF  BE 81 26  	ldx	joybuf,Y
  129  00:F9C2  62        	cla
  130  00:F9C3  60        	rts
  131  00:F9C4            _get_joy_events.1:
  132  00:F9C4  02        	sxy
  133  00:F9C5            _get_joy_events.sub:
  134  00:F9C5  BE 81 26  	ldx	joybuf,Y
  135  00:F9C8  62        	cla
  136  00:F9C9  99 81 26  	sta	joybuf,Y
  137  00:F9CC  60        	rts
  138                     
  139                     ; clear_joy_events(char mask)
  140                     ; ----
  141                     
  142  00:F9CD            _clear_joy_events:
  143  00:F9CD  86 F8     	stx	<__al
  144  00:F9CF  C2        	cly
  145  00:F9D0  78        	sei
  146  00:F9D1  46 F8     .l1:	lsr	<__al
  147  00:F9D3  90 15     	bcc	.l2
  148  00:F9D5  62        	cla
  149  00:F9D6  99 81 26  	sta	joybuf,Y
  150  00:F9D9  99 A2 26  	sta	joybuf6,Y
  151  00:F9DC  99 2D 22  	sta	joytrg,Y
  152  00:F9DF  99 98 26  	sta	joytrg6,Y
  153  00:F9E2  A9 FF     	lda	#$FF
  154  00:F9E4  99 32 22  	sta	joyold,Y
  155  00:F9E7  99 9D 26  	sta	joyold6,Y
  156  00:F9EA  C8        .l2:	iny
  157  00:F9EB  C0 05     	cpy	#5
  158                     	blo	.l1
       00:F9ED  90 E2     	bcc	.l1
  159  00:F9EF  58        	cli
  160  00:F9F0  60        	rts
  161                     
  162                     
  163                     ; clock_hh()
  164                     ; ----
  165  00:F9F1            _clock_hh:
  166  00:F9F1  62        	cla
  167  00:F9F2  AE 8F 26  	ldx	clock_hh
  168  00:F9F5  60        	rts
  169                     
  170                     ; clock_mm()
  171                     ; ----
  172  00:F9F6            _clock_mm:
  173  00:F9F6  62        	cla
  174  00:F9F7  AE 90 26  	ldx	clock_mm
  175  00:F9FA  60        	rts
  176                     
  177                     ; clock_ss()
  178                     ; ----
  179  00:F9FB            _clock_ss:
  180  00:F9FB  62        	cla
  181  00:F9FC  AE 91 26  	ldx	clock_ss
  182  00:F9FF  60        	rts
  183                     
  184                     ; clock_tt()
  185                     ; ----
  186  00:FA00            _clock_tt:
  187  00:FA00  62        	cla
  188  00:FA01  AE 92 26  	ldx	clock_tt
  189  00:FA04  60        	rts
  190                     
  191                     ; clock_reset()
  192                     ; ----
  193  00:FA05            _clock_reset:
  194  00:FA05  9C 8F 26  	stz	clock_hh
  195  00:FA08  9C 90 26  	stz	clock_mm
  196  00:FA0B  9C 91 26  	stz	clock_ss
  197  00:FA0E  9C 92 26  	stz	clock_tt
  198  00:FA11  60        	rts
  199                     
  200                     
  201                     ; poke(int offset bx, char val)
  202                     ; ----
  203                     
  204  00:FA12            _poke.2:
  205  00:FA12  8A        	txa
  206  00:FA13  92 FA     	sta	[__bx]
  207  00:FA15  60        	rts
  208                     
  209                     ; poke/pokew(int offset bx, int val)
  210                     ; ----
  211                     
  212  00:FA16            _pokew.2:
  213  00:FA16  22        	sax
  214  00:FA17  92 FA     	sta	[__bx]
  215  00:FA19  A0 01     	ldy	#1
  216  00:FA1B  22        	sax
  217  00:FA1C  91 FA     	sta	[__bx],Y
  218  00:FA1E  60        	rts
  219                     
  220                     ; peek(int offset)
  221                     ; ----
  222                     
  223  00:FA1F            _peek:
  224                     	__stw	<__ptr
       00:FA1F  86 06     	stx	<__ptr
       00:FA21  85 07     	sta	<__ptr+1
  225  00:FA23  B2 06     	lda	[__ptr]
  226  00:FA25  AA        	tax
  227  00:FA26  62        	cla
  228  00:FA27  60        	rts
  229                     
  230                     ; peekw(int offset)
  231                     ; ----
  232                     
  233  00:FA28            _peekw:
  234                     	__stw	<__ptr
       00:FA28  86 06     	stx	<__ptr
       00:FA2A  85 07     	sta	<__ptr+1
  235  00:FA2C  B2 06     	lda	[__ptr]
  236  00:FA2E  AA        	tax
  237  00:FA2F  A0 01     	ldy	#1
  238  00:FA31  B1 06     	lda	[__ptr],Y
  239  00:FA33  60        	rts
  240                     
  241                     ; farpeekb(far void *base)
  242                     ; ----
  243                     
  244  00:FA34            _farpeekb.1:
  245  00:FA34  A5 08     	lda	<__fbank
  246  00:FA36  53 08     	tam	#3
  247  00:FA38  A5 0A     	lda	<__fptr+1
  248  00:FA3A  29 1F     	and	#$1F
  249  00:FA3C  09 60     	ora	#$60
  250  00:FA3E  85 0A     	sta	<__fptr+1
  251  00:FA40  B2 09     	lda	[__fptr]
  252  00:FA42  AA        	tax
  253  00:FA43  62        	cla
  254  00:FA44  60        	rts
  255                     
  256                     ; farpeekw(far void *base)
  257                     ; ----
  258                     
  259  00:FA45            _farpeekw.1:
  260  00:FA45  A5 08     	lda	<__fbank
  261  00:FA47  53 08     	tam	#3
  262  00:FA49  A5 0A     	lda	<__fptr+1
  263  00:FA4B  29 1F     	and	#$1F
  264  00:FA4D  09 60     	ora	#$60
  265  00:FA4F  85 0A     	sta	<__fptr+1
  266  00:FA51  80 09     	bra	_farpeekw.sub
  267  00:FA53            _farpeekw.fast:
  268  00:FA53  53 08     	tam	#3
  269  00:FA55  8A        	txa
  270  00:FA56  29 1F     	and	#$1F
  271  00:FA58  09 60     	ora	#$60
  272  00:FA5A  85 0A     	sta	<__fptr+1
  273  00:FA5C            _farpeekw.sub:
  274  00:FA5C  B2 09     	lda	[__fptr]
  275  00:FA5E  AA        	tax
  276  00:FA5F  E6 09     	inc	<__fptr
  277  00:FA61  90 08     	bcc	.l1
  278  00:FA63  E6 0A     	inc	<__fptr+1
  279  00:FA65  10 04     	bpl	.l1
  280  00:FA67  A9 60     	lda	#$60
  281  00:FA69  85 0A     	sta	<__fptr+1
  282  00:FA6B            .l1:
  283  00:FA6B  B2 09     	lda	[__fptr]
  284  00:FA6D  60        	rts
  285                     
  286                     ; farmemget(void *dst, far void *base, int len)
  287                     ; ----
  288                     
  289  00:FA6E            _farmemget.3:
  290                     	maplibfunc	lib2_farmemget.3
       00:FA6E  A8        	tay
       00:FA6F  43 20     	tma	#page(lib2_farmemget.3)
       00:FA71  48        	pha
       00:FA72  A9 01     	lda	#bank(lib2_farmemget.3)
       00:FA74  53 20     	tam	#page(lib2_farmemget.3)
       00:FA76  98        	tya
       00:FA77  20 34 B4  	jsr	lib2_farmemget.3
       00:FA7A  A8        	tay
       00:FA7B  68        	pla
       00:FA7C  53 20     	tam	#page(lib2_farmemget.3)
       00:FA7E  98        	tya
  291  00:FA7F  60        	rts
  292                     
  293                     ; The following function was too large to stay
  294                     ; in LIB1_BANK, so it is placed in LIB2_BANK
  295                     ; and must be mapped in and out when used.
  296                     
  297                     ; Code after this routine should be back in LIB1_BANK
  298                     
  299           0001      	.bank	LIB2_BANK
  300                     
  301  01:B434            lib2_farmemget.3:
  302                     
  303                     	__stw	<__cx
       01:B434  86 FC     	stx	<__cx
       01:B436  85 FD     	sta	<__cx+1
  304  01:B438  A5 08     	lda	<__fbank
  305  01:B43A  53 08     	tam	#3
  306                     
  307                     	; ----
  308                     	; split transfer if needed
  309                     	;
  310                     	; -- clip length (max. 8KB)
  311                     	cmpw	#$2000,<__cx
       01:B43C  A5 FD     	lda	HIGH_BYTE <__cx
       01:B43E  C9 20     	cmp	HIGH_BYTE #$2000
       01:B440  D0 04     	bne	.x_00517
       01:B442  A5 FC     	lda	LOW_BYTE <__cx
       01:B444  C9 00     	cmp	LOW_BYTE #$2000
       01:B446            .x_00517:
  312                     	blo	.t1
       01:B446  90 08     	bcc	.t1
  313                     	stw	#$2000,<__cx
       01:B448  A9 00     	lda	LOW_BYTE #$2000
       01:B44A  85 FC     	sta	LOW_BYTE <__cx
       01:B44C  A9 20     	lda	HIGH_BYTE #$2000
       01:B44E  85 FD     	sta	HIGH_BYTE <__cx
  314                     	; -- check length
  315  01:B450  A5 09     .t1:	lda	<__fptr
  316                     	add	<__cl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B452  18        	clc
       01:B453  65 FC     	adc	<__cl
                          .endif
  317  01:B455  85 F8     	sta	<__al
  318  01:B457  A5 0A     	lda	<__fptr+1
  319  01:B459  29 1F     	and	#$1F
  320  01:B45B  65 FD     	adc	<__ch
  321  01:B45D  85 F9     	sta	<__ah
  322  01:B45F  C9 20     	cmp	#$20
  323                     	blo	.t2
       01:B461  90 15     	bcc	.t2
  324                     	; -- calculate second-half size
  325  01:B463  29 1F     	and	#$1F
  326  01:B465  85 FF     	sta	<__dh
  327  01:B467  A5 F8     	lda	<__al
  328  01:B469  85 FE     	sta	<__dl
  329                     	subw	<__dx,<__cx
       01:B46B  38        	sec
       01:B46C  A5 FC     	lda	LOW_BYTE <__cx
       01:B46E  E5 FE     	sbc	LOW_BYTE <__dx
       01:B470  85 FC     	sta	LOW_BYTE <__cx
       01:B472  A5 FD     	lda	HIGH_BYTE <__cx
       01:B474  E5 FF     	sbc	HIGH_BYTE <__dx
       01:B476  85 FD     	sta	HIGH_BYTE <__cx
  330                     	; -- remap src ptr
  331  01:B478  A5 0A     .t2:	lda	<__fptr+1
  332  01:B47A  29 1F     	and	#$1F
  333  01:B47C  09 60     	ora	#$60
  334  01:B47E  85 0A     	sta	<__fptr+1
  335                     
  336                     	; ----
  337                     	; copy a block
  338                     	;
  339  01:B480  82        	clx
  340  01:B481  C2        	cly
  341  01:B482  C6 FD     	dec	<__ch
  342  01:B484  30 1C     	bmi	.l4
  343                     	; -- main loop
  344  01:B486  B1 09     .l1:	lda	[__fptr],Y
  345  01:B488  91 FA     	sta	[__bx],Y
  346  01:B48A  C8        	iny
  347  01:B48B  CA        	dex
  348  01:B48C  D0 F8     	bne	.l1
  349                     	; -- inc dst ptr
  350  01:B48E  C0 00     	cpy	#0
  351  01:B490  F0 08     	beq	.l2
  352  01:B492  98        	tya
  353                     	add	<__bl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B493  18        	clc
       01:B494  65 FA     	adc	<__bl
                          .endif
  354  01:B496  85 FA     	sta	<__bl
  355  01:B498  90 02     	bcc	.l3
  356  01:B49A  E6 FB     .l2:	inc	<__bh
  357                     	; -- inc src ptr
  358  01:B49C  E6 0A     .l3:	inc	<__fptr+1
  359                     	; -- next chunk
  360  01:B49E  C6 FD     	dec	<__ch
  361  01:B4A0  10 E4     	bpl	.l1
  362  01:B4A2  A6 FC     .l4:	ldx	<__cl
  363  01:B4A4  64 FC     	stz	<__cl
  364  01:B4A6  D0 DE     	bne	.l1
  365                     
  366                     	; ----
  367                     	; second half
  368                     	;
  369                     	tstw	<__dx
       01:B4A8  A5 FE     	lda	<__dx		; value at stated memory
       01:B4AA  05 FF     	ora	<__dx+1		; location is zero
  370  01:B4AC  F0 17     	beq	.l5
  371                     	; -- reload dst and cnt
  372                     	stw	<__dx,<__cx
       01:B4AE  A5 FE     	lda	LOW_BYTE <__dx
       01:B4B0  85 FC     	sta	LOW_BYTE <__cx
       01:B4B2  A5 FF     	lda	HIGH_BYTE <__dx
       01:B4B4  85 FD     	sta	HIGH_BYTE <__cx
  373                     	stw	#$6000,<__fptr
       01:B4B6  A9 00     	lda	LOW_BYTE #$6000
       01:B4B8  85 09     	sta	LOW_BYTE <__fptr
       01:B4BA  A9 60     	lda	HIGH_BYTE #$6000
       01:B4BC  85 0A     	sta	HIGH_BYTE <__fptr
  374                     	; -- inc bank
  375  01:B4BE  43 08     	tma	#3
  376  01:B4C0  1A        	inc	A
  377  01:B4C1  53 08     	tam	#3
  378  01:B4C3  80 C1     	bra	.l1
  379                     
  380                     	; ----
  381                     	; exit
  382                     	;
  383  01:B4C5  60        .l5:	rts
  384                     
  385                     ; The preceding function was too large to stay
  386                     ; in LIB1_BANK, so it is placed in LIB2_BANK
  387                     ; and must be mapped in and out when used.
  388                     
  389                     ; Code after this routine should be back in LIB1_BANK
  390                     
  391           0000      	.bank	LIB1_BANK
  392                     
  393                     
  394                     ; srand(int seed)
  395                     ; srand32.2(int seed1 [__dx], int seed2 [__cx])
  396                     ; ---------------
  397                     ; set the seed number for the pseudo-random number generator
  398                     
  399  00:FA80            _srand:
  400                     	__stw	<__dx
       00:FA80  86 FE     	stx	<__dx
       00:FA82  85 FF     	sta	<__dx+1
  401                     	__stw	<__cx
       00:FA84  86 FC     	stx	<__cx
       00:FA86  85 FD     	sta	<__cx+1
  402                     
  403  00:FA88            _srand32.2:
  404  00:FA88  20 BE E6  	jsr	srand
  405  00:FA8B  60        	rts
  406                     
  407                     ; rand()
  408                     ; ----
  409                     ; get a 16-bit random number
  410                     
  411  00:FA8C            _rand:
  412  00:FA8C  20 E4 E6  	jsr	rand
  413                     	__ldw	<__dx
                0000      .if (1 = 2)
                          .else
       00:FA8F  A6 FE     	ldx	<__dx
       00:FA91  A5 FF     	lda	<__dx+1
                          .endif
  414  00:FA93  60        	rts
  415                     
  416                     
  417                     ; random(char limit)
  418                     ; --- 
  419                     ; get a random number where 0 <= n < limit
  420                     ; (and limit < 128)
  421                     
  422  00:FA94            _random:
  423  00:FA94  22        	sax
  424  00:FA95  29 7F     	and	#$7f
  425  00:FA97  20 5D E7  	jsr	random
  426  00:FA9A  22        	sax
  427  00:FA9B  62        	cla
  428  00:FA9C  60        	rts
  429                     
#[2]   startup.asm
 1283                     
 1284                     .endif	; HUC
 1285                     
 1286           0001      .ifdef SUPPORT_MOUSE
#[3]   mouse.asm
 1287                      .include "mouse.asm"
    1                     ;- The mouse is read 4 successive times, in order to assemble the mouse data
    2                     ;  (horiz most-significant-nybble/horiz LSN/vert MSN/vert LSN).
    3                     ;- values are deltas, and reading the mouse every VSYNC is normal
    4                     ;- For vertical movement, up is positive, down is negative
    5                     ;- For horizontal movement, left is positive, right is negative
    6                     ;- I was not able to yield a delta value greater than 0x25 (hexadecimal)
    7                     ;  during a 1-VSYNC interval  (I didn't try all *that* hard though).  This
    8                     ;  should give you an idea of the sensitivity.
    9                     
   10                     ;
   11                     ;  PCE mouse driver source
   12                     ;
   13                     
   14           298E      	.bss
   15  --:298E            msflag:	.ds 1
   16  --:298F            msvert:	.ds 1
   17  --:2990            mshorz:	.ds 1
   18                     
   19           FA9D      	.code
   20                     
   21                     ;
   22                     ; These stub interfaces are available from LIB1_BANK
   23                     ; But the real guts are in LIB2_BANK
   24                     ;
   25  00:FA9D            mousinit:
   26                     	maplibfunc	lib2_mousinit
       00:FA9D  A8        	tay
       00:FA9E  43 20     	tma	#page(lib2_mousinit)
       00:FAA0  48        	pha
       00:FAA1  A9 01     	lda	#bank(lib2_mousinit)
       00:FAA3  53 20     	tam	#page(lib2_mousinit)
       00:FAA5  98        	tya
       00:FAA6  20 C6 B4  	jsr	lib2_mousinit
       00:FAA9  A8        	tay
       00:FAAA  68        	pla
       00:FAAB  53 20     	tam	#page(lib2_mousinit)
       00:FAAD  98        	tya
   27  00:FAAE  60        	rts
   28                     
   29  00:FAAF            mousread:
   30                     	maplibfunc	lib2_mousread
       00:FAAF  A8        	tay
       00:FAB0  43 20     	tma	#page(lib2_mousread)
       00:FAB2  48        	pha
       00:FAB3  A9 01     	lda	#bank(lib2_mousread)
       00:FAB5  53 20     	tam	#page(lib2_mousread)
       00:FAB7  98        	tya
       00:FAB8  20 55 B5  	jsr	lib2_mousread
       00:FABB  A8        	tay
       00:FABC  68        	pla
       00:FABD  53 20     	tam	#page(lib2_mousread)
       00:FABF  98        	tya
   31  00:FAC0  60        	rts
   32                     
   33                     
   34                     ;
   35                     ; These functions are available in bank 2 of the
   36                     ; library:
   37                     ;
   38           0001      	.bank	LIB2_BANK
   39                     
   40                     ;
   41                     ; detect and initialize the mouse
   42                     ;
   43  01:B4C6            lib2_mousinit:
   44  01:B4C6  A9 20     	lda	#$20	; reset resource-usage flag
   45  01:B4C8  04 F5     	tsb	<irq_m	; to skip joystick read portion of vsync
   46                     
   47  01:B4CA  9C 28 22  	stz	joy	; clear joypad memory area
   48  01:B4CD  73 28 22  	tii	joy, joy+1, $4
       01:B4D0  29 22 04  
       01:B4D3  00        
   49                     
   50  01:B4D4  9C 2D 22  	stz	joytrg	; clear joypad memory area
   51  01:B4D7  73 2D 22  	tii	joytrg, joytrg+1, $4
       01:B4DA  2E 22 04  
       01:B4DD  00        
   52                     
   53  01:B4DE  9C 32 22  	stz	joyold	; clear joypad memory area
   54  01:B4E1  73 32 22  	tii	joyold, joyold+1, $4
       01:B4E4  33 22 04  
       01:B4E7  00        
   55                     
   56  01:B4E8  9C 81 26  	stz	joybuf	; clear joypad memory area
   57  01:B4EB  73 81 26  	tii	joybuf, joybuf+1, $4
       01:B4EE  82 26 04  
       01:B4F1  00        
   58                     
   59  01:B4F2  9C 93 26  	stz	joy6	; clear joypad memory area
   60  01:B4F5  73 93 26  	tii	joy6, joy6+1, $4
       01:B4F8  94 26 04  
       01:B4FB  00        
   61                     
   62  01:B4FC  9C 98 26  	stz	joytrg6	; clear joypad memory area
   63  01:B4FF  73 98 26  	tii	joytrg6, joytrg6+1, $4
       01:B502  99 26 04  
       01:B505  00        
   64                     
   65  01:B506  9C 9D 26  	stz	joyold6	; clear joypad memory area
   66  01:B509  73 9D 26  	tii	joyold6, joyold6+1, $4
       01:B50C  9E 26 04  
       01:B50F  00        
   67                     
   68  01:B510  9C A2 26  	stz	joybuf6	; clear joypad memory area
   69  01:B513  73 A2 26  	tii	joybuf6, joybuf6+1, $4
       01:B516  A3 26 04  
       01:B519  00        
   70                     
   71  01:B51A  9C 8F 29  	stz	msvert
   72  01:B51D  9C 90 29  	stz	mshorz
   73  01:B520  9C 8E 29  	stz	msflag
   74                     
   75  01:B523  62        	cla		; counter of 'good' reads (where vertical == 0)
   76  01:B524  A2 0A     	ldx	#$0A	; try 10 iterations
   77  01:B526  48        .loop1:	pha
   78  01:B527  DA        	phx
   79  01:B528  A9 01     	lda	#1
   80                     ;	jsr	wait_vsync	; wait for 1 vsync frame
   81  01:B52A  20 55 B5  	jsr	lib2_mousread	; read mouse
   82  01:B52D  FA        	plx
   83  01:B52E  68        	pla
   84  01:B52F  AC 8F 29  	ldy	msvert	; read mouse vertical axis movement
   85  01:B532  D0 01     	bne	.l1	; if (val == 0), inc counter
   86  01:B534  1A        	inc a
   87  01:B535  CA        .l1:	dex
   88  01:B536  D0 EE     	bne	.loop1	; next iteration
   89                     
   90  01:B538  C9 00     	cmp	#$00	; if #$00 value found even once (out of 10 times)
   91  01:B53A  D0 0F     	bne	.mous	; then return(1)
   92                     
   93  01:B53C  A9 20     	lda	#$20	; reset #$20 bit of $F5
   94  01:B53E  14 F5     	trb	<irq_m
   95  01:B540  62        	cla		; bad return code
   96  01:B541  8D 8E 29  	sta	msflag
   97  01:B544  9C 8F 29  	stz	msvert
   98  01:B547  9C 90 29  	stz	mshorz
   99  01:B54A  60        	rts
  100                     
  101  01:B54B            .mous:
  102  01:B54B  A9 20     	lda	#$20	; reset #$20 bit of $F5
  103  01:B54D  14 F5     	trb	<irq_m
  104  01:B54F  A9 01     	lda	#$01	; good return code
  105  01:B551  8D 8E 29  	sta	msflag
  106  01:B554  60        	rts
  107                     
  108                     ;
  109                     ; actual mechanics of reading mouse
  110                     ;
  111  01:B555            lib2_mousread:
  112  01:B555  A2 04     	ldx	#$04	; # iterations (actually 5)
  113  01:B557  BD 28 22  .loop1:	lda	joy,X	; copy 'current' value to 'previous' value
  114  01:B55A  9D 32 22  	sta	joyold,X
  115  01:B55D  CA        	dex
  116  01:B55E  10 F7     	bpl	.loop1
  117                     
  118  01:B560  9C 28 22  	stz	joy	; initialize joypad #1's value
  119                     
  120  01:B563  A9 01     	lda	#$01	; reset joypad port# to joystick #1
  121  01:B565  8D 00 10  	sta	joyport
  122  01:B568  A9 03     	lda	#$03
  123  01:B56A  8D 00 10  	sta	joyport
  124  01:B56D  A9 01     	lda	#$01
  125  01:B56F  8D 00 10  	sta	joyport
  126                     
  127  01:B572  20 EA B5  	jsr	delay240	; delay 240 CPU cycles
  128                     
  129  01:B575  AD 00 10  	lda	joyport	; read joystick port
  130  01:B578  0A        	asl a	; upper nybble of 8-bit value - shift it
  131  01:B579  0A        	asl a
  132  01:B57A  0A        	asl a
  133  01:B57B  0A        	asl a
  134  01:B57C  8D 90 29  	sta	mshorz	; store it
  135  01:B57F  20 F7 B5  	jsr	msbutt	; read buttons (toggle port/read other nybble)
  136                     
  137  01:B582  A9 01     	lda	#$01	; reset joystick port again (to stick #1)
  138  01:B584  8D 00 10  	sta	joyport
  139  01:B587  A9 03     	lda	#$03
  140  01:B589  8D 00 10  	sta	joyport
  141  01:B58C  A9 01     	lda	#$01
  142  01:B58E  8D 00 10  	sta	joyport
  143                     
  144  01:B591  20 F6 B5  	jsr	delay14	; wait 14 cycles to settle (reference code says 9)
  145                     
  146  01:B594  AD 00 10  	lda	joyport	; read port
  147  01:B597  29 0F     	and	#$0F	; lower nybble of 8-bit value
  148  01:B599  0C 90 29  	tsb	mshorz	; 'or' it into memory
  149  01:B59C  44 59     	bsr	msbutt	; read buttons (toggle port/read other nybble)
  150                     
  151  01:B59E  A9 01     	lda	#$01	; reset joystick port again
  152  01:B5A0  8D 00 10  	sta	joyport
  153  01:B5A3  A9 03     	lda	#$03
  154  01:B5A5  8D 00 10  	sta	joyport
  155  01:B5A8  A9 01     	lda	#$01
  156  01:B5AA  8D 00 10  	sta	joyport
  157                     
  158  01:B5AD  20 F6 B5  	jsr	delay14	; wait 14 cycles to settle (reference code says 9)
  159                     
  160  01:B5B0  AD 00 10  	lda	joyport	; read port
  161  01:B5B3  0A        	asl a	; upper nybble of 8-bit value - shift it
  162  01:B5B4  0A        	asl a
  163  01:B5B5  0A        	asl a
  164  01:B5B6  0A        	asl a
  165  01:B5B7  8D 8F 29  	sta	msvert
  166  01:B5BA  44 3B     	bsr	msbutt	; read buttons (toggle port/read other nybble)
  167                     
  168  01:B5BC  A9 01     	lda	#$01	; reset joystick port again
  169  01:B5BE  8D 00 10  	sta	joyport
  170  01:B5C1  A9 03     	lda	#$03
  171  01:B5C3  8D 00 10  	sta	joyport
  172  01:B5C6  A9 01     	lda	#$01
  173  01:B5C8  8D 00 10  	sta	joyport
  174                     
  175  01:B5CB  20 F6 B5  	jsr	delay14	; wait 14 cycles to settle (reference code says 9)
  176                     
  177  01:B5CE  AD 00 10  	lda	joyport	; read port
  178  01:B5D1  29 0F     	and	#$0F	; lower nybble of 8-bit value
  179  01:B5D3  0C 8F 29  	tsb	msvert	; 'or' it into value
  180  01:B5D6  44 1F     	bsr	msbutt	; read buttons (toggle port/read other nybble)
  181                     
  182  01:B5D8  AD 2D 22  	lda	joytrg	; check joystick buttons
  183  01:B5DB  C9 04     	cmp	#$04	; is 'select' newly-pressed ?
  184  01:B5DD  D0 0A     	bne	.exit
  185  01:B5DF  AD 28 22  	lda	joy	; if so, are both run & select pressed ?
  186  01:B5E2  C9 0C     	cmp	#$0C
  187  01:B5E4  D0 03     	bne	.exit
  188  01:B5E6  6C 84 22  	jmp	[soft_reset]	; if yes, reboot
  189  01:B5E9  60        .exit:	rts		; else return
  190                     
  191  01:B5EA            delay240:
  192  01:B5EA  48        	pha		; delay loop for 240 processor cycles
  193  01:B5EB  DA        	phx		; (including call/return overhead)
  194  01:B5EC  62        	cla
  195  01:B5ED  EA        	nop
  196  01:B5EE  EA        .lp:	nop
  197  01:B5EF  1A        	inc	a
  198  01:B5F0  C9 15     	cmp	#21
  199  01:B5F2  90 FA     	bcc	.lp
  200  01:B5F4  FA        	plx
  201  01:B5F5  68        	pla
  202  01:B5F6            delay14:
  203  01:B5F6  60        	rts
  204                     
  205  01:B5F7            msbutt:
  206  01:B5F7  9C 00 10  	stz	joyport	; toggle joystick port to read buttons
  207                     
  208  01:B5FA  20 F6 B5  	jsr	delay14	; wait 14 cycles to settle (reference code says 9)
  209                     
  210  01:B5FD  AD 00 10  	lda	joyport	; read value
  211  01:B600  49 FF     	eor	#$FF	; change low-active to high-active
  212  01:B602  29 0F     	and	#$0F	; only 4 bits
  213  01:B604  0C 28 22  	tsb	joy	; 'or' it into value
  214                     
  215  01:B607  0D 32 22  	ora	joyold	; determine 'newly-pressed' buttons
  216  01:B60A  4D 32 22  	eor	joyold
  217  01:B60D  8D 2D 22  	sta	joytrg	; put them into 'delta'
  218  01:B610  60        	rts
  219                     
  220           0000      	.bank	LIB1_BANK	; restore bank-context
#[2]   startup.asm
 1288                     .endif	; SUPPORT_MOUSE
 1289                     
 1290           0000      .if (CDROM)
 1292                     .endif	; CDROM
 1293                     
 1294           0000      .if (NEED_SOUND_CODE)
 1296                     .endif ; defined in sound.inc if needed
 1297                     
 1298                     ;
 1299                     ;
 1300                     ;
 1301                     
 1302                     ; ----
 1303                     ; disp_on
 1304                     ; ----
 1305                     ; enable display
 1306                     ; ----
 1307                     
 1308           0001      .ifdef HUC
 1309                     
 1310  00:FAC1            _disp_on:
 1311  00:FAC1  AE 8E 26  	ldx   disp_cr
 1312           0000      .if (CDROM)
 1314                     .else
 1315  00:FAC4  A9 01      	lda	#1
 1316                     .endif
 1317  00:FAC6  8D 8E 26  	sta   disp_cr
 1318  00:FAC9  62        	cla
 1319  00:FACA  60        	rts
 1320                     
 1321                     .else	; HUC
 1328                     .endif	; HUC
 1329                     
 1330                     
 1331                     ; ----
 1332                     ; disp_off
 1333                     ; ----
 1334                     ; disable display
 1335                     ; ----
 1336                     
 1337           0001      .ifdef HUC
 1338                     
 1339  00:FACB            _disp_off:
 1340  00:FACB  AE 8E 26  	ldx   disp_cr
 1341           0000      .if (CDROM)
 1344                     .else
 1345  00:FACE  9C 8E 26   	stz	disp_cr
 1346                     .endif
 1347  00:FAD1  62        	cla
 1348  00:FAD2  60        	rts
 1349                     
 1350                     .else	; HUC
 1356                     .endif	; HUC
 1357                     
 1358                     ; ----
 1359                     ; set_intvec
 1360                     ; ----
 1361                     ; set interrupt vector
 1362                     ; ----
 1363                     ; IN : A = vector number
 1364                     ;           0 IRQ2
 1365                     ;           1 IRQ1 (VDC)
 1366                     ;           2 TIMER
 1367                     ;           3 NMI
 1368                     ;           4 VSYNC
 1369                     ;           5 HSYNC
 1370                     ;           6 SOFT RESET (RUN + SELECT)
 1371                     ;      X = vector address low byte
 1372                     ;      Y =   "      "    high byte
 1373                     ; ----
 1374                     
 1375           0001      .if  !(CDROM)
 1376                     
 1377  00:FAD3            set_intvec:
 1378  00:FAD3  08        	php
 1379  00:FAD4  78        	sei
 1380  00:FAD5  C9 06     	cmp   #6
 1381                     	blo  .vector
       00:FAD7  90 0A     	bcc	.vector
 1382  00:FAD9  D0 14     	bne  .exit
 1383  00:FADB            .reset:
 1384  00:FADB  8E 84 22  	stx   soft_reset
 1385  00:FADE  8C 85 22  	sty   soft_reset+1
 1386  00:FAE1  80 0C     	bra  .exit	
 1387  00:FAE3            .vector:
 1388  00:FAE3  48        	pha
 1389  00:FAE4  0A        	asl   A
 1390  00:FAE5  22        	sax
 1391  00:FAE6  9D 00 22  	sta   user_jmptbl,X
 1392  00:FAE9  E8        	inx
 1393  00:FAEA  98        	tya
 1394  00:FAEB  9D 00 22  	sta   user_jmptbl,X
 1395  00:FAEE  68        	pla
 1396  00:FAEF            .exit:
 1397  00:FAEF  28        	plp
 1398  00:FAF0  60        	rts
 1399                     
 1400                     .endif	; !(CDROM)
 1401                     
 1402                     ; ----
 1403                     ; wait_vsync
 1404                     ; ----
 1405                     ; wait the next vsync
 1406                     ; ----
 1407                     ; IN :  A = number of frames to be sync'ed on
 1408                     ; ----
 1409                     ; OUT:  A = number of elapsed frames since last call
 1410                     ; ----
 1411                     
 1412  00:FAF1            wait_vsync:
 1413  00:FAF1  1F F5 03  	bbr1 <irq_m,.l1
 1414  00:FAF4  62        	cla			; return immediately if IRQ1 is redirected
 1415           0001      .ifdef HUC
 1416  00:FAF5  82        	clx
 1417                     .endif
 1418  00:FAF6  60        	rts
 1419                     
 1420  00:FAF7  78        .l1:	sei			; disable interrupts
 1421  00:FAF8  CD 41 22  	cmp   irq_cnt		; calculate how many frames to wait
 1422  00:FAFB  F0 05     	beq  .l2
 1423                     	bhs  .l3
       00:FAFD  B0 04     	bcs	.l3
 1424  00:FAFF  AD 41 22  	lda   irq_cnt
 1425  00:FB02  1A        .l2:	inc   A
 1426                     .l3:	sub   irq_cnt
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:FB03  38        	sec
       00:FB04  ED 41 22  	sbc	irq_cnt
                          .endif
 1427  00:FB07  8D 80 26  	sta   vsync_cnt
 1428  00:FB0A  58        	cli			; re-enable interrupts
 1429                     
 1430  00:FB0B  AD 41 22  .l4:	lda   irq_cnt		; wait loop
 1431                     .l5:	incw  rndseed2
       00:FB0E  EE 75 27  	inc	rndseed2		; value at stated memory
       00:FB11  D0 03     	bne	.x_00535		; location
       00:FB13  EE 76 27  	inc	rndseed2+1
       00:FB16            .x_00535:
 1432  00:FB16  CD 41 22  	cmp   irq_cnt
 1433  00:FB19  F0 F3     	beq  .l5
 1434  00:FB1B  CE 80 26  	dec   vsync_cnt
 1435  00:FB1E  D0 EB     	bne  .l4
 1436                     
 1437  00:FB20  9C 41 22  	stz   irq_cnt		; reset system interrupt counter
 1438  00:FB23  1A        	inc   A			; return number of elapsed frames
 1439                     
 1440           0000      .ifndef HUC
 1444                     .else	; !HUC
 1445                     
 1446                         ; ----
 1447                         ; callback support
 1448                     
 1449  00:FB24  48        	pha
 1450  00:FB25  AD 88 26  	lda   joycallback	; callback valid?
 1451  00:FB28  10 34     	bpl  .t3
 1452  00:FB2A  89 01     	bit   #$01
 1453  00:FB2C  D0 30     	bne  .t3
 1454                     
 1455  00:FB2E  AD 89 26  	lda   joycallback+1	; get events for all the 
 1456  00:FB31  F0 2B     	beq  .t3		; selected joypads
 1457  00:FB33  85 F8     	sta  <__al
 1458  00:FB35  C2        	cly
 1459  00:FB36  62        	cla
 1460  00:FB37  46 F8     .t1:    lsr  <__al
 1461  00:FB39  90 03     	bcc  .t2
 1462  00:FB3B  19 81 26  	ora   joybuf,Y
 1463  00:FB3E  C8        .t2:	iny
 1464  00:FB3F  C0 05     	cpy   #5
 1465                     	blo  .t1
       00:FB41  90 F4     	bcc	.t1
 1466                     
 1467  00:FB43  2D 8A 26  	and   joycallback+2	; compare with requested state
 1468  00:FB46  F0 16     	beq  .t3
 1469                     
 1470  00:FB48  EE 88 26  	inc   joycallback	; lock callback feature
 1471  00:FB4B  AA        	tax			; call user routine
 1472  00:FB4C  43 20     	tma   #5
 1473  00:FB4E  48        	pha
 1474  00:FB4F  AD 8B 26  	lda   joycallback+3
 1475  00:FB52  53 20     	tam   #5
 1476  00:FB54  62        	cla
 1477  00:FB55  20 61 FB  	jsr  .callback
 1478  00:FB58  68        	pla
 1479  00:FB59  53 20     	tam   #5
 1480  00:FB5B  CE 88 26  	dec   joycallback	; unlock
 1481                     	; --
 1482  00:FB5E  FA        .t3:	plx
 1483  00:FB5F  62        	cla
 1484  00:FB60  60        	rts
 1485                     
 1486                         ; ----
 1487                         ; user routine callback
 1488                         ;
 1489  00:FB61            .callback:
 1490  00:FB61  6C 8C 26  	jmp   [joycallback+4]
 1491                     
 1492                     .endif	; !HUC
 1493                     
#[3]   joypad.asm
 1494                     .include  "joypad.asm"	; read joypad values
    1                     ; ----
    2                     ; read_joypad
    3                     ; ----
    4                     ; poll joypads
    5                     ;
    6                     ; 'joyport' (location $1000) is a control read/write port which only reads
    7                     ; 4 bits at a time; the program uses joyport to toggle the multiplex line
    8                     ;
    9                     ; real logic values are read into the port - the joypad's keys are default
   10                     ; high, and 'pulled' low when pressed.  Therefore, these values must be
   11                     ; inverted/complemented to yield values where '1' means 'pressed'
   12                     ;
   13                     ; bit values for joypad bytes: (MSB = #7; LSB = #0)
   14                     ; -------------------------------------------------
   15                     ; bit 0 (ie $01) = I
   16                     ; bit 1 (ie $02) = II
   17                     ; bit 2 (ie $04) = 'select'
   18                     ; bit 3 (ie $08) = 'run'
   19                     ; bit 4 (ie $10) = UP
   20                     ; bit 5 (ie $20) = RIGHT
   21                     ; bit 6 (ie $40) = DOWN
   22                     ; bit 7 (ie $80) = LEFT
   23                     ; ----
   24                     ; bit values for joypad 6-button bytes: (MSB = #7; LSB = #0)
   25                     ; ----------------------------------------------------------
   26                     ; bit 0	(ie $01) = III
   27                     ; bit 1	(ie $02) = IV
   28                     ; bit 2	(ie $04) = V
   29                     ; bit 3	(ie $08) = VI
   30                     ; bit 4-7 (ie $F0) = exists (all on or all off)
   31                     ; ----
   32                     
   33                     ; Note: Read twice for 6-button joysticks.
   34                     ; First read should be for 'joy' and second for
   35                     ; 'joy6'; need to hide values temporarily while
   36                     ; scanning twice.
   37                     
   38  00:FB64            read_joypad:
   39           0000      .ifdef _SGX
   41                     .else
   42                     	maplibfunc	lib2_readjoy
       00:FB64  A8        	tay
       00:FB65  43 20     	tma	#page(lib2_readjoy)
       00:FB67  48        	pha
       00:FB68  A9 01     	lda	#bank(lib2_readjoy)
       00:FB6A  53 20     	tam	#page(lib2_readjoy)
       00:FB6C  98        	tya
       00:FB6D  20 11 B6  	jsr	lib2_readjoy
       00:FB70  A8        	tay
       00:FB71  68        	pla
       00:FB72  53 20     	tam	#page(lib2_readjoy)
       00:FB74  98        	tya
   43                     .endif
   44  00:FB75  60        	rts
   45                     
   46           0000      .ifdef _SGX
   49                     .else
   50           0001      	.bank	LIB2_BANK
   51  01:B611            lib2_readjoy:
   52                     .endif
   53  01:B611  AD 27 22  	lda	joyena		; suppress reset during individual read
   54  01:B614  48        	pha
   55  01:B615  9C 27 22  	stz	joyena
   56                     
   57           0000      .if (CDROM)
   59                     .else
   60  01:B618  20 C3 B6  	jsr	.readjoys
   61                     .endif
   62                     
   63  01:B61B  73 28 22  	tii	joy, joy6, 5	; move to 6-button area
       01:B61E  93 26 05  
       01:B621  00        
   64                     
   65           0000      .if (CDROM)
   67                     .else
   68  01:B622  20 C3 B6  	jsr	.readjoys
   69                     .endif
   70                     
   71  01:B625  68        	pla
   72  01:B626  8D 27 22  	sta	joyena
   73                     
   74  01:B629  73 A7 26  	tii	joytmp, joyold, 5	; restore past info from stash
       01:B62C  32 22 05  
       01:B62F  00        
   75  01:B630  73 AC 26  	tii	joytmp6, joyold6, 5
       01:B633  9D 26 05  
       01:B636  00        
   76                     
   77                     	;
   78                     	; the '.l2' loop determines if first or
   79                     	; second scans imply a 6-button joystick,
   80                     	; and rearrange bytes if out of order,
   81                     	; and zero the joy6 area if necessary
   82                     	;
   83  01:B637  C2        	cly
   84  01:B638  B9 28 22  .l2:	lda	joy,Y		; check if 6-button joypad, and
   85  01:B63B  AA        	tax
   86  01:B63C  29 50     	and	#JOY_TYPE6	; scans became backwards somehow
   87  01:B63E  C9 50     	cmp	#JOY_TYPE6
   88  01:B640  D0 0A     	bne	.notswap
   89  01:B642  B9 93 26  	lda	joy6,Y		; then swap them if they need it
   90  01:B645  99 28 22  	sta	joy,Y
   91  01:B648  22        	sax
   92  01:B649  99 93 26  	sta	joy6,Y
   93                     
   94  01:B64C            .notswap:
   95  01:B64C  B9 93 26  	lda	joy6,Y		; verify whether a 6-button exists
   96  01:B64F  29 50     	and	#JOY_TYPE6
   97  01:B651  C9 50     	cmp	#JOY_TYPE6
   98  01:B653  F0 04     	beq	.type6
   99  01:B655  62        	cla
  100  01:B656  99 93 26  	sta	joy6,Y		; not 6-button, so clear extra entry
  101                     
  102  01:B659            .type6:
  103  01:B659  B9 93 26  	lda	joy6,Y		; strip off unused bits
  104  01:B65C  29 5F     	and	#(JOY_III | JOY_IV | JOY_V | JOY_VI | JOY_TYPE6)
  105  01:B65E  99 93 26  	sta	joy6,Y		; clear unnecessary bits
  106                     
  107                     
  108                     	;
  109                     	; The '.l2a' area sets appropriate values
  110                     	; for all of the joytrg and joybuf areas
  111                     	;
  112                     
  113  01:B661  B9 28 22  .l2a:	lda	joy,Y
  114  01:B664  59 32 22  	eor	joyold,Y		; check against previous value
  115  01:B667  39 28 22  	and	joy,Y
  116  01:B66A  99 2D 22  	sta	joytrg,Y		; 'new key pressed' key values
  117                     
  118                     	; ----
  119                     	; buffered 'new key pressed'
  120                     	; see joy_events();
  121                     	;
  122  01:B66D  19 81 26  	ora	joybuf,Y		; collect 'new key pressed'
  123  01:B670  99 81 26  	sta	joybuf,Y
  124                     
  125                     	; ----
  126                     	; repeat the joyold/joytrg/joybuf stuff
  127                     	; for 6-button values
  128                     	;
  129  01:B673  B9 93 26  	lda	joy6,Y
  130  01:B676  59 9D 26  	eor	joyold6,Y
  131  01:B679  39 93 26  	and	joy6,Y
  132  01:B67C  99 98 26  	sta	joytrg6,Y
  133  01:B67F  19 A2 26  	ora	joybuf6,Y
  134  01:B682  99 A2 26  	sta	joybuf6,Y
  135                     
  136                     	; ----
  137                     	; next joypad
  138                     	;
  139  01:B685  C8        	iny
  140  01:B686  C0 05     	cpy	#$05		; cycle for next of 5 joypads
  141  01:B688  90 AE     	bcc	.l2
  142                     
  143                     	; ----
  144                     	; soft reset check
  145                     	;
  146  01:B68A  C2        	cly			; start cycle of 5 joypads
  147  01:B68B  AD 27 22  .l3:	lda	joyena		; find mask of 'important' joysticks
  148  01:B68E  39 07 B7  	and	.bitmsk,Y
  149  01:B691  F0 11     	beq	.l4		; not important enough to check
  150  01:B693  B9 2D 22  	lda	joytrg,Y
  151  01:B696  C9 04     	cmp	#$04		; 'select' key newly-pressed ?
  152  01:B698  D0 0A     	bne	.l4
  153  01:B69A  B9 28 22  	lda	joy,Y
  154  01:B69D  C9 0C     	cmp	#$0C		; 'run+select' currently pressed ?
  155  01:B69F  D0 03     	bne	.l4
  156                     
  157           0000      .if (DEVELO)
  159                     .else
  160  01:B6A1  6C 84 22  	jmp	[soft_reset]	; run+select 'soft reset' vector
  161                     .endif ; (DEVELO)
  162                     
  163  01:B6A4  C8        .l4:	iny			; try next joypad
  164  01:B6A5  C0 05     	cpy	#$05
  165  01:B6A7  90 E2     	bcc	.l3
  166                     
  167                     	; ----
  168                     	; joyread hook
  169                     	;
  170           0001      .ifdef HUC
  171                     	tstw	joyhook
       01:B6A9  AD 86 26  	lda	joyhook		; value at stated memory
       01:B6AC  0D 87 26  	ora	joyhook+1		; location is zero
  172  01:B6AF  F0 03     	beq	.l5
  173  01:B6B1  20 0C B7  	jsr	.hook
  174  01:B6B4            .l5:
  175                     .endif	; HUC
  176                     
  177                     
  178                     	; ----
  179                     	; return
  180                     	;
  181  01:B6B4  73 28 22  	tii	joy, joytmp, 5	; stash values for next read because CDROM
       01:B6B7  A7 26 05  
       01:B6BA  00        
  182  01:B6BB  73 93 26  	tii	joy6, joytmp6, 5	; may force another read between VSYNC's
       01:B6BE  AC 26 05  
       01:B6C1  00        
  183                     
  184  01:B6C2  60        	rts
  185                     
  186                     
  187           0001      .if !(CDROM)
  188                     	; ----
  189                     	; read 5 joystick values into 'joy' buffer area
  190                     	;
  191  01:B6C3            .readjoys:
  192  01:B6C3  73 28 22  	tii	joy, joyold, 5
       01:B6C6  32 22 05  
       01:B6C9  00        
  193  01:B6CA  A9 01     	lda	#$01		; reset joypad port to joystick #1
  194  01:B6CC  8D 00 10  	sta	joyport
  195  01:B6CF  A9 03     	lda	#$03
  196  01:B6D1  8D 00 10  	sta	joyport
  197  01:B6D4  20 01 B7  	jsr	.delay
  198                     
  199  01:B6D7  C2        	cly			; counter for 5 joypads
  200  01:B6D8  A9 01     .rdlp:	lda	#$01		; first nybble
  201  01:B6DA  8D 00 10  	sta	joyport
  202  01:B6DD  44 22     	bsr	.delay		; required delay (approx 9 cycles)
  203                     
  204  01:B6DF  AD 00 10  	lda	joyport		; fetch first nybble
  205  01:B6E2  0A        	asl a			; shift it to 'high' position within byte
  206  01:B6E3  0A        	asl a
  207  01:B6E4  0A        	asl a
  208  01:B6E5  0A        	asl a
  209  01:B6E6  99 28 22  	sta	joy,Y		; store in 'current' area
  210  01:B6E9  9C 00 10  	stz	joyport		; toggle port (to read other 4 key values)
  211  01:B6EC  44 13     	bsr	.delay		; delay again
  212  01:B6EE  AD 00 10  	lda	joyport		; fetch second nybble
  213  01:B6F1  29 0F     	and	#$0F		; clear unused bits
  214  01:B6F3  19 28 22  	ora	joy,Y		; merge 2 nybbles into 1 byte
  215  01:B6F6  49 FF     	eor	#$FF		; reset 'sense' of keys
  216  01:B6F8  99 28 22  	sta	joy,Y		; store it
  217  01:B6FB  C8        	iny
  218  01:B6FC  C0 05     	cpy	#$05		; cycle for next of 5 joypads
  219  01:B6FE  90 D8     	bcc	.rdlp
  220                     
  221  01:B700  60        	rts
  222                     
  223                     
  224                     	; ----
  225                     	; small delay
  226                     	;
  227  01:B701            .delay:
  228  01:B701  A2 03     	ldx	#3
  229  01:B703  CA        .l6:	dex
  230  01:B704  D0 FD     	bne	.l6
  231  01:B706  60        	rts
  232                     
  233                     .endif	; !(CDROM)
  234                     
  235  01:B707            .bitmsk:
  236  01:B707  01 02 04  	.db $01,$02,$04,$08,$10	; bit-masks for check-reset
       01:B70A  08 10     
  237                     
  238                     	; ----
  239                     	; user routine
  240                     	;
  241           0001      .ifdef HUC
  242  01:B70C            .hook:
  243  01:B70C  6C 86 26  	jmp	[joyhook]
  244                     .endif	; HUC
  245                     
  246                     ; At end of all this lib2_bank stuff, we need to return
  247                     ; to the base context of lib1_bank:
  248                     
  249           0000      	.bank	LIB1_BANK
#[2]   startup.asm
#[1]   beep.s
   15           60C8      	.data
   16           0003      	.bank DATA_BANK
   17                     
   18           FB76      	.code
   19                     
   20                     ;/*
   21                     ; *
   22                     ; * beep - try to manipulate the 4 settings for volume in order to see
   23                     ; *        which ones (or whether all) cause a "pop" style volume spike
   24                     ; *
   25                     ;*/
   26                     ;#include "huc.h"
   27                     ;/*
   28                     ; * backup ram defines
   29                     ; */
   30                     ;#define  BM_OK             0
   31                     ;#define  BM_NOT_FOUND      1
   32                     ;#define  BM_BAD_CHECKSUM   2
   33                     ;#define  BM_DIR_CORRUPTED  3
   34                     ;#define  BM_FILE_EMPTY     4
   35                     ;#define  BM_FULL           5
   36                     ;#define  BM_NOT_FORMATED   0xFF
   37                     ;#define  BRAM_STARTPTR     0x8010
   38                     ;/*
   39                     ; * sprite defines
   40                     ; */
   41                     ;#define  FLIP_X_MASK 0x08
   42                     ;#define  FLIP_Y_MASK 0x80
   43                     ;#define  FLIP_MAS   0x88
   44                     ;#define  SIZE_MAS   0x31
   45                     ;#define  NO_FLIP    0x00
   46                     ;#define  NO_FLIP_X  0x00
   47                     ;#define  NO_FLIP_Y  0x00
   48                     ;#define  FLIP_X     0x08
   49                     ;#define  FLIP_Y     0x80
   50                     ;#define  SZ_16x16   0x00
   51                     ;#define  SZ_16x32   0x10
   52                     ;#define  SZ_16x64   0x30
   53                     ;#define  SZ_32x16   0x01
   54                     ;#define  SZ_32x32   0x11
   55                     ;#define  SZ_32x64   0x31
   56                     ;/*
   57                     ; * joypad defines
   58                     ; */
   59                     ;#define	JOY_A		0x01
   60                     ;#define	JOY_I		0x01
   61                     ;#define	JOY_B		0x02
   62                     ;#define	JOY_II		0x02
   63                     ;#define	JOY_SLCT	0x04
   64                     ;#define	JOY_SEL		0x04
   65                     ;#define	JOY_STRT	0x08
   66                     ;#define	JOY_RUN		0x08
   67                     ;#define	JOY_UP		0x10
   68                     ;#define	JOY_RGHT	0x20
   69                     ;#define	JOY_RIGHT	0x20
   70                     ;#define	JOY_DOWN	0x40
   71                     ;#define	JOY_LEFT	0x80
   72                     ;#define	JOY_C		0x0100
   73                     ;#define	JOY_III		0x0100
   74                     ;#define	JOY_D		0x0200
   75                     ;#define	JOY_IV		0x0200
   76                     ;#define	JOY_E		0x0400
   77                     ;#define	JOY_V		0x0400
   78                     ;#define	JOY_F		0x0800
   79                     ;#define	JOY_VI		0x0800
   80                     ;#define JOY_SIXBUT	0x5000
   81                     ;#define JOY_TYPE6	0x5000
   82                     ;/*
   83                     ; * screen defines
   84                     ; */
   85                     ;#define	SCR_SIZE_32x32	0
   86                     ;#define	SCR_SIZE_64x32	1
   87                     ;#define	SCR_SIZE_128x32	3
   88                     ;#define	SCR_SIZE_32x64	4
   89                     ;#define	SCR_SIZE_64x64	5
   90                     ;#define	SCR_SIZE_128x64	7
   91                     ;#define	XRES_SHARP	0
   92                     ;#define	XRES_SOFT	4
   93                     ;/*
   94                     ; * CD defines
   95                     ; */
   96                     ;#define	CDPLAY_MUTE		0
   97                     ;#define	CDPLAY_REPEAT		1
   98                     ;#define	CDPLAY_NORMAL		2
   99                     ;#define	CDPLAY_ENDOFDISC	0
  100                     ;#define	CDFADE_CANCEL	0
  101                     ;#define	CDFADE_PCM6	8
  102                     ;#define	CDFADE_ADPCM6	10
  103                     ;#define	CDFADE_PCM2	12
  104                     ;#define	CDFADE_ADPCM2	14
  105                     ;#define CDTRK_AUDIO	0
  106                     ;#define CDTRK_DATA	4
  107                     ;/*
  108                     ; * ADPCM defines
  109                     ; */
  110                     ;#define	ADPLAY_AUTOSTOP		0
  111                     ;#define	ADPLAY_REPEAT		0x80
  112                     ;#define ADPLAY_FREQ_16KHZ	0xE
  113                     ;#define ADPLAY_FREQ_10KHZ	0xD
  114                     ;#define ADPLAY_FREQ_8KHZ	0xC
  115                     ;#define ADPLAY_FREQ_6KHZ	0xB
  116                     ;#define ADPLAY_FREQ_5KHZ	0xA
  117                     ;#define ADREAD_RAM	0
  118                     ;#define ADREAD_VRAM	0xFF
  119                     ;#define ADWRITE_RAM	0
  120                     ;#define ADWRITE_VRAM	0xFF
  121                     ;void vsync(void);
  122                     ;void satb_update(void);
  123                     ;void __fastcall vsync(unsigned char num<acc>);
  124                     ;void __fastcall satb_update(unsigned char max<acc>);
  125                     ;void __fastcall vreg(unsigned char reg<acc>);
  126                     ;void __fastcall vreg(unsigned char reg<__al>, unsigned int data<acc>);
  127                     ;void __fastcall spr_hide(unsigned char num<acc>);
  128                     ;void __fastcall spr_show(unsigned char num<acc>);
  129                     ;void __fastcall set_map_pals(char far *pal<__bl:__si>);
  130                     ;void set_map_tile_type(unsigned char);
  131                     ;void set_map_tile_base(unsigned int vaddr);
  132                     ;unsigned char mem_mapdatabank(unsigned char new_bank);
  133                     ;unsigned int mem_mapdatabanks(unsigned int new_banks);
  134                     ;void timer_set(unsigned char cnt);
  135                     ;void timer_start(void);
  136                     ;void timer_stop(void);
  137                     ;unsigned char timer_get(void);
  138                     ;void irq_enable(unsigned char irq);
  139                     ;void irq_disable(unsigned char irq);
  140                     ;#define STATUS_LINE   3
  141                     ;   char glb_bal;
  142                     ;   char chn_bal;
  143                     ;   char ctrl;
  144                     ;#asm
  145  00:FB76            _beepsetup:
  146  00:FB76  A9 02         lda #2
  147  00:FB78  8D 00 08      sta psg_ch
  148  00:FB7B  A9 FF         lda #$FF
  149  00:FB7D  8D 01 08      sta psg_mainvol
  150  00:FB80  A9 1C         lda #$1C	; 4KHz
  151  00:FB82  8D 02 08      sta psg_freqlo
  152  00:FB85  9C 03 08      stz psg_freqhi
  153  00:FB88  A9 00         lda	#$0
  154  00:FB8A  8D 04 08      sta psg_ctrl
  155  00:FB8D  A9 1F         lda #$1F
  156  00:FB8F  A2 10         ldx #16
  157  00:FB91            .loop:
  158  00:FB91  8D 06 08      sta psg_wavebuf
  159  00:FB94  CA            dex
  160  00:FB95  D0 FA         bne .loop
  161  00:FB97  A9 00         lda #$0
  162  00:FB99  A2 10         ldx #16
  163  00:FB9B            .loop1:
  164  00:FB9B  8D 06 08      sta psg_wavebuf
  165  00:FB9E  CA            dex
  166  00:FB9F  D0 FA         bne .loop1
  167  00:FBA1  A9 FF         lda #$FF
  168  00:FBA3  8D 05 08      sta psg_pan
  169  00:FBA6  A9 9F         lda #$9f
  170  00:FBA8  8D 04 08      sta psg_ctrl
  171  00:FBAB  60            rts
  172  00:FBAC            _beepoff:
  173  00:FBAC  A9 00         lda #$0
  174  00:FBAE  8D 04 08      sta psg_ctrl
  175  00:FBB1  60            rts
  176  00:FBB2            _beepon:
  177  00:FBB2  A9 9F         lda #$9f
  178  00:FBB4  8D 04 08      sta psg_ctrl
  179  00:FBB7  60            rts
  180                     ;char a;
  181                     ;main()
  182                     ;{
  183  04:4000            	.proc _main
  184                     ;   set_color(0,0);
  185                     	__ldwi	0
       04:A000  A2 00     	ldx	#low(0)
       04:A002  A9 00     	lda	#high(0)
  186                     	__stw	color_reg
       04:A004  8E 02 04  	stx	color_reg
       04:A007  8D 03 04  	sta	color_reg+1
  187                     	__ldwi	0
       04:A00A  A2 00     	ldx	#low(0)
       04:A00C  A9 00     	lda	#high(0)
  188                     	__stw	color_data
       04:A00E  8E 04 04  	stx	color_data
       04:A011  8D 05 04  	sta	color_data+1
  189                     ;   set_color(1,511);
  190                     	__ldwi	1
       04:A014  A2 01     	ldx	#low(1)
       04:A016  A9 00     	lda	#high(1)
  191                     	__stw	color_reg
       04:A018  8E 02 04  	stx	color_reg
       04:A01B  8D 03 04  	sta	color_reg+1
  192                     	__ldwi	511
       04:A01E  A2 FF     	ldx	#low(511)
       04:A020  A9 01     	lda	#high(511)
  193                     	__stw	color_data
       04:A022  8E 04 04  	stx	color_data
       04:A025  8D 05 04  	sta	color_data+1
  194                     ;   beepsetup();
  195  04:A028  20 76 FB  	  call	_beepsetup
  196                     ;   beepoff();
  197  04:A02B  20 AC FB  	  call	_beepoff
  198                     ;   while (1) {
  199  04:A02E            LL2:
  200                     
  201                     	__ldwi	1
       04:A02E  A2 01     	ldx	#low(1)
       04:A030  A9 00     	lda	#high(1)
  202                     	__tstw
                          	; pha
       04:A032  86 02     	stx	<__temp
       04:A034  05 02     	ora	<__temp
       04:A036  62        	cla
       04:A037  82        	clx
       04:A038  F0 01     	beq	.x_00548
       04:A03A  E8        	inx
       04:A03B            .x_00548:
                          	; pla
  203                     	__lbeq	LL3
       04:A03B  E0 00     	cpx	#0
       04:A03D  D0 03     	bne	.x00549
       04:A03F  4C F8 A1  	jmp	LL3
       04:A042            .x00549
  204                     ;      vsync(0);
  205                     	__ldwi	0
       04:A042  A2 00     	ldx	#low(0)
       04:A044  A9 00     	lda	#high(0)
  206  04:A046  20 55 EF  	  call	_vsync.1
  207                     ;      a = joy(0);
  208                     	__ldwi	0
       04:A049  A2 00     	ldx	#low(0)
       04:A04B  A9 00     	lda	#high(0)
  209  04:A04D  20 53 F9  	  call	_joy
  210  04:A050  8E 94 29  	  stx	_a
  211                     ;      if (a & JOY_DOWN) {
  212                     	__ldub	_a
                0000      .if (1 = 2)
                          .else
       04:A053  AE 94 29  	ldx	_a
       04:A056  62        	cla
                          .endif
  213                     	__andwi	64
       04:A057  22        	sax
       04:A058  29 40     	and	#low(64)
       04:A05A  22        	sax
       04:A05B  29 00     	and	#high(64)
  214                     	__tstw
                          	; pha
       04:A05D  86 02     	stx	<__temp
       04:A05F  05 02     	ora	<__temp
       04:A061  62        	cla
       04:A062  82        	clx
       04:A063  F0 01     	beq	.x_00554
       04:A065  E8        	inx
       04:A066            .x_00554:
                          	; pla
  215                     	__lbeq	LL4
       04:A066  E0 00     	cpx	#0
       04:A068  D0 03     	bne	.x00555
       04:A06A  4C 95 A0  	jmp	LL4
       04:A06D            .x00555
  216                     ;         put_string("D", 1, STATUS_LINE);
  217                     	__ldwi	LL0+0
       04:A06D  A2 00     	ldx	#low(LL0+0)
       04:A06F  A9 40     	lda	#high(LL0+0)
  218                     	__stw	__si
       04:A071  8E EE 20  	stx	__si
       04:A074  8D EF 20  	sta	__si+1
  219                     	__ldwi	1
       04:A077  A2 01     	ldx	#low(1)
       04:A079  A9 00     	lda	#high(1)
  220  04:A07B  8E FA 20  	  stx	__bl
  221                     	__ldwi	3
       04:A07E  A2 03     	ldx	#low(3)
       04:A080  A9 00     	lda	#high(3)
  222  04:A082  20 23 EF  	  call	_put_string.3
  223                     ;	 ctrl = (ctrl & 0x80);
  224                     	__ldub	_ctrl
                0000      .if (1 = 2)
                          .else
       04:A085  AE 93 29  	ldx	_ctrl
       04:A088  62        	cla
                          .endif
  225                     	__andwi	128
       04:A089  22        	sax
       04:A08A  29 80     	and	#low(128)
       04:A08C  22        	sax
       04:A08D  29 00     	and	#high(128)
  226  04:A08F  8E 93 29  	  stx	_ctrl
  227                     ;      } else {
  228                     	__lbra	LL5
       04:A092  4C C0 A0  	jmp	LL5
  229  04:A095            LL4:
  230                     
  231                     ;         put_string(" ", 1, STATUS_LINE);
  232                     	__ldwi	LL0+2
       04:A095  A2 02     	ldx	#low(LL0+2)
       04:A097  A9 40     	lda	#high(LL0+2)
  233                     	__stw	__si
       04:A099  8E EE 20  	stx	__si
       04:A09C  8D EF 20  	sta	__si+1
  234                     	__ldwi	1
       04:A09F  A2 01     	ldx	#low(1)
       04:A0A1  A9 00     	lda	#high(1)
  235  04:A0A3  8E FA 20  	  stx	__bl
  236                     	__ldwi	3
       04:A0A6  A2 03     	ldx	#low(3)
       04:A0A8  A9 00     	lda	#high(3)
  237  04:A0AA  20 23 EF  	  call	_put_string.3
  238                     ;	 ctrl = (ctrl & 0x80) | 0x1f;
  239                     	__ldub	_ctrl
                0000      .if (1 = 2)
                          .else
       04:A0AD  AE 93 29  	ldx	_ctrl
       04:A0B0  62        	cla
                          .endif
  240                     	__andwi	128
       04:A0B1  22        	sax
       04:A0B2  29 80     	and	#low(128)
       04:A0B4  22        	sax
       04:A0B5  29 00     	and	#high(128)
  241                     	__orwi	31
       04:A0B7  22        	sax
       04:A0B8  09 1F     	ora	#low(31)
       04:A0BA  22        	sax
       04:A0BB  09 00     	ora	#high(31)
  242  04:A0BD  8E 93 29  	  stx	_ctrl
  243                     ;      }
  244  04:A0C0            LL5:
  245                     
  246                     ;      if (a & JOY_SEL) {
  247                     	__ldub	_a
                0000      .if (1 = 2)
                          .else
       04:A0C0  AE 94 29  	ldx	_a
       04:A0C3  62        	cla
                          .endif
  248                     	__andwi	4
       04:A0C4  22        	sax
       04:A0C5  29 04     	and	#low(4)
       04:A0C7  22        	sax
       04:A0C8  29 00     	and	#high(4)
  249                     	__tstw
                          	; pha
       04:A0CA  86 02     	stx	<__temp
       04:A0CC  05 02     	ora	<__temp
       04:A0CE  62        	cla
       04:A0CF  82        	clx
       04:A0D0  F0 01     	beq	.x_00572
       04:A0D2  E8        	inx
       04:A0D3            .x_00572:
                          	; pla
  250                     	__lbeq	LL6
       04:A0D3  E0 00     	cpx	#0
       04:A0D5  D0 03     	bne	.x00573
       04:A0D7  4C 02 A1  	jmp	LL6
       04:A0DA            .x00573
  251                     ;         put_string("S", 2, STATUS_LINE);
  252                     	__ldwi	LL0+4
       04:A0DA  A2 04     	ldx	#low(LL0+4)
       04:A0DC  A9 40     	lda	#high(LL0+4)
  253                     	__stw	__si
       04:A0DE  8E EE 20  	stx	__si
       04:A0E1  8D EF 20  	sta	__si+1
  254                     	__ldwi	2
       04:A0E4  A2 02     	ldx	#low(2)
       04:A0E6  A9 00     	lda	#high(2)
  255  04:A0E8  8E FA 20  	  stx	__bl
  256                     	__ldwi	3
       04:A0EB  A2 03     	ldx	#low(3)
       04:A0ED  A9 00     	lda	#high(3)
  257  04:A0EF  20 23 EF  	  call	_put_string.3
  258                     ;	 ctrl = (ctrl & 0x1f);
  259                     	__ldub	_ctrl
                0000      .if (1 = 2)
                          .else
       04:A0F2  AE 93 29  	ldx	_ctrl
       04:A0F5  62        	cla
                          .endif
  260                     	__andwi	31
       04:A0F6  22        	sax
       04:A0F7  29 1F     	and	#low(31)
       04:A0F9  22        	sax
       04:A0FA  29 00     	and	#high(31)
  261  04:A0FC  8E 93 29  	  stx	_ctrl
  262                     ;      } else {
  263                     	__lbra	LL7
       04:A0FF  4C 2D A1  	jmp	LL7
  264  04:A102            LL6:
  265                     
  266                     ;         put_string(" ", 2, STATUS_LINE);
  267                     	__ldwi	LL0+6
       04:A102  A2 06     	ldx	#low(LL0+6)
       04:A104  A9 40     	lda	#high(LL0+6)
  268                     	__stw	__si
       04:A106  8E EE 20  	stx	__si
       04:A109  8D EF 20  	sta	__si+1
  269                     	__ldwi	2
       04:A10C  A2 02     	ldx	#low(2)
       04:A10E  A9 00     	lda	#high(2)
  270  04:A110  8E FA 20  	  stx	__bl
  271                     	__ldwi	3
       04:A113  A2 03     	ldx	#low(3)
       04:A115  A9 00     	lda	#high(3)
  272  04:A117  20 23 EF  	  call	_put_string.3
  273                     ;	 ctrl = (ctrl & 0x1f) | 0x80;
  274                     	__ldub	_ctrl
                0000      .if (1 = 2)
                          .else
       04:A11A  AE 93 29  	ldx	_ctrl
       04:A11D  62        	cla
                          .endif
  275                     	__andwi	31
       04:A11E  22        	sax
       04:A11F  29 1F     	and	#low(31)
       04:A121  22        	sax
       04:A122  29 00     	and	#high(31)
  276                     	__orwi	128
       04:A124  22        	sax
       04:A125  09 80     	ora	#low(128)
       04:A127  22        	sax
       04:A128  09 00     	ora	#high(128)
  277  04:A12A  8E 93 29  	  stx	_ctrl
  278                     ;      }
  279  04:A12D            LL7:
  280                     
  281                     ;      if (a & JOY_II) {
  282                     	__ldub	_a
                0000      .if (1 = 2)
                          .else
       04:A12D  AE 94 29  	ldx	_a
       04:A130  62        	cla
                          .endif
  283                     	__andwi	2
       04:A131  22        	sax
       04:A132  29 02     	and	#low(2)
       04:A134  22        	sax
       04:A135  29 00     	and	#high(2)
  284                     	__tstw
                          	; pha
       04:A137  86 02     	stx	<__temp
       04:A139  05 02     	ora	<__temp
       04:A13B  62        	cla
       04:A13C  82        	clx
       04:A13D  F0 01     	beq	.x_00590
       04:A13F  E8        	inx
       04:A140            .x_00590:
                          	; pla
  285                     	__lbeq	LL8
       04:A140  E0 00     	cpx	#0
       04:A142  D0 03     	bne	.x00591
       04:A144  4C 69 A1  	jmp	LL8
       04:A147            .x00591
  286                     ;         put_string("2", 3, STATUS_LINE);
  287                     	__ldwi	LL0+8
       04:A147  A2 08     	ldx	#low(LL0+8)
       04:A149  A9 40     	lda	#high(LL0+8)
  288                     	__stw	__si
       04:A14B  8E EE 20  	stx	__si
       04:A14E  8D EF 20  	sta	__si+1
  289                     	__ldwi	3
       04:A151  A2 03     	ldx	#low(3)
       04:A153  A9 00     	lda	#high(3)
  290  04:A155  8E FA 20  	  stx	__bl
  291                     	__ldwi	3
       04:A158  A2 03     	ldx	#low(3)
       04:A15A  A9 00     	lda	#high(3)
  292  04:A15C  20 23 EF  	  call	_put_string.3
  293                     ;	 glb_bal = 0;
  294                     	__ldwi	0
       04:A15F  A2 00     	ldx	#low(0)
       04:A161  A9 00     	lda	#high(0)
  295  04:A163  8E 91 29  	  stx	_glb_bal
  296                     ;      } else {
  297                     	__lbra	LL9
       04:A166  4C 88 A1  	jmp	LL9
  298  04:A169            LL8:
  299                     
  300                     ;         put_string(" ", 3, STATUS_LINE);
  301                     	__ldwi	LL0+10
       04:A169  A2 0A     	ldx	#low(LL0+10)
       04:A16B  A9 40     	lda	#high(LL0+10)
  302                     	__stw	__si
       04:A16D  8E EE 20  	stx	__si
       04:A170  8D EF 20  	sta	__si+1
  303                     	__ldwi	3
       04:A173  A2 03     	ldx	#low(3)
       04:A175  A9 00     	lda	#high(3)
  304  04:A177  8E FA 20  	  stx	__bl
  305                     	__ldwi	3
       04:A17A  A2 03     	ldx	#low(3)
       04:A17C  A9 00     	lda	#high(3)
  306  04:A17E  20 23 EF  	  call	_put_string.3
  307                     ;	 glb_bal = 255;
  308                     	__ldwi	255
       04:A181  A2 FF     	ldx	#low(255)
       04:A183  A9 00     	lda	#high(255)
  309  04:A185  8E 91 29  	  stx	_glb_bal
  310                     ;      }
  311  04:A188            LL9:
  312                     
  313                     ;      if (a & JOY_I) {
  314                     	__ldub	_a
                0000      .if (1 = 2)
                          .else
       04:A188  AE 94 29  	ldx	_a
       04:A18B  62        	cla
                          .endif
  315                     	__andwi	1
       04:A18C  22        	sax
       04:A18D  29 01     	and	#low(1)
       04:A18F  22        	sax
       04:A190  29 00     	and	#high(1)
  316                     	__tstw
                          	; pha
       04:A192  86 02     	stx	<__temp
       04:A194  05 02     	ora	<__temp
       04:A196  62        	cla
       04:A197  82        	clx
       04:A198  F0 01     	beq	.x_00605
       04:A19A  E8        	inx
       04:A19B            .x_00605:
                          	; pla
  317                     	__lbeq	LL10
       04:A19B  E0 00     	cpx	#0
       04:A19D  D0 03     	bne	.x00606
       04:A19F  4C C4 A1  	jmp	LL10
       04:A1A2            .x00606
  318                     ;         put_string("1", 4, STATUS_LINE);
  319                     	__ldwi	LL0+12
       04:A1A2  A2 0C     	ldx	#low(LL0+12)
       04:A1A4  A9 40     	lda	#high(LL0+12)
  320                     	__stw	__si
       04:A1A6  8E EE 20  	stx	__si
       04:A1A9  8D EF 20  	sta	__si+1
  321                     	__ldwi	4
       04:A1AC  A2 04     	ldx	#low(4)
       04:A1AE  A9 00     	lda	#high(4)
  322  04:A1B0  8E FA 20  	  stx	__bl
  323                     	__ldwi	3
       04:A1B3  A2 03     	ldx	#low(3)
       04:A1B5  A9 00     	lda	#high(3)
  324  04:A1B7  20 23 EF  	  call	_put_string.3
  325                     ;	 chn_bal = 0;
  326                     	__ldwi	0
       04:A1BA  A2 00     	ldx	#low(0)
       04:A1BC  A9 00     	lda	#high(0)
  327  04:A1BE  8E 92 29  	  stx	_chn_bal
  328                     ;      } else {
  329                     	__lbra	LL11
       04:A1C1  4C E3 A1  	jmp	LL11
  330  04:A1C4            LL10:
  331                     
  332                     ;         put_string(" ", 4, STATUS_LINE);
  333                     	__ldwi	LL0+14
       04:A1C4  A2 0E     	ldx	#low(LL0+14)
       04:A1C6  A9 40     	lda	#high(LL0+14)
  334                     	__stw	__si
       04:A1C8  8E EE 20  	stx	__si
       04:A1CB  8D EF 20  	sta	__si+1
  335                     	__ldwi	4
       04:A1CE  A2 04     	ldx	#low(4)
       04:A1D0  A9 00     	lda	#high(4)
  336  04:A1D2  8E FA 20  	  stx	__bl
  337                     	__ldwi	3
       04:A1D5  A2 03     	ldx	#low(3)
       04:A1D7  A9 00     	lda	#high(3)
  338  04:A1D9  20 23 EF  	  call	_put_string.3
  339                     ;	 chn_bal = 255;
  340                     	__ldwi	255
       04:A1DC  A2 FF     	ldx	#low(255)
       04:A1DE  A9 00     	lda	#high(255)
  341  04:A1E0  8E 92 29  	  stx	_chn_bal
  342                     ;      }
  343  04:A1E3            LL11:
  344                     
  345                     ;#asm
  346  04:A1E3  AD 91 29        lda _glb_bal
  347  04:A1E6  8D 01 08        sta psg_mainvol
  348  04:A1E9  AD 92 29        lda _chn_bal
  349  04:A1EC  8D 05 08        sta psg_pan
  350  04:A1EF  AD 93 29        lda _ctrl
  351  04:A1F2  8D 04 08        sta psg_ctrl
  352                     ;   }
  353                     	__lbra	LL2
       04:A1F5  4C 2E A0  	jmp	LL2
  354  04:A1F8            LL3:
  355                     
  356                     ;   return;
  357                     	__lbra	LL1
       04:A1F8  4C FB A1  	jmp	LL1
  358                     ;}
  359  04:A1FB            LL1:
  360                     
  361  04:A1FB  60        	  rts
  362                     	.endp
  363                     
  364           60C8      	.data
  365           0002      	.bank CONST_BANK
  366  02:4000            LL0:
  367  02:4000  44 00 20  	.db	68,0,32,0,83,0,32,0
       02:4003  00 53 00  
       02:4006  20 00     
  368  02:4008  32 00 20  	.db	50,0,32,0,49,0,32,0
       02:400B  00 31 00  
       02:400E  20 00     
  369                     
  370           2991      	.bss
  371  --:2991            _glb_bal:		.ds	1
  372  --:2992            _chn_bal:		.ds	1
  373  --:2993            _ctrl:		.ds	1
  374  --:2994            _a:		.ds	1
  375                     
  376                     
  377                     ;0 error(s) in compilation
  378                     ;	literal pool:16
  379                     ;	constant pool:0
  380                     ;	global pool:31
  381                     ;	Macro pool:81
  382  --:2995            huc_rodata:
  383  --:2995            __huc_rodata:
  384  --:2995            huc_rodata_end:
  385  --:2995            __huc_rodata_end:
  386  --:2995            huc_data:
  387  --:2995            __huc_data:
  388  --:2995            huc_data_end:
  389  --:2995            __huc_data_end:
  390  --:2995            __heap_start:
